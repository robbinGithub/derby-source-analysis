
###############################################################################
#
# Text for exceptions
#
###############################################################################

# Monitor
XBM01.D=Der Systemstart ist aufgrund einer Ausnahme gescheitert. Details enth\u00e4lt die n\u00e4chste Ausnahme.
XBM02.D=Der Systemstart ist aufgrund fehlender Funktionalit\u00e4t f\u00fcr {0} gescheitert. Stellen Sie sicher, dass der Klassenpfad die richtige Derby-Software enth\u00e4lt.
XBM05.D=Der Systemstart ist aufgrund der fehlenden Produktversionsnummer f\u00fcr {0} gescheitert.
XBM06.D=Der Systemstart ist gescheitert. Auf eine verschl\u00fcsselte Datenbank kann nur mit dem richtigen Boot-Kennwort zugegriffen werden.
XBM07.D=Der Systemstart ist gescheitert. Das Boot-Passwort muss eine Mindestl\u00e4nge von 8 Bytes haben.
XBM08.D=Die StorageFactory-Klasse {1} unter {0} konnte nicht instanziiert werden.

XBM0G.D=Die Verschl\u00fcsselungssteuerkomponente konnte nicht gestartet werden. Vergewissern Sie sich, dass Sie Java 2 ausf\u00fchren und einen Verschl\u00fcsselungsprovider wie JCE heruntergeladen und in den Klassenpfad aufgenommen haben.
XBM0H.D=Das Verzeichnis {0} kann nicht erstellt werden.
XBM0I.D=Das Verzeichnis {0} kann nicht entfernt werden.
XBM0J.D=Das Verzeichnis {0} ist bereits vorhanden.
XBM0K.D=Unbekanntes Unterprotokoll f\u00fcr den Datenbanknamen {0}.
XBM0L.D=Die angegebene Authentifizierungsschemaklasse {0} implementiert nicht die Authentifizierungsschnittstelle {1}.
XBM0M.D=Fehler beim Erstellen einer Instanz der Authentifizierungsschemaklasse {0}.
XBM0N.D=Die JDBC-Treiberregistrierung mit java.sql.DriverManager ist gescheitert. Details enth\u00e4lt die n\u00e4chste Ausnahme.
XBM0P.D=Der Serviceprovider ist nur im Lesezugriff verf\u00fcgbar. F\u00fcr die Operation liegt keine Berechtigung vor.
XBM0S.D=Die Datei ''{0}'' kann nicht in ''{1}'' umbenannt werden.
XBM0T.D=Mehrdeutiges Unterprotokoll f\u00fcr den Datenbanknamen {0}.
XBM0U.S=F\u00fcr die ID {0} wurde keine Klasse registriert.
XBM0V.S=Beim Laden der f\u00fcr die ID {0} registrierten Klasse {1} wurde eine Ausnahme ausgel\u00f6st.
XBM0W.S=Beim Erstellen einer Instanz der f\u00fcr die ID {0} registrierten Klasse {1} wurde eine Ausnahme ausgel\u00f6st.
XBM0X.D=Das angegebene Gebietsschema ''{0}'' ist ung\u00fcltig. Erwartet wurde ln[_CO[_variant]]\nln = zwei Kleinbuchstaben des ISO-639-Sprachencodes, CO = zwei Gro\u00dfbuchstaben der ISO-3166-Sprachencodes. Siehe java.util.Locale.
XBM0Y.D=Das Sicherungsdatenbankverzeichnis {0} wurde nicht gefunden. Vergewissern Sie sich, dass der angegebene Sicherungspfad stimmt.
XBM0Z.D=Die Datei ''{0}'' kann nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00fcgbar ist und dass die notwendigen Berechtigungen vorliegen. 
XBM0Q.D=Die Datei {0} wurde nicht gefunden. Vergewissern Sie sich, dass es sich um die richtige Sicherungskopie handelt und dass diese nicht besch\u00e4digt ist.
XBM0R.D=Die Datei {0} kann nicht entfernt werden.

# Upgrade
XCW00.D=Ein Upgrade von ''{0}'' auf ''{1}'' wird nicht unterst\u00fctzt.

# Feature not supported


# COntext service
08000=Die Verbindung wurde von einer unbekannten Unterbrechung aufgehoben.

#../java/com/ibm/db2j/protocol/BasicServices/LockManager/messages.properties
40001=Eine Sperre konnte aufgrund einer Verklemmung nicht angefordert werden. Zyklus der Sperren und beantragten Sperren:\n{0} Die ausgew\u00e4hlte Opfertransaktion ist XID : {1}

40XL1=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden.
40XL2=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden. Speicherauszug der Sperrentabelle: {0}

# ClassManager
XBCM1.S=Beim Laden der generierten Klasse {0} wurde ein Java-Verbindungsfehler ausgel\u00f6st.
XBCM2.S=Es kann keine Instanz der generierten Klasse {0} erstellt werden.
XBCM3.S=Die Methode {1}() ist in der generierten Klasse {0} nicht vorhanden.

# Properties

XCY00.S=Ung\u00fcltiger Wert f\u00fcr das Merkmal ''{0}''=''{1}''.
XCY02.S=Die angeforderte Merkmal\u00e4nderung wird nicht unterst\u00fctzt; ''{0}''=''{1}''.
XCY03.S=Das erforderliche Merkmal ''{0}'' wurde nicht definiert.

# Cryptography
XBCX0.S=Ausnahme vom Verschl\u00fcsselungsprovider. Details enth\u00e4lt die n\u00e4chste Ausnahme.
XBCX1.S=Sie initialisieren das Verschl\u00fcsselungsverfahren mit einem ung\u00fcltigen Modus. Der Modus muss ENCRYPT oder DECRYPT sein.
XBCX2.S=Sie initialisieren das Verschl\u00fcsselungsverfahren mit einem zu kurzen Boot-Kennwort. Das Kennwort muss aus mindestens {0} Zeichen bestehen.
XBCX5.S=Das Boot-Kennwort kann nicht in eine Nullzeichenfolge ge\u00e4ndert werden.
XBCX6.S=Das Boot-Kennwort kann nicht in einen serialisierbaren Typ, der keine Zeichenfolge ist, ge\u00e4ndert werden.
XBCX7.S=Falsches Format f\u00fcr das \u00c4ndern des Boot-Kennworts. G\u00fcltiges Format: altes_Boot-Kennwort, neues_Boot-Kennwort.
XBCX8.S=Das Boot-Kennwort f\u00fcr eine nicht verschl\u00fcsselte Datenbank kann nicht ge\u00e4ndert werden.
XBCX9.S=Das Boot-Kennwort f\u00fcr eine Datenbank mit Lesezugriff kann nicht ge\u00e4ndert werden.
XBCXA.S=Falsches Boot-Kennwort.
XBCXB.S=Die Verschl\u00fcsselungsauff\u00fcllung ''{0}'' ist fehlerhaft oder es wurde keine Auff\u00fcllung angegeben. Es muss ''Keine Auff\u00fcllung'' verwendet werden.
XBCXC.S=Der Verschl\u00fcsselungsalgorithmus ''{0}'' ist nicht vorhanden. \u00dcberpr\u00fcfen Sie, ob der ausgew\u00e4hlte Provider ''{1}'' diesen Algorithmus unterst\u00fctzt.
XBCXD.S=Der Verschl\u00fcsselungsalgorithmus kann nach dem Erstellen der Datenbank nicht ge\u00e4ndert werden.
XBCXE.S=Der Verschl\u00fcsselungsprovider kann nach dem Erstellen der Datenbank nicht ge\u00e4ndert werden.
XBCXF.S=Die Klasse ''{0}'', die den Verschl\u00fcsselungsprovider repr\u00e4sentiert, wurde nicht gefunden.
XBCXG.S=Der Verschl\u00fcsselungsprovider ''{0}'' ist nicht vorhanden.
XBCXH.S=Der Verschl\u00fcsselungsalgorithmus ''{0}'' hat nicht das richtige Format. Korrektes Format: Algorithmus/Feedbackmodus/Keine Auff\u00fcllung.
XBCXI.S=Der Feedbackmodus ''{0}'' wird nicht unterst\u00fctzt. Unterst\u00fctzte Feedbackmodi sind CBC, CFB, OFB und ECB.
XBCXJ.S=Die Anwendung verwendet eine \u00e4ltere JCE-Version (Java Cryptography Extension) als 1.2.1. F\u00fchren Sie ein Upgrade auf JCE 1.2.1 durch und wiederholen Sie die Operation.
XBCXK.S=Der angegebene Chiffrierschl\u00fcssel stimmt nicht mit dem bei der Erstellung der Datenbank verwendeten Chiffrierschl\u00fcssel \u00fcberein. Vergewissern Sie sich, dass Sie den richtigen Chiffrierschl\u00fcssel verwenden, und versuchen Sie es erneut. 
XBCXL.S=Der Pr\u00fcfprozess f\u00fcr den Chiffrierschl\u00fcssel war nicht erfolgreich. Die folgende Ausnahme enth\u00e4lt weitere Details. Als Ursache kommt ein Fehler beim Zugriff auf die Datei f\u00fcr die Ausf\u00fchrung des Pr\u00fcfprozesses in Frage.

#../java/com/ibm/db2j/impl/BasicServices/CacheService/Generic/messages.properties

# CacheStatementException messages
# sqlstate range: XBCA0 to XBCAZ

XBCA0.S=Im {0}-Cache kann kein neues Objekt mit dem Schl\u00fcssel {1} erstellt werden, da es bereits im Cache vorhanden ist.


# java/com/ibm/db2j/protocol/Database/Storage/Access/Interface.
# sqlstate range: XSAI0 to XSAIZ
XSAI2.S=Das angeforderte Konglomerat ({0}) ist nicht vorhanden.
XSAI3.S=Ein Feature ist nicht implementiert.

# java/com/ibm/db2j/protocol/Database/Storage/Access/Interface
# RunTimeStatistics properties messages.
# sqlstate range: XSAJ0 to XSAJZ
XSAJ0.U=Suchtyp
XSAJ1.U=Anzahl der besuchten Seiten
XSAJ2.U=Anzahl der besuchten Zeilen
XSAJ3.U=Anzahl der gel\u00f6schten besuchten Zeilen
XSAJ4.U=Anzahl der qualifizierten Zeilen
XSAJ5.U=Anzahl der abgerufenen Spalten
XSAJ6.U=Bits der abgerufenen Spalten
XSAJ7.U=Tiefe der Baumstruktur
XSAJ8.U=Sortiertyp
XSAJA.U=Anzahl der eingegebenen Zeilen
XSAJB.U=Anzahl der ausgegebenen Zeilen
XSAJC.U=Anzahl der Mischvorg\u00e4nge
XSAJD.U=Umfang der Mischvorg\u00e4nge
XSAJE.U=Alle

#NOTE: The next three messages are the names of types of scans.
XSAJF.U=B-Baumstruktur
XSAJG.U=Heap-Speicher
XSAJH.U=Sortierung

#NOTE: The next two messages are types of sorts
XSAJI.U=\u00e4u\u00dfere
XSAJJ.U=innere

# java/com/ibm/db2j/protocol/Database/Storage/Access/XA.
# sqlstate range: XSAX0 to XSAXZ
XSAX0.S=Fehlerhaftes XA-Protokoll.
XSAX1.S=Es wurde versucht, eine globale Transaktion mit der XID einer vorhandenen globalen Transaktion zu starten.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/AccessManager/Generic
# sqlstate range: XSAM0 to XSAMZ
XSAM0.S=Bei dem Versuch, ein Modul f\u00fcr ''{0}'' zu booten, ist eine Ausnahme eingetreten.
XSAM2.S=Es ist kein Index oder Konglomerat mit der Konglomerat-ID ''{0}'' zum Freigeben vorhanden.
XSAM3.S=Es ist kein Index oder Konglomerat mit der Konglomerat-ID ''{0}'' vorhanden.
XSAM4.S=Es gibt keine Sortierung mit der Bezeichnung ''{0}''.
XSAM5.S=Sie m\u00fcssen die Suche \u00f6ffnen und positionieren, indem Sie vor allen anderen Methoden next() aufrufen.
XSAM6.S=Der Datensatz {2} auf Seite {1} im Container {0} wurde nicht gefunden.


#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/Generic
# sqlstate range: XSCG0 to XSCGZ
XSCG0.S=Eine Schablone konnte nicht erstellt werden.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/Heap
# sqlstate range: XSCH0 to XSCHZ

XSCH8.S=Das Feature ist nicht implementiert.
XSCH7.S=Die Suche ist nicht positioniert.
XSCH6.S=Der Heap-Container mit der Container-ID {0} ist geschlossen.
XSCH5.S=In einer Basistabelle wich die Anzahl der angeforderten Spalten ({0}) von der maximalen Spaltenanzahl ({1}) ab.
XSCH4.S=Ein Konglomerat konnte nicht erstellt werden.
XSCH1.S=Der Container {0} wurde nicht gefunden.
XSCH0.S=Ein Container konnte nicht erstellt werden.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/BTree/Generic
# sqlstate range: XSCB0 to XSCBZ
XSCB9.S=F\u00fcr Testzwecke reserviert.
XSCB8.S=Das B-Baum-Konglomerat {0} ist geschlossen.
XSCB7.S=Beim Durchsuchen einer B-Baumstruktur ist ein interner Fehler aufgetreten; current_rh ist null = {0}; der Positionsschl\u00fcssel ist null = {1}.
XSCB6.S=Einschr\u00e4nkung: Der Datensatz f\u00fcr den Sekund\u00e4rindex einer B-Baumstruktur kann wegen unzureichenden Speicherbereichs auf der Seite nicht aktualisiert oder eingef\u00fcgt werden. Verwenden Sie den Parameter derby.storage.pageSize und/oder derby.storage.pageReservedSpace, um diese Einschr\u00e4nkung zu umgehen.
XSCB5.S=W\u00e4hrend des logischen Widerrufs einer Einf\u00fcge- oder L\u00f6schoperation f\u00fcr eine B-Baumstruktur kann die Zeile in der Baumstruktur nicht gefunden werden.
XSCB4.S=F\u00fcr eine begonnene Suche in einer B-Baumstruktur wurde eine Methode aufgerufen, bevor die Suche in der ersten Zeile positioniert wurde (d. h. next() wurde noch nicht aufgerufen). Der aktuelle Status der Suche ist ({0}).
XSCB3.S=Nicht implementiertes Feature.
XSCB2.S=In der f\u00fcr createConglomerate() f\u00fcr den Sekund\u00e4rindex einer Baumstruktur bereitgestellten Merkmalliste wurde das erforderliche Merkmal {0} nicht gefunden.
XSCB1.S=Der Container {0} wurde nicht gefunden.
XSCB0.S=Ein Container konnte nicht erstellt werden.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Sort/External
# sqlstate range: XSAS0 to XSASZ

XSAS6.S=Es konnten keine Ressourcen f\u00fcr die Sortierung angefordert werden.
XSAS3.S=Der Typ einer in eine Suche eingef\u00fcgten Zeile stimmt nicht mit der Suchschablone \u00fcberein.
XSAS1.S=Es wurde versucht, eine Zeile vor Beginn oder nach Beendigung einer Suche abzurufen.
XSAS0.S=Es wurde eine Schnittstellenmethode des Suchcontrollers aufgerufen, die f\u00fcr das Durchsuchen einer Sortierung nicht geeignet ist.

# java/com/ibm/db2j/protocol/Database/Storage/RawStore/Interface.
# statement errors.
# sqlstate range: XSRS0 to XSRSZ
XSRS0.S=Die Datenbank kann nicht eingefroren werden, da sie bereits eingefroren ist.
XSRS1.S=Die Datenbank kann nicht in {0} gesichert werden, da es sich nicht um ein Verzeichnis handelt.
XSRS4.S=W\u00e4hrend der Sicherung ist ein Fehler beim Umbenennen der Datei von {0} in {1} aufgetreten.
XSRS5.S=W\u00e4hrend der Sicherung ist ein Fehler beim Kopieren der Datei von {0} in {1} aufgetreten.
XSRS6.S=Das Sicherungsverzeichnis {0} kann nicht erstellt werden.
XSRS7.S=Die Sicherung hat eine unerwartete Ausnahme abgefangen.
XSRS8.S=Die Protokolleinheit kann nur beim Erstellen der Datenbank definiert und w\u00e4hrend der Verarbeitung nicht ge\u00e4ndert werden.
XSRS9.S=Der Datensatz {0} ist nicht mehr vorhanden.


# java/com/ibm/db2j/impl/Database/Storage/RawStore/Log/Generic
# statement errors.
# sqlstate range: XSLB0 to XSLBZ
XSLB9.S=Es k\u00f6nnen keine weiteren \u00c4nderungen ausgegeben werden. Die Protokoll-Factory wurde gestoppt.
XSLB8.S=Es wurde versucht, eine Suche auf {0} zur\u00fcckzusetzen. Dieser Wert liegt au\u00dferhalb der Begrenzung {1}.
XSLB6.S=Es wurde versucht, einen Protokollsatz mit der L\u00e4nge 0 oder -ve zu protokollieren.
XSLB5.S=Unzul\u00e4ssiger truncationLWM-Zeitpunkt {1} f\u00fcr Abschneidepunkt {0}. Der g\u00fcltige Bereich liegt zwischen {2} und {3}.
XSLB4.S=truncationLWM {0} wurde nicht gefunden.
XSLB2.S=Die Protokolloperation {0} protokolliert zu viele Daten. Sie hat den internen Protokollpuffer gef\u00fcllt.
XSLB1.S=Die Protokolloperation {0} hat beim Schreiben ihrer Daten in den Protokolldatenstrom einen Fehler festgestellt. Die Ursache kann eine falsche Protokolloperation oder die Ersch\u00f6pfung der Kapazit\u00e4t des internen Protokollpuffers durch eine zu umfangreiche Protokolloperation sein.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Log/Generic
# database errors.
# sqlstate range: XSLA0 to XSLAZ
XSLAT.D=Das Protokollverzeichnis {0} ist bereits vorhanden. Vergewissern Sie sich, dass die angegebene Position der Protokolleinheit stimmt. 
XSLAS.D=Bei der Wiederherstellung wurde das Protokollverzeichnis {0} nicht in der Sicherung gefunden. Vergewissern Sie sich, dass es sich um die richtige Sicherungskopie handelt und dass diese nicht besch\u00e4digt ist.
XSLAR.D=Die Protokolldatei ''{0}'' kann beim Wiederherstellen nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00fcgbar ist und dass die notwendigen Berechtigungen vorliegen. 
XSLAQ.D=Im Verzeichnis {0} kann keine Protokolldatei erstellt werden.
XSLAP.D=Die Datenbank in {0} hat die Version {1}. F\u00fcr Betadatenbanken ist kein Upgrade m\u00f6glich.
XSLAO.D=Die Wiederherstellung ist aufgrund des unerwarteten Fehlers {0} gescheitert.
XSLAN.D=Das Format der Datenbank in {0} ist nicht mit der aktuellen Version der Software kompatibel. Die Datenbank wurde mit der Version {1} erstellt oder erweitert.
XSLAM.D=Das Format der Datenbank in {1} kann aufgrund einer E/A-Ausnahme nicht gepr\u00fcft werden.
XSLAL.D=Die Protokollsatzgr\u00f6\u00dfe {2} \u00fcberschreitet die maximal zul\u00e4ssige Gr\u00f6\u00dfe der Protokolldatei von {3}. In der Protokolldatei {0} wurde an der Position {1} ein Fehler festgestellt.
XSLAK.D=Die Datenbank hat die h\u00f6chste Protokolldateinummer {0} \u00fcberschritten.
XSLAJ.D=Das Protokollierungssystem wurde wegen eines fr\u00fcheren Fehlers zum Herunterfahren vorgemerkt und l\u00e4sst weitere Operationen erst nach einem Systemabschluss und einem Neustart des Systems zu.
XSLAI.D=Der Pr\u00fcfpunktprotokollsatz kann nicht protokolliert werden.
XSLAH.D=Sie aktualisieren eine Datenbank mit Lesezugriff.
XSLAF.D=Eine Datenbank mit Lesezugriff wurde mit benutzten Datenpuffern erstellt.
XSLAE.D=Die Steuerdatei in {0} kann nicht geschrieben oder aktualisiert werden.
XSLAD.D=Der Protokollsatz an der Adresse {2} in der Protokolldatei {3} ist besch\u00e4digt. Erwartete Protokollsatzl\u00e4nge: {0}; tats\u00e4chliche L\u00e4nge: {1}.
XSLAC.D=Das Format der Datenbank in {0} ist nicht mit der aktuellen Version der Software kompatibel. Sie wurde m\u00f6glicherweise mit einer neueren Version erstellt oder erweitert.
XSLAB.D=Die Protokolldatei {0} wurde nicht gefunden. Vergewissern Sie sich, dass das Merkmal logDevice ordnungsgem\u00e4\u00df und mit dem richtigen Pfadtrennzeichen f\u00fcr Ihre Plattform angegeben ist.
XSLAA.D=Der Speicher wurde von einer fr\u00fcheren Ausnahme zum Herunterfahren vorgemerkt.
XSLA8.D=Die Transaktion {0} kann nicht zur\u00fcckgesetzt werden. Es wird versucht, die Operation {1} durch {2} zu kompensieren.
XSLA7.D=Die Operation {0} im Protokoll kann nicht wiederholt werden.
XSLA6.D=Die Datenbank kann nicht wiederhergestellt werden.
XSLA5.D=Der Protokolldatenstrom f\u00fcr das Zur\u00fccksetzen der Transaktion {0} kann nicht gelesen werden.
XSLA4.D=Es kann nicht in das Protokoll geschrieben werden. Wahrscheinlich ist das Protokoll voll. L\u00f6schen Sei nicht ben\u00f6tigte Dateien. Es kann auch sein, dass nur Lesezugriff auf das Dateisystem m\u00f6glich ist oder ein Datentr\u00e4gerfehler vorliegt.
XSLA3.D=Das Protokoll ist besch\u00e4digt. Der Protokolldatenstrom enth\u00e4lt ung\u00fcltige Daten.
XSLA2.D=Das System wird heruntergefahren. Beim Zugriff auf die Protokolldatei wurde eine E/A-Ausnahme empfangen.
XSLA1.D=Der Protokollsatz wurde an den Datenstrom gesendet, kann jedoch nicht in den Speicher (Objekt {0}) gestellt werden. Dies kann zu Fehlern bei der Wiederherstellung f\u00fchren.
XSLA0.D=Die freigegebene Protokolldatei kann nicht auf den Datentr\u00e4ger {0} geschrieben werden.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# statement errors.
# sqlstate range: XSTA0 to XSTAZ
# changed XSTA0 and XSTA1 to match DB2 sqlstates - bug 4466
3B501.S=In der aktuellen Transaktion ist bereits ein Sicherungspunkt mit dem \u00fcbergebenen Namen vorhanden.
3B502.S=Es wurde RELEASE oder ROLLBACK TO SAVEPOINT angegeben. Der Sicherungspunkt ist jedoch nicht vorhanden.
3B001.S=Der Sicherungspunkt {0} ist nicht vorhanden oder in der aktuellen Transaktion nicht aktiv.
3B002.S=Die maximale Anzahl von Sicherungspunkten ist erreicht. 
XSTA2.S=Es wurde versucht, eine Transaktion zu aktivieren, obwohl bereits eine andere Transaktion aktiv war.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# transaction errors.
# sqlstate range: 40XT0 to 40XTZ
40XT0=Das Modul RawStore hat einen internen Fehler festgestellt.
40XT1=Beim Festschreiben der Transaktion wurde eine Ausnahme ausgel\u00f6st.
40XT2=Beim Zur\u00fccksetzen eines Sicherungspunktes wurde eine Ausnahme ausgel\u00f6st.
40XT4=Es wurde versucht, eine noch aktive Transaktion zu schlie\u00dfen. Die Transaktion wurde abgebrochen.
40XT5=W\u00e4hrend einer internen Transaktion wurde eine Ausnahme ausgel\u00f6st.
40XT6=Die Datenbank ist stillgelegt, so dass die Transaktion nicht aktiviert werden kann. Warten Sie, bis die Datenbank vom Stilllegungsstatus in einen anderen Status wechselt.
40XT7=Die Operation wird in einer internen Transaktion nicht unterst\u00fctzt.

#
#java/com/ibm/db2j/internalUtil
#	Id Parse Errors       			XCXA0-XCXAZ
#  	Db Class Path Parse Errors 	 	XCXB0-XCXBZ
# 	Id List Parse Errors			XCXC0-XCXCZ
#  	IO Errors						XCXD0-XCXDZ
#	LocaleFinder Errors				XCXE0-XCXEZ
XCXA0.S=Ung\u00fcltige Kennung.
XCXB0.S=Ung\u00fcltiger Datenbankklassenpfad: ''{0}''.
XCXC0.S=Ung\u00fcltige ID-Liste.
XCXE0.S=Sie versuchen, eine Operation auszuf\u00fchren, die das Gebietsschema der Datenbank verwendet. F\u00fcr die Datenbank ist jedoch kein Gebietsschema festgelegt.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# system errors.
# sqlstate range: XSTB0 to XSTBZ
XSTB0.M=Beim Abbrechen der Transaktion wurde eine Ausnahme ausgel\u00f6st.
XSTB2.M=Die Transaktions\u00e4nderungen k\u00f6nnen nicht protokolliert werden. M\u00f6glicherweise versuchen Sie, in eine Datenbank mit Lesezugriff zu schreiben.
XSTB3.M=Die Transaktion kann nicht abgebrochen werden, weil der Protokollmanager - wahrscheinlich aufgrund eines fr\u00fcheren Fehlers - nicht angegeben ist.
XSTB5.M=Beim Erstellen einer Datenbank mit inaktivierter Protokollierung ist ein unerwarteter Fehler aufgetreten.
XSTB6.M=Eine Transaktionstabelle kann nicht durch eine andere ersetzt werden, solange eine der beiden Tabellen verwendet wird.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# transaction errors.
# sqlstate range: 40XD0 to 40XDZ
40XD0=Der Container wurde geschlossen.
40XD1=Der Container wurde im Schreibschutzmodus ge\u00f6ffnet.
40XD2=Der Container {0} kann nicht ge\u00f6ffnet werden. Er wurde gel\u00f6scht oder ist nicht vorhanden.


# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# statement errors.
# sqlstate range: XSDA0 to XSDAZ
XSDA1.S=Es wurde versucht, auf einer Seite auf eine Stelle au\u00dferhalb des Bereiches zuzugreifen.
XSDA2.S=Es wurde versucht, einen gel\u00f6schten Datensatz zu aktualisieren.
XSDA3.S=Einschr\u00e4nkung: Der Datensatz wegen unzureichenden Speicherbereichs auf der Seite nicht aktualisiert oder eingef\u00fcgt werden. Verwenden Sie den Parameter derby.storage.pageSize und/oder derby.storage.pageReservedSpace, um diese Einschr\u00e4nkung zu umgehen.
XSDA4.S=Es wurde eine unerwartete Ausnahme ausgel\u00f6st.
XSDA5.S=Es wurde versucht, das L\u00f6schen eines nicht gel\u00f6schten Datensatzes zu widerrufen.
XSDA6.S=Die Spalte {0} der Zeile ist gleich null. Sie muss so konfiguriert werden, dass sie auf ein Objekt zeigt.
XSDA7.S=Beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0} wurde versucht, mehr Daten zu lesen, als urspr\u00fcnglich gespeichert wurden.
XSDA8.S=Ausnahme beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0}.
XSDA9.S=Beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0} wurde die Klasse nicht gefunden.
XSDAA.S=Ung\u00fcltige Zeitmarke {0}. Die Zeitmarke stammt von einer anderen Seite oder von einer inkompatiblen Implementierung.
XSDAB.S=Eine Nullzeitmarke kann nicht gesetzt werden.
XSDAC.S=Es wurde versucht, Zeilen oder Seiten von einem Container in einen anderen zu verschieben.
XSDAD.S=Es wurde versucht, Nullzeilen von einer Seite auf eine andere zu verschieben.
XSDAE.S=Eine interne Datensatzkennung kann nur f\u00fcr eine spezifische Kennungs-ID erstellt werden.
XSDAF.S=Eine spezifische interne Datensatzkennung wird wie eine normale interne Kennung verwendet.
XSDAG.S=Der Container kann nicht w\u00e4hrend der Zuordnung durch die erste verschachtelte Transaktion ge\u00f6ffnet werden.
XSDAI.S=Die Seite {0}, die gerade entfernt wird, ist bereits gesperrt, um freigegeben zu werden.
XSDAJ.S=Ausnahme beim Schreiben eines serialisierbaren oder SQLData-Objekts.
XSDAK.S=F\u00fcr die interne Datensatzkennung {0} wurde die falsche Seite abgerufen.
XSDAL.S=Die interne Datensatzkennung {0} zeigt unerwartet auf die \u00dcberlaufseite.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# database errors.
# sqlstate range: XSDB0 to XSDBZ
XSDB0.D=Unerwartete Ausnahme auf der speicherinternen Seite {0}
XSDB1.D=Unbekanntes Seitenformat auf der Seite {0}
XSDB2.D=Unbekanntes Containerformat im Container {0}: {1}
XSDB3.D=Einmal geschriebene Containerinformationen k\u00f6nnen nicht ge\u00e4ndert werden. Vorheriger Stand: {0}; aktueller Stand: {1}
XSDB4.D=Die Seite {0} hat den Versionsstand {1}. Die Protokolldatei enth\u00e4lt die \u00c4nderungsversion {2}. Es fehlen Protokolls\u00e4tze dieser Seite oder die Seite wurde nicht ordnungsgem\u00e4\u00df auf den Datentr\u00e4ger geschrieben.
XSDB5.D=Der \u00c4nderungssatz befindet sich auf Seite {0} des Protokolls, die sich au\u00dferhalb des Containerendes befindet.
XSDB6.D=Die Datenbank {0} wurde m\u00f6glicherweise bereits von einer anderen Derby-Instanz gebootet.
XSDB7.D=WARNUNG: Derby (Instanz {0}) versucht, die Datenbank {1} zu booten, obwohl Derby (Instanz {2}) noch aktiv sein k\u00f6nnte. Eine Datenbank sollte immer nur von jeweils einer Derby-Instanz gebootet werden. Es k\u00f6nnen schwerwiegende und irreparable Sch\u00e4den eingetreten sein oder noch eintreten.
XSDB8.D=WARNUNG: Derby (Instanz {0}) versucht, die Datenbank {1} zu booten, obwohl Derby (Instanz {2}) noch aktiv sein k\u00f6nnte. Eine Datenbank sollte immer nur von jeweils einer Derby-Instanz gebootet werden. Es k\u00f6nnen schwerwiegende und irreparable Sch\u00e4den eintreten, wenn zwei Instanzen von Derby gleichzeitig dieselbe Datenbank booten. Das Merkmal db2j.database.forceDatabaseLock=true wurde gesetzt, so dass die Datenbank erst gebootet wird, wenn db.lck nicht mehr vorhanden ist. Diese Datei wird normalerweise entfernt, wenn die erste Derby-Instanz zum Booten der Datenbank vorhanden ist. Es kann jedoch vorkommen, dass sie beim Herunterfahren nicht gel\u00f6scht wird. In diesem Fall muss die Datei manuell entfernt werden. Vergewissern Sie sich vor dem manuellen L\u00f6schen der Datei db.lck unbedingt, dass keine andere VM auf die Datenbank zugreift.
XSDB9.D=Der Datenstromcontainer {0} ist besch\u00e4digt.
XSDBA.D=Der Versuch, das Objekt {0} zuzuordnen, ist gescheitert.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/FileSystem
# statment errors.
# sqlstate range: XSDF0 to XSDFZ
XSDF0.S=Die Datei {0} konnte nicht erstellt werden, da sie bereits vorhanden ist.
XSDF1.S=Beim Erstellen der Datei {0} f\u00fcr den Container ist eine Ausnahme eingetreten.
XSDF2.S=Beim Erstellen der Datei {0} f\u00fcr den Container ist eine Ausnahme eingetreten. Die Datei konnte nicht entfernt werden. Ausnahme: {1}.
XSDF3.S=Das Segment {0} kann nicht erstellt werden.
XSDF4.S=Beim Entfernen der Datei {0} f\u00fcr den gel\u00f6schten Container ist eine Ausnahme eingetreten. Die Datei konnte nicht entfernt werden. {1}.
XSDF6.S=Die Zuordnungsseite {0} wurde nicht gefunden.
XSDF7.S=Die neu erstellte Seite {0} konnte nicht gesperrt werden.
XSDF8.S=Die wiederzuverwendende Seite {0} wurde nicht gefunden.
XSDFB.S=Die Operation wird von einer Datenbank mit Lesezugriff nicht unterst\u00fctzt.
XSDFD.S=Auf Seite {0} wurde in zwei Ein-/Ausgaben verschiedene Seitenimages gelesen. Das erste Image hat die falsche Kontrollsumme und das zweite die richtige. Seitenimages: {1} {2}
XSDFF.S=Die angeforderte Operation ist durch eine unerwartete Ausnahme gescheitert.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/FileSystem
# database errors.
# sqlstate range: XSDG0 to XSDGZ
XSDG0.D=Die Seite {0} konnte nicht vom Datentr\u00e4ger gelesen werden.
XSDG1.D=Die Seite {0} konnte nicht auf den Datentr\u00e4ger geschrieben werden. Pr\u00fcfen Sie, ob der Datentr\u00e4ger voll ist.
XSDG2.D=Ung\u00fcltige Kontrollsumme auf der Seite {0}. Erwartet: {1}, Version auf Datentr\u00e4ger: {2}. Seitenspeicherauszug: {3}
XSDG3.D=Auf die Metadaten f\u00fcr den Container {0} konnte nicht zugegriffen werden.
XSDG5.D=Die Datenbank befand sich nicht im Erstellungsmodus, als createFinished aufgerufen wurde.
XSDG6.D=Bei der Wiederherstellung wurde das Datensegmentverzeichnis nicht in der Sicherung {0} gefunden. Vergewissern Sie sich, dass es sich um die richtige Sicherungskopie handelt und dass diese nicht besch\u00e4digt ist.
XSDG7.D=Bei der Wiederherstellung konnte das Verzeichnis {0} nicht entfernt werden. Vergewissern Sie sich, dass die notwendigen Berechtigungen vorliegen.
XSDG8.D=Das Verzeichnis ''{0}'' kann beim Wiederherstellen nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00fcgbar ist und dass die notwendigen Berechtigungen vorliegen. 

# language
01500=Die Integrit\u00e4tsbedingung {0} in Tabelle {1} wurde gel\u00f6scht.
01501=Die Ansicht {0} wurde gel\u00f6scht.
01502=Der Ausl\u00f6ser {0} in Tabelle {1} wurde gel\u00f6scht.
01503=Die Spalte {0} in Tabelle {1} wurde durch das Hinzuf\u00fcgen einer Integrit\u00e4tsbedingung ungleich null ge\u00e4ndert.
01504=Der neue Index ist ein Duplikat eines vorhandenen Indexes: {0}.
01505=Der Wert {0} ist m\u00f6glicherweise abgeschnitten.
01003=Aus dem Argument einer Spaltenfunktion wurden Nullwerte eliminiert.
0100E=XX Es wurde versucht, zu viele Ergebnislisten zur\u00fcckzugeben.
02000=F\u00fcr FETCH, UPDATE oder DELETE wurde keine Zeile gefunden oder das Ergebnis einer Abfrage ist eine leere Tabelle.
21000=Eine skalare Unterabfrage darf nur eine Zeile zur\u00fcckgeben.
22001=Bei dem Versuch, {0} ''{1}'' auf die L\u00e4nge {2} zu k\u00fcrzen, ist ein Abschneidefehler aufgetreten.
54006=Die aus der Operation {0} resultierende L\u00e4nge ist gr\u00f6\u00dfer als {1}.
22003=Der resultierende Wert liegt au\u00dferhalb des Bereichs f\u00fcr den Datentyp {0}.
22005=Es wurde versucht, einen Datenwert des Typs ''{0}'' aus einem Datenwert des Typs ''{1}'' abzurufen.
22007.S.180=Die Zeichenfolgendarstellung eines datetime-Wertes liegt au\u00dferhalb des Bereichs.
22007.S.181=Die Syntax der Zeichenfolgendarstellung eines datetime-Wertes ist fehlerhaft.
22011=Das zweite oder dritte Argument der Funktion SUBSTR liegt au\u00dferhalb des Bereichs.
22012=Es wurde eine Division durch null versucht.
22013=Es wurde versucht, die Quadratwurzel einer negativen Zahl (''{0}'') zu ziehen.
22014=Die Anfangsposition f\u00fcr LOCATE ist ung\u00fcltig. Sie muss eine positive ganze Zahl sein. Der Index, bei dem die Suche beginnen soll, ist ''{2}''. Zu suchende Zeichenfolge: ''{0}''. Die Zeichenfolge, bei der die Suche beginnen soll, ist ''{1}''.

22015=Die Funktion ''{0}'' ist f\u00fcr die folgenden Typen unzul\u00e4ssig. Der erste Operand ist vom Typ ''{1}''. Der zweite Operand ist vom Typ ''{2}''. Der dritte Operand (Anfangsposition) ist vom Typ ''{3}''.
22018=Ung\u00fcltiges Zeichenfolgenformat f\u00fcr den Typ {0}
22019=Die Escape-Zeichenfolge ''{0}'' ist ung\u00fcltig. Die Escape-Zeichenfolge muss aus genau einem Zeichen bestehen. Sie muss ungleich null sein und darf nicht mehr als ein Zeichen enthalten.
22025=Auf das Escape-Zeichen muss ein Escape-Zeichen '_' oder '%' folgen. Ein anderes Folgezeichen ist unzul\u00e4ssig. Das Escape-Zeichen darf auch nicht das letzte Zeichen des Musters sein.
22027=Die integrierte Funktion TRIM() unterst\u00fctzt nur das Entfernen eines Zeichens. Die integrierten Funktionen LTRIM() und RTRIM() unterst\u00fctzen das Entfernen mehrerer Zeichen.
22500=Der Parameter ? kann nicht sowohl im LIKE-Muster als auch in der ESCAPE-Klausel verwendet werden.
22501=Eine ESCAPE-Klausel NULL gibt nicht definierte Ergebnisse zur\u00fcck und ist unzul\u00e4ssig.
23502=Die Spalte ''{0}''  akzeptiert keinen Nullwert.
23505=Die Anweisung wurde abgebrochen, weil sie in einer f\u00fcr ''{1}'' definierten Vorgabe f\u00fcr einen eindeutigen oder Prim\u00e4rschl\u00fcssel bzw. f\u00fcr einen von ''{0}'' bezeichneten eindeutigen Index zu einem duplizierten Schl\u00fcsselwert gef\u00fchrt h\u00e4tte.
23503={2} in Tabelle ''{1}'' hat f\u00fcr Schl\u00fcssel {3} die Integrit\u00e4tsbedingung "{0}" f\u00fcr Fremdschl\u00fcssel verletzt. Die Anweisung wurde zur\u00fcckgesetzt.
23513=Die Bedingung ''{1}'' f\u00fcr die Integrit\u00e4tspr\u00fcfung wurde beim Ausf\u00fchren von INSERT oder UPDATE f\u00fcr Tabelle ''{0}'' verletzt.
38000=Bei der Auswertung eines Ausdrucks wurde die Ausnahme ''{0}'' ausgel\u00f6st.
38001=Die externe Routine ist nicht berechtigt, SQL-Anweisungen auszuf\u00fchren.
38002=Die Routine hat versucht, Daten zu modifizieren, wurde jedoch nicht als MODIFIES SQL DATA definiert.
38004=Die Routine hat versucht, Daten zu lesen, wurde jedoch nicht als READS SQL DATA definiert.
39004=An eine Methode mit einem Parameter des primitiven Typs ''{0}'' kann kein Nullwert \u00fcbergeben werden.
40XC0=Nicht mehr verwendbare Anweisung. Die Ursache kann das Abfangen eines Transaktionsfehlers bestimmter Wertigkeit innerhalb dieser Anweisung sein.
# this error is retired in 1.3
42000=Syntaxfehler oder Verletzung einer Zugriffsregel. Details k\u00f6nnen Sie den zus\u00e4tzlichen Fehlernachrichten entnehmen.

# DB2 error for max length violation by char, varchar and long varchar. In future, this error message will be used for other purposes too
42601=Die Spalte ''{0}'' wurde in einer Anweisung ALTER TABLE als NOT NULL angegeben und die Klausel DEFAULT wurde nicht oder als DEFAULT NULL angegeben.
42601.S.372=Die Anweisung ALTER TABLE kann keine Spalte IDENTITY zu einer Tabelle hinzuf\u00fcgen. 
42606=Es wurde eine ung\u00fcltige Hexadezimalkonstante gefunden, die mit ''{0}'' beginnt.
54002=Eine mit ''{0}'' beginnende Zeichenfolgekonstante ist zu lang.
42611=Das L\u00e4ngen-, Genauigkeits- oder Skalenattribut f\u00fcr die Spalte oder Typzuordnung ''{0}'' ist ung\u00fcltig. 

42605=Die Anzahl der Argumente f\u00fcr die Funktion ''{0}'' ist falsch.
42610=Es k\u00f6nnen nicht alle Argumente f\u00fcr die Funktion COALESC/VALUE Parameter sein. Mindestens eines der Argumente muss kein Parameter sein.

42613=Es liegen mehrere oder in Konflikt stehende Schl\u00fcsselw\u00f6rter mit der Klausel ''{0}'' vor.
42621=Eine mit ''{0}'' definierte Bedingung f\u00fcr die Integrit\u00e4tspr\u00fcfung oder generierte Spalte ist ung\u00fcltig.
42734=Der im Kontext ''{1}'' angegebene Name ''{0}'' ist nicht eindeutig.
# DB2 error for invalid set schema
42802=Die Anzahl der zugeordneten Werte stimmt nicht mit der Anzahl der angegebenen oder impliziten Spalten \u00fcberein.
42815.S.713=Der Ersatzwert f\u00fcr ''{0}'' ist ung\u00fcltig.
42815.S.171=Die Argumente ''{0}'' und ''{1}'' sind nach Datentyp, L\u00e4nge oder Argumentwerten inkompatibel.
42820=Das Gleitkommaliteral ''{0}'' enth\u00e4lt mehr als 30 Zeichen.
42824=Ein Operand von LIKE ist keine Zeichenfolge, oder der erste Operand ist keine Spalte.
42831=''{0}'' kann Nullwerte enthalten und daher keine Spalte eines Prim\u00e4rschl\u00fcssels oder eines eindeutigen Schl\u00fcssels sein.
42834=SET NULL kann nicht angegeben werden, weil der Fremdschl\u00fcssel ''{0}''  keine Nullwerte enthalten darf.

42884=Es wurde keine autorisierte Routine ''{0}'' des Typs ''{1}'' mit kompatiblen Argumenten gefunden.
42886=Der ''{0}''-Parameter  ''{1}'' erfordert eine Parametermarke ''?''.
42894=Der DEFAULT-Wert oder der Wert des Attributs IDENTITY ist f\u00fcr die Spalte ''{0}'' ung\u00fcltig.
428C1=Pro Tabelle ist nur eine Identit\u00e4tsspalte zul\u00e4ssig.
42903=Ung\u00fcltige Verwendung einer Aggregatfunktion.
42908=Die Anweisung CREATE VIEW enth\u00e4lt keine Spaltenliste.
42915=Der Fremdschl\u00fcssel ''{0}'' ist wegen ''{1}'' ung\u00fcltig.

42972=Eine einem JOIN-Operator zugeordnete ON-Klausel ist ung\u00fcltig.
42X01=Syntaxfehler: {0}.
42X02={0}.
42X03=Der Spaltenname ''{0}'' findet sich in mehr als einer Tabelle der FROM-Liste.
42X04=Die Spalte ''{0}'' ist in keiner Tabelle der FROM-Liste enthalten, erscheint in einer Verkn\u00fcpfungsspezifikation und befindet sich au\u00dferhalb des Geltungsbereichs derselben oder erscheint in einer HAVING-Klausel und ist nicht in der 'GROUP BY'-Liste enthalten. Wenn es sich um eine Anweisung CREATE oder ALTER TABLE handelt, ist ''{0}'' keine Spalte in der Zieltabelle.
42X05=Die Tabelle ''{0}'' ist nicht vorhanden.
42X06=F\u00fcr die Tabelle ''{0}'' wurden zu viele Ergebnisspalten angegeben.
42X07=Null ist nur in einer VALUES-Klausel innerhalb einer INSERT-Anweisung zul\u00e4ssig.
42X08=Der Konstruktor f\u00fcr die Klasse ''{0}'' kann nicht als \u00e4u\u00dfere virtuelle Tabelle verwendet werden, da die Klasse ''{1}'' nicht implementiert.
42X09=Die Tabelle oder der Aliasname ''{0}'' wird in der FROM-Liste mehr als einmal verwendet.
42X10=''{0}'' ist kein in diesem Bereich angezeigter Tabellenname.
42622=Der Name ''{0}'' ist zu lang. Die maximale L\u00e4nge liegt bei ''{1}''.
42X12=Der Spaltenname ''{0}'' erscheint in der Anweisung CREATE TABLE mehr als einmal.
54011=F\u00fcr die Tabelle oder Ansicht {1} wurden zu viele Spalten ({0}) angegeben. Die Begrenzung liegt bei {2}.
42Z9F=Zu viele Indizes ({0}) f\u00fcr die Tabelle {1}. Die Begrenzung liegt bei {2}.
42X13=Der Spaltenname ''{0}'' erscheint in der Spaltenliste einer INSERT-Anweisung mehr als einmal.
42X14=''{0}'' ist keine Spalte in der Tabelle oder in VTI ''{1}''.
42X15=Der Spaltenname ''{0}'' erscheint in einer Anweisung ohne eine FROM-Liste.
42X16=Der Spaltenname ''{0}'' erscheint mehrfach in der SET-Klausel einer UPDATE-Anweisung.
42X17=Der Wert ''{0}'' ist in der Merkmalliste einer FROM-Klausel nicht als joinOrder-Spezifikation g\u00fcltig. Es sind nur die Werte FIXED und UNFIXED g\u00fcltig.
42803=Ein Ausdruck mit der Spalte ''{0}'' erscheint in der SELECT-Liste und ist nicht Bestandteil einer 'GROUP BY'-Klausel.
42818=Vergleiche von ''{0}'' und ''{1}'' werden nicht unterst\u00fctzt.
42X19=Die WHERE- oder HAVING-Klausel oder die Definition CHECK CONSTRAINT ist ein Ausdruck des Typs ''{0}''. Es muss ein boolescher Ausdruck sein.
42X23=Der Cursor {0} kann nicht aktualisiert werden.
#42X24=The unary ''-'' operator is not allowed on the ''{0}'' type.
42X25=Die Funktion ''{0}'' ist f\u00fcr den Typ ''{1}'' nicht zul\u00e4ssig.
42X26=Die Klasse ''{0}'' f\u00fcr Spalte ''{1}'' ist nicht vorhanden oder es kann nicht auf die Klasse zugegriffen werden. Diese Situation kann eintreten, wenn die Klasse nicht \u00f6ffentlich ist.
42X28=Die zu l\u00f6schende Tabelle ''{0}'' ist keine Zieltabelle des Cursors ''{1}''.
42X29=Die zu aktualisierende Tabelle ''{0}'' ist keine Zieltabelle des Cursors ''{1}''.
42X30=Der Cursor ''{0}'' wurde nicht gefunden. Pr\u00fcfen Sie, ob das automatische Festschreiben inaktiviert ist.
42X31=Die Spalte ''{0}'' ist nicht in der Liste FOR UPDATE des Cursors ''{1}'' enthalten.
42X32=Die Spaltenanzahl in der abgeleiteten Spaltenliste muss mit der Spaltenanzahl der Tabelle ''{0}'' \u00fcbereinstimmen.
42X33=Die abgeleitete Spaltenliste enth\u00e4lt zweimal den Spaltennamen ''{0}''.
42X34=Die Liste enth\u00e4lt einen ?-Parameter. Dies ist unzul\u00e4ssig.
42X35=Es ist unzul\u00e4ssig, dass beide Operanden von ''{0}'' ?-Parameter sind.
42X36=F\u00fcr den Operator ''{0}'' darf kein ?-Parameter als Operand angegeben werden.
42X37=Der unit\u00e4re Operator ''{0}'' ist f\u00fcr den Typ ''{1}'' nicht zul\u00e4ssig.
42X38=''SELECT *'' ist nur in den Unterabfragen EXISTS und NOT EXISTS zul\u00e4ssig.
42X39=Eine Unterabfrage darf nur eine Spalte zur\u00fcckgeben.
42X40=Ein NOT verwendet einen nicht booleschen Operanden. Das Ergebnis der Auswertung f\u00fcr den Operanden von NOT muss TRUE, FALSE oder UNKNOWN sein.
42X41=Das Merkmal ''{0}'' ist in der Merkmalklausel einer FROM-Liste ung\u00fcltig. (Das Merkmal wurde auf ''{1}'' gesetzt.)
42821=Spalten des Typs ''{0}'' k\u00f6nnen keine Werte des Typs ''{1}'' enthalten. 
42X43=Die von der Klasse bzw. dem Objekt ''{0}'' zur\u00fcckgegebenen ResultSetMetaData waren Nulldaten. Die ResultSetMetaData m\u00fcssen ungleich null sein, wenn diese Klasse als \u00e4u\u00dfere virtuelle Tabelle verwendet werden soll.
42X44=Ung\u00fcltige L\u00e4nge ''{0}'' in der Spaltenspezifikation.
# 42X45=
# 42X46=
# 42X47=
42X48=Der Wert ''{1}'' hat eine f\u00fcr {0} nicht g\u00fcltige Genauigkeit.
42X49=Der Wert ''{0}'' ist kein g\u00fcltiges ganzzahliges Literal.
42X50=Es wurde keine mit dem Methodenaufruf {0}.{1}({2}) \u00fcbereinstimmende Methode gefunden, obwohl alle Kombinationen von Objekttypen und primitiven Typen und alle m\u00f6glichen Typumsetzungen f\u00fcr die zul\u00e4ssigen Parameter des Methodenaufrufs versucht wurden. M\u00f6glicherweise ist die Methode vorhanden, jedoch keine \u00f6ffentliche und/oder statische Methode. Es kann auch sein, dass die Parametertypen beim Aufruf der Methode nicht konvertierbar sind.
42X51=Die Klasse ''{0}'' ist nicht vorhanden oder es kann nicht auf die Klasse zugegriffen werden. Diese Situation kann eintreten, wenn die Klasse nicht \u00f6ffentlich ist.
42X52=Das Aufrufen einer Methode (''{0}'') mit dem primitiven Java-Typ ''{1}" als Empf\u00e4nger ist unzul\u00e4ssig.
42X53=Das Pr\u00e4dikat LIKE kann nur mit dem Operand ''CHAR'' oder ''VARCHAR'' verwendet werden. Der Typ ''{0}'' ist unzul\u00e4ssig.
42X54=Die Java-Methode ''{0}'' gibt ? als Empf\u00e4nger an. Dies ist unzul\u00e4ssig.
42X55=Der Tabellenname ''{1}'' darf nicht mit ''{0}'' \u00fcbereinstimmen.
42X56=Die Spaltenanzahl in der angezeigten Spaltenliste stimmt nicht mit der Spaltenanzahl im zugrundeliegen Abfrageausdruck in der Anzeigedefinition f\u00fcr ''{0}'' \u00fcberein.
42X57=getColumnCount() f\u00fcr die \u00e4u\u00dfere virtuelle Tabelle ''{0}'' hat den ung\u00fcltigen Wert ''{1}'' zur\u00fcckgegeben. G\u00fcltig sind Werte >= 1.
42X58=Die Spaltenanzahl auf der linken Seite der Verkn\u00fcpfung (UNION) muss mit der auf der rechten Seite \u00fcbereinstimmen.
42X59=Die Spaltenanzahl muss in allen VALUES-Konstruktoren identisch sein.
42X60=F\u00fcr die Tabelle ''{1}'' wurde f\u00fcr das Merkmal insertMode der ung\u00fcltige Wert ''{0}'' angegeben.
42X61=Die Typen ''{0}'' und ''{1}'' sind inkompatibel mit einer Verkn\u00fcpfung (UNION).
42X62=''{0}'' ist im Schema ''{1}'' nicht zul\u00e4ssig.
42X63=Die USING-Klausel hat keine Ergebnisse geliefert. Es k\u00f6nnen keine Parameter gesetzt werden.
42X64=In der Merkmalliste wurde f\u00fcr das Merkmal useStatistics der ung\u00fcltige Wert ''{0}'' angegeben. G\u00fcltig sind nur die Werte TRUE und FALSE.
42X65=Der Index ''{0}'' ist nicht vorhanden.
42X66=Der Spaltenname ''{0}'' erscheint in der Anweisung CREATE INDEX mehr als einmal.
42X68=Es wurde kein Feld ''{0}'' gefunden, das zur Klasse ''{1}'' geh\u00f6rt. M\u00f6glicherweise ist das Feld vorhanden, jedoch nicht \u00f6ffentlich. Es kann auch sein, dass die Klasse nicht vorhanden oder nicht \u00f6ffentlich ist.
42X69=Es ist unzul\u00e4ssig, mit einem Verweisausdruck des primitiven Java-Typs ''{1}'' auf ein Feld (''{0}'') zu verweisen.
42X72=Es wurde kein statisches Feld ''{0}'' gefunden, das zur Klasse ''{1}'' geh\u00f6rt. M\u00f6glicherweise ist das Feld vorhanden, jedoch nicht \u00f6ffentlich und/oder statisch. Es kann auch sein, dass die Klasse nicht vorhanden oder nicht \u00f6ffentlich ist.
42X73=Die Methodenaufl\u00f6sung f\u00fcr die Signatur {0}.{1}({2}) war mehrdeutig. (Es gibt keine Methode mit maximaler Spezifik.)
42X74=Ung\u00fcltige Syntax f\u00fcr Anweisung CALL.
42X75=Es wurde kein Konstruktor mit der Signatur {0}({1}) gefunden. M\u00f6glicherweise sind die Parametertypen beim Aufruf der Methode nicht konvertierbar.
42X76=F\u00fcr mindestens eine Spalte (''{0}'') des hinzuzuf\u00fcgenden prim\u00e4ren Schl\u00fcssels besteht keine Eintragspflicht. F\u00fcr alle Spalten eines Prim\u00e4rschl\u00fcssels muss Eintragspflicht gelten.
42X77=Die Spaltenposition ''{0}'' befindet sich au\u00dferhalb des Bereichs f\u00fcr den Abfrageausdruck.
42X78=Die Spalte ''{0}'' ist nicht im Ergebnis des Abfrageausdrucks enthalten.
42X79=Der Spaltenname ''{0}'' erscheint mehr als einmal im Ergebnis des Abfrageausdrucks.
42877=Der qualifizierte Spaltenname ''{0}'' ist in der 'ORDER BY'-Klausel nicht zul\u00e4ssig.
42X80=Die VALUES-Klausel muss mindestens einen Eintrag enthalten und keiner der Eintr\u00e4ge darf leer sein.
42X82=Die USING-Klausel hat mehr als eine Zeile zur\u00fcckgegeben. Es sind nur aus einer Zeile bestehende ResultSets zul\u00e4ssig.
42X83=Die Integrit\u00e4tsbedingungen f\u00fcr die Spalte ''{0}'' erfordern, dass f\u00fcr die Spalte sowohl Eintragspflicht als auch keine Eintragspflicht gilt.
42X84=Der Index ''{0}'' wurde erstellt, um die Integrit\u00e4tsbedingung ''{1}'' zu erzwingen. Der Index kann nur gel\u00f6scht werden, wenn die Integrit\u00e4tsbedingung gel\u00f6scht wird.
42X85=Die Integrit\u00e4tsbedingung ''{0}'' muss sich in demselben Schema wie die Tabelle ''{1}'' befinden.
42X86=ALTER f\u00fcr die Tabelle ist gescheitert. Es gibt keine Integrit\u00e4tsbedingung ''{0}'' f\u00fcr die Tabelle ''{1}''.
42X87=Mindestens ein Ergebnisausdruck (then oder else) des Ausdrucks ''{0}'' muss ''?'' sein.
42X88=Ein Bedingungsausdruck enth\u00e4lt einen nicht booleschen Operanden. Das Ergebnis der Auswertung f\u00fcr den Operanden eines Bedingungsausdrucks muss TRUE, FALSE oder UNKNOWN sein.
42X89=Die Typen ''{0}'' und ''{1}'' sind untereinander nicht kompatibel. (Keiner der Typen kann dem jeweils anderen zugeordnet werden.)
42X90=F\u00fcr die Tabelle ''{0}'' wurde mehr als eine Integrit\u00e4tsbedingung f\u00fcr Prim\u00e4rschl\u00fcssel angegeben.
42X91=Der Integrit\u00e4tsbedingungsname ''{0}'' erscheint in der Anweisung CREATE TABLE mehr als einmal.
42X92=Der Spaltenname ''{0}'' erscheint mehr als einmal in der Spaltenliste einer Integrit\u00e4tsbedingung.
42X93=Die Tabelle ''{0}'' enth\u00e4lt die Definition einer Integrit\u00e4tsbedingung mit der Spalte ''{1}'', die nicht in der Tabelle ist.
42Z93=Die Integrit\u00e4tsbedingungen ''{0}'' und ''{1}'' haben dieselben Spaltengruppen. Dies ist unzul\u00e4ssig.
42Z96=Read-Write-VTIs werden in den Umgebungen JDK 1.1/JDBC 1.2 nicht unterst\u00fctzt: ''{0}''
42Z9B=Die externe virtuelle Tabellenschnittstelle unterst\u00fctzt keine BLOB- oder CLOB-Spalten. ''{0}''-Spalte ''{1}''.
42Z9D=''{0}''-Anweisungen sind in ''{1}''-Ausl\u00f6sern nicht zul\u00e4ssig.
42Z9E=Die Integrit\u00e4tsbedingung ''{0}'' ist keine ''{1}''-Integrit\u00e4tsbedingung.
42X94={0} ''{1}'' ist nicht vorhanden.
42X96=Der Datenbankklassenpfad enth\u00e4lt die unbekannte JAR-Datei ''{0}''.
42X98=In einer VIEW-Definition sind Parameter nicht zul\u00e4ssig.
42Y00=Die Klasse ''{0}'' implementiert nicht org.apache.derby.iapi.db.AggregateDefinition und kann deshalb nicht als Aggregatausdruck verwendet werden.
42Y01=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig.
42Y03=''{0}'' wurde nicht als Funktion oder Prozedur erkannt.

# EXTERNAL NAME is SQL keyword - do not translate
42Y04=F\u00fcr die Funktion mit EXTERNAL NAME ''{0}'' kann kein Prozedur oder Funktion erstellt werden, weil keine Liste in Schreibweise mit Trennzeichen vorliegt. Das erwartete Format ist <vollst\u00e4ndiger Java-Pfad>.<Methodenname>.

42Y05=Es gibt keinen Fremdschl\u00fcssel mit dem Namen ''{0}''.
42Y07=Das Schema ''{0}'' ist nicht vorhanden.
42Y08=F\u00fcr Systemtabellen sind Integrit\u00e4tsbedingungen f\u00fcr Fremdschl\u00fcssel unzul\u00e4ssig.
42Y09=Void-Methoden sind nur in einer CALL-Anweisung erlaubt.
42Y10=Bei einem Tabellenkonstruktor, der nicht in einer INSERT-Anweisung enthalten ist, befinden sich alle ?-Parameter in einer der Spalten. F\u00fcr jede Spalte muss mindestens eine der Zeilen einen nichtparametrischen Wert enthalten.
42Y11=F\u00fcr die Klausel ''{0}'' ist eine Verkn\u00fcpfungsspezifikation erforderlich.
42Y12=Die ON-Klausel f\u00fcr ein JOIN ist ein Ausdruck vom Typ ''{0}''. Es muss ein boolescher Ausdruck sein.
42Y13=Der Spaltenname ''{0}'' erscheint in der Anweisung CREATE VIEW mehr als einmal.
42Z97=Wenn die Spalte ''{0}'' umbenannt wird, ist die Bedingung ''{1}'' f\u00fcr Integrit\u00e4tspr\u00fcfung nicht mehr erf\u00fcllt.
42Z99=Ein Zeichenfolgen- oder Hexadezimalliteral darf 64 K nicht \u00fcberschreiten.
42Y16=In der Klasse ''{1}'' wurde keine \u00f6ffentliche statische Methode ''{0}'' gefunden. M\u00f6glicherweise ist die Methode vorhanden, jedoch keine \u00f6ffentliche oder statische Methode.
42846=Die Typen ''{0}'' k\u00f6nnen nicht in ''{1}'' konvertiert werden.
42Y19=''{0}'' erscheint mehrfach in der 'GROUP BY'-Liste. Die Spalten der 'GROUP BY'-Liste m\u00fcssen eindeutig sein.
42Y22=Das Aggregat {0} kann nicht f\u00fcr den Typ {1} verwendet werden.
42Y23=F\u00fcr Spalte {0} wurde eine falsche JDBC-Typangabe zur\u00fcckgegeben.
42Y24=Die Ansicht ''{0}'' kann nicht aktualisiert werden. (Es ist derzeit nicht m\u00f6glich, Ansichten zu aktualisieren.)
42Y25=''{0}'' ist eine Systemtabelle. Benutzer d\u00fcrfen den Inhalt dieser Tabelle nicht \u00e4ndern.
#42Y26=Parameters are not allowed in the WHEN clause of a trigger.
42Y27=Parameter sind in der Ausl\u00f6seaktion unzul\u00e4ssig.
42Y29=Die SELECT-Liste einer nicht gruppierten Abfrage enth\u00e4lt mindestens einen ung\u00fcltigen Ausdruck. Wenn die SELECT-Liste mindestens ein Aggregat enth\u00e4lt, m\u00fcssen alle Eintr\u00e4ge g\u00fcltige Aggregatausdr\u00fccke sein.
42Y30=Die SELECT-Liste einer gruppierten Abfrage enth\u00e4lt mindestens einen ung\u00fcltigen Ausdruck. F\u00fcr ein SELECT mit GROUP BY darf die SELECT-Liste nur Gruppierungsspalten und g\u00fcltige Aggregatausdr\u00fccke enthalten.
42Y32=Die Aggregator-Klasse ''{0}'' f\u00fcr das Aggregat ''{1}'' f\u00fcr den Typ {2} implementiert nicht com.ibm.db2j.aggregates.Aggregator.

42Y33=Das Aggregat {0} enth\u00e4lt ein oder mehrere Aggregat(e).
42Y34=Der Spaltenname ''{0}'' stimmt mit mehr als einer Ergebnisspalte in der Tabelle ''{1}'' \u00fcberein.
42Y35=Der Spaltenverweis ''{0}'' ist ung\u00fcltig. Wenn die SELECT-Liste mindestens ein Aggregat enth\u00e4lt, m\u00fcssen alle Eintr\u00e4ge g\u00fcltige Aggregatausdr\u00fccke sein.
42Y36=Der Spaltenverweis ''{0}'' ist ung\u00fcltig. F\u00fcr ein SELECT mit GROUP BY darf die SELECT-Liste nur Gruppierungsspalten und g\u00fcltige Aggregatausdr\u00fccke enthalten.
42Y37=''{0}'' ist ein primitiver Java-Typ und kann nicht mit diesem Operator verwendet werden.
42Y38=insertMode = replace ist f\u00fcr eine Einf\u00fcgung unzul\u00e4ssig, bei der sich SELECT auf die Zieltabelle ''{0}'' bezieht.
# NOTE: The parameter to this message is a keyword used as a noun phrase.
# Some possible values are "subquery", "CurrentDate", and "?".
42Y39=''{0}'' darf nicht in einer 'CHECK CONSTRAINT'-Definition erscheinen, da dies zu unvorhersehbaren Ergebnissen f\u00fchren k\u00f6nnte.
42Y40=''{0}'' erscheint mehrfach in der Spalte UPDATE OF des Ausl\u00f6sers ''{1}''.
42Y41=''{0}'' kann nicht direkt mit EXECUTE STATEMENT aufgerufen werden, da dieses Objekt Teil eines Ausl\u00f6sers ist.
42Y42=Die Skala ''{1}'' ist keine g\u00fcltige Skala f\u00fcr {0}.
42Y43=Die Skala ''{0}'' ist keine g\u00fcltige Skala mit einer Genauigkeit von ''{1}''.
42Y44=In der Merkmalliste der FROM-Liste wurde der ung\u00fcltige Schl\u00fcssel ''{0}'' angegeben. Derzeit werden folgende Schl\u00fcssel unterst\u00fctzt: ''{1}''. Es ist die Gro\u00df-/Kleinschreibung zu beachten.
42Y45=Der VTI ''{0}'' kann nicht gebunden werden, weil es sich um einen spezifischen Ausl\u00f6ser-VTI handelt und diese Anweisung nicht zu einer Ausl\u00f6seaktion oder WHEN-Klausel geh\u00f6rt.
42Y46=Ung\u00fcltige Merkmalliste in FROM-Liste. In Tabelle ''{1}'' gibt es keinen Index ''{0}''.
42Y48=Ung\u00fcltige Merkmalliste in FROM-Liste. Entweder gibt es f\u00fcr Tabelle ''{1}'' keine benannte Integrit\u00e4tsbedingung ''{0}'' oder es gibt keinen Sicherungsindex f\u00fcr die Integrit\u00e4tsbedingung.
42Y49=F\u00fcr den Merkmalschl\u00fcssel ''{0}'' wurden mehrere Werte angegeben.

42Y50=Die Merkmalliste f\u00fcr die Tabelle ''{0}'' darf Indexwerte oder Werte f\u00fcr Integrit\u00e4tsbedingungen enthalten, jedoch nicht beide zusammen.
42Y55=''{0}'' kann nicht f\u00fcr ''{1}'' ausgef\u00fchrt werden, da dieses Objekt nicht vorhanden ist.
42Y56=In der Merkmalliste f\u00fcr Tabelle ''{1}'' wurde die ung\u00fcltige joinStrategy ''{0}'' angegeben. Derzeit werden f\u00fcr joinStrategy die Werte ''hash'' und ''nestedloop'' unterst\u00fctzt.
42Y58=Beim Konvertieren des Wertes ''{0}'' f\u00fcr den Parameter override ''{1}'' des Optimizer ist eine NumberFormatException eingetreten.
42Y59=F\u00fcr das \u00dcberschreiben von hashInititalCapacity wurde der ung\u00fcltige Wert ''{0}'' angegeben. Der Wert muss > 0 sein.
42Y60=F\u00fcr das \u00dcberschreiben von hashLoadFactor wurde der ung\u00fcltige Wert ''{0}'' angegeben. Der Wert muss > 0,0 und <= 1,0 sein.
42Y61=F\u00fcr das \u00dcberschreiben von hashMaxCapacity wurde der ung\u00fcltige Wert ''{0}'' angegeben. Der Wert muss > 0 sein.
42Y62=''{0}'' ist f\u00fcr ''{1}'' nicht zul\u00e4ssig, weil es sich um eine Ansicht handelt.
42Y63=Eine Hash-Verkn\u00fcpfung erfordert ein optimierbares equijoin-Pr\u00e4dikat f\u00fcr eine Spalte im ausgew\u00e4hlten Index oder Heap-Speicher. Die Tabelle bzw. der Index ''{0}'' enth\u00e4lt f\u00fcr keine Spalte ein optimierbares equijoin-Pr\u00e4dikat. Verwenden Sie den override-Parameter ''index'' des Optimizer, um einen Index oder Heap-Speicher f\u00fcr die Tabelle ''{1}'' anzugeben.
42Y64=Der bulkFetch-Wert ''{0}'' ist ung\u00fcltig: der Mindestwert f\u00fcr bulkFetch ist 1.
42Y65=bulkFetch ist f\u00fcr ''{0}''-Verkn\u00fcpfungen nicht zul\u00e4ssig.
42Y66=bulkFetch ist f\u00fcr aktualisierbare Cursor nicht zul\u00e4ssig.
42Y67=Das Schema ''{0}'' kann nicht gel\u00f6scht werden.
42Y69=F\u00fcr diese Anweisung wurde kein g\u00fcltiger Ausf\u00fchrungsplan gefunden. Dies kann eine der beiden folgenden Ursachen haben: Sie haben eine Hash-Verkn\u00fcpfungsstrategie angegeben, obwohl keine Hash-Verkn\u00fcpfung erlaubt ist (kein optimierbares equijoin) oder Sie versuchen, zwei ExternalVirtualTables zu verkn\u00fcpfen, die jeweils aufeinander verweisen, so dass die Anweisung nicht ausgewertet werden kann.
42Y70=Die vom Benutzer angegebene Verkn\u00fcpfungsfolge ist keine zul\u00e4ssige Verkn\u00fcpfungsfolge. Dies kann daran liegen, dass eine zu verkn\u00fcpfende Spalte einer inneren Tabelle als Parameter an eine \u00e4u\u00dfere virtuelle Tabelle \u00fcbergeben wird.
42Y71=Die Systemfunktion oder Prozedur ''{0}'' kann nicht gel\u00f6scht werden.
42Y82=Die vom System generierte gespeicherte vorbereitete Anweisung ''{0}'' kann mit DROP STATEMENT nicht gel\u00f6scht werden. Sie geh\u00f6rt zu einem Ausl\u00f6ser.
42Y83=Eine Nullangabe ohne Typ ist kein zul\u00e4ssiges Argument f\u00fcr das Aggregat {0}. Setzen Sie die Nullangabe in einen geeigneten Typ um.
# NOTE: The parameter to this message is a keyword used as a noun phrase.
# Some possible values are "subquery", "CurrentDate", and "?".
42Y84=''{0}'' darf in einer DEFAULT-Definition nicht erscheinen.
42Y85=Das Schl\u00fcsselwort DEFAULT ist in einer VALUES-Klausel nur zul\u00e4ssig, wenn die VALUES-Klausel in einer INSERT-Anweisung erscheint.
42Y90=FOR UPDATE ist f\u00fcr diesen Anweisungstyp unzul\u00e4ssig.
42Y91=Die USING-Klausel ist in EXECUTE STATEMENT f\u00fcr eine Ausl\u00f6seaktion nicht zul\u00e4ssig.
42Y92={0}-Ausl\u00f6ser k\u00f6nnen nur auf \u00dcbergangsvariablen/Tabellen des Typs {1} Bezug nehmen.
42Y93=Ung\u00fcltige REFERENCING-Klausel: F\u00fcr jede Art von \u00dcbergangsvariable/-tabelle ist nur ein Name zul\u00e4ssig.
42Y94=Ein AND oder OR verwendet einen nicht booleschen Operanden. Das Ergebnis der Auswertung f\u00fcr die Operanden von AND und OR muss TRUE, FALSE oder UNKNOWN sein.
42Y95=Der Operator ''{0}'' mit dem linken Operanden vom Typ ''{1}'' und dem rechten Operanden vom Typ ''{2}'' wird nicht unterst\u00fctzt.
42Y96.U=UNKNOWN
42Y97=Ung\u00fcltiges Escape-Zeichen in Zeile ''{0}'', Spalte ''{1}''.
42Y98.U=In Zeile {1}, Spalte {2}, wurde "{0}" gefunden
42Y99.U=Lexikalischer Fehler in Zeile {0}, Spalte {1}. Festgestellt wurde: {2}
42Z00.U=Java-Methodenaufruf oder Feldverweis
# This message is put into message 42X75 when a parameter doesn't have a
# datatype. For example, from the parameterWidening test:
#
# values (java.lang.Integer::toString(?, null));
# ERROR 42X50: No method was found with the signature
# java.lang.Integer.toString(UNTYPED, UNTYPED).  It may be that the method
# exists, but it is not public and/or static, or that the parameter types
# are not method invocation convertible.
42Z01.U=UNTYPED
42Z02=Mehrere DISTINCT-Aggregate werden zur Zeit nicht unterst\u00fctzt.
42Z07=Aggregate sind in der ON-Klausel nicht erlaubt.
42Z08=F\u00fcr ''{0}'' gibt es einen aktivierten Ausl\u00f6ser ({1}). Eine Ersetzung durch Masseneinf\u00fcgung ist deshalb unzul\u00e4ssig.
42Z09.U=COLUMN DEFAULT f\u00fcr
#
# The following message is used in error messages where we want to say that
# certain operations on streams are illegal. The word "stream" is not a
# keyword or method name, so it should be translated.
42Z11.U=Datenstrom

# alter table modify column error messages.
#####
42Z15=F\u00fcr die Spalte ''{0}'' wurde ein ung\u00fcltiger Typ angegeben. Der Typ einer Spalte kann nicht ge\u00e4ndert werden.
42Z16=Die L\u00e4nge kann nur f\u00fcr Spalten des Typs VARCHAR ge\u00e4ndert werden. 
42Z17=F\u00fcr die Spalte ''{0}'' wurde eine ung\u00fcltige L\u00e4nge angegeben. Der L\u00e4ngenwert muss gr\u00f6\u00dfer als die aktuelle Spaltenl\u00e4nge sein.
42Z18=Die Spalte ''{0}'' geh\u00f6rt zur Integrit\u00e4tsbedingung ''{1}'' f\u00fcr Fremdschl\u00fcssel. Wenn Sie die L\u00e4nge dieser Spalte \u00e4ndern m\u00f6chten, sollten Sie zun\u00e4chst die Integrit\u00e4tsbedingung l\u00f6schen. F\u00fchren Sie dann ALTER aus und erstellen Sie die Integrit\u00e4tsbedingung neu.
42Z19=Auf die Spalte ''{0}'' wird von mindestens einer Integrit\u00e4tsbedingung ''{1}'' f\u00fcr Fremdschl\u00fcssel verwiesen. Wenn Sie die L\u00e4nge dieser Spalte \u00e4ndern m\u00f6chten, sollten Sie zun\u00e4chst die verweisenden Integrit\u00e4tsbedingungen l\u00f6schen. F\u00fchren Sie dann ALTER aus und erstellen Sie die Integrit\u00e4tsbedingungen neu.
42Z20=Die Eintragspflicht f\u00fcr die Spalte ''{0}'' kann nicht aufgehoben werden. Sie geh\u00f6rt zu einem Prim\u00e4rschl\u00fcssel, der keine Spalten ohne Eintragspflicht enthalten darf.

#####
# end of alter table modify constraints.
# identity error message (from 42Z21-42Z29)
#####
42837=ALTER TABLE ''{0}'' gibt Attribute f\u00fcr die Spalte ''{1}'' an, die nicht mit der vorhandenen Spalte kompatibel sind.
42Z21=F\u00fcr die Identit\u00e4t der Spalte ''{0}'' wurde ein ung\u00fcltiges Inkrement angegeben. Das Inkrement muss ungleich null sein.
42Z22=F\u00fcr die Identit\u00e4tsspalte ''{0}'' wurde ein ung\u00fcltiger Typ angegeben. F\u00fcr Identit\u00e4tsspalten sind nur die Typen BIGINT, INT und SMALLINT g\u00fcltig.
42Z23=Es wurde versucht, die Identit\u00e4tsspalte ''{0}'' zu \u00e4ndern. 
42Z24=Beim Identit\u00e4tswert f\u00fcr die Spalte ''{1}'' in der Tabelle ''{0}'' ist es zu einem \u00dcberlauf gekommen.
42Z25=INTERNER FEHLER: Identit\u00e4tsz\u00e4hler: UPDATE wurde ohne Argumente mit dem aktuellen Wert = NULL aufgerufen.
42Z26=F\u00fcr die Spalte ''{0}'' mit einer Standardidentit\u00e4t kann die Eintragspflicht nicht aufgehoben werden.
42Z27=F\u00fcr die Spalte ''{0}'' ohne Eintragspflicht kann keine Standardidentit\u00e4t festgelegt werden.

#####
# end of identity error messages.

42Z30.U=Zeit f\u00fcr dieses ResultSet =
42Z31.U=Zeit f\u00fcr dieses ResultSet und folgende =
42Z32.U=Aufschl\u00fcsselung der Gesamtzeit:

42Z33.U=Konstruktorzeit (Millisekunden) =
42Z34.U=Zeit f\u00fcr \u00d6ffnen (Millisekunden) =
42Z35.U=Zeit f\u00fcr next (Millisekunden) =
42Z36.U=Zeit f\u00fcr Schlie\u00dfen (Millisekunden) =
42Z37.U=Keine
42Z38.U=Es ist keine Positionierungsangabe verf\u00fcgbar, weil dieses ResultSet nie ge\u00f6ffnet wurde.
42Z39.U=Unerwartete Ausnahme {0} beim Anfordern des Positionierers.
## NOTE: In the following message, {0} will be either >= or >
42Z40.U={0} f\u00fcr die ersten {1} Spalten.
42Z41.U=Semantik mit Nullsortierung in den folgenden Spalten:

42Z42.U=Spalten-ID
42Z43.U=Operator
42Z44.U=Nullsortierung
42Z45.U=Unbekannter R\u00fcckgabewert
42Z46.U=Vergleichsergebnis negieren
42Z47.U=Das Abrufen des Abfrageplans als Zeichenfolge wird derzeit f\u00fcr {0} nicht unterst\u00fctzt
## NOTE: In the following message, {0} and {1} are integer indexes into a 2-d array
42Z48.U=ID f\u00fcr Spalte [{0}][{1}]

# matches DB2
42939=Mit dem Schemanamen ''{0}'' kann kein Objekt erstellt werden.




42Z50=INTERNER FEHLER: F\u00fcr {0} kann kein Code generiert werden.
42Z53=INTERNER FEHLER: Es ist nicht bekannt, welcher Aktivierungstyp f\u00fcr die Knotenauswahl {0} generiert werden soll.
42Z54.U=Diese Ausnahme stoppt die Anweisung nach der Syntaxanalyse. Es ist keine weitere Verarbeitung erforderlich.
42Z55.U=Die Ausf\u00fchrung wurde nach der Syntaxanalyse von der Debug-Markierung StopAfterParsing gestoppt.
42Z56.U=Die Ausf\u00fchrung wurde nach der Bindung von der Debug-Markierung StopAfterBinding gestoppt.
42Z57.U=Die Ausf\u00fchrung wurde nach der Optimierung von der Debug-Markierung StopAfterOptimizing gestoppt.
42Z58.U=Die Ausf\u00fchrung wurde nach der Generierung von der Debug-Markierung StopAfterGenerating gestoppt.

## More RUNTIMESTATISTICS messages
42Z80.U=SERIALIZABLE
42Z81.U=READ COMMITED
42Z82.U=EXCLUSIVE
42Z83.U=INSTANTANEOUS SHARE
42Z84.U=SHARE
42Z85.U=TABLE
42Z86.U=ROW
42Z87.U=SHARE TABLE
42Z88.U=SHARE ROW

# More generic language stuff
42Z90=Die Klasse ''{0}'' gibt kein aktualisierbares ResultSet zur\u00fcck.
42Z91=Unterabfrage
42Z92=wiederholbares Lesen
42Z9A=unbest\u00e4tigtes Lesen

# Declare global temporary table language stuff. Does not match DB2, specific to Derby behavior
XCL478.S=Die angeforderte Funktion kann keine Tabellen im Schema SESSION referenzieren.
# Declare global temporary table language stuff. Matches DB2
428EK=Das Qualifikationsmerkmal f\u00fcr eine deklarierte globale tempor\u00e4re Tabelle muss SESSION sein.
42995=Die angeforderte Funktion ist nicht auf globale tempor\u00e4re Tabellen anwendbar.
42962=Die LOB-Spalte oder der Parameter ''{0}'' ist in deklarierten globalen tempor\u00e4ren Tabellen oder Prozedurdefinitionen nicht zul\u00e4ssig. 

## org.apache.derby.impl.sql.execute.rts
43X00.U=Zugeordnet zu
43X01.U=Nummer der ersten Unterabfrage
# NOTE: In this case, the name of the type of ResultSet is "Any". ResultSet
# is the name of an interface, so it should not be translated.
43X02.U=ANY-ResultSet
43X03.U=Anzahl der \u00d6ffnungsvorg\u00e4nge
43X04.U=Gesehene Zeilen
43X05.U=Quellenergebnismenge
43X06.U=Nummer der letzten Unterabfrage
43X07.U=Vom Optimizer gesch\u00e4tzte Zeilenzahl
43X08.U=Vom Optimizer gesch\u00e4tzte Kosten
43X09.U=Sekunden
43X10.U=Summe
43X11.U=Knoten
43X12.U={0} ist derzeit nicht f\u00fcr {1} implementiert.
# NOTE: In this case, the name of the type of ResultSet is "Any". ResultSet
# is the name of an interface, so it should not be translated.
43X13.U=DELETE-ResultSet mit
43X14.U=Tabelle wird gesperrt
43X15.U=Zeile wird gesperrt
43X16.U=verz\u00f6gert
43X17.U=Gel\u00f6schte Zeilen
43X18.U=Aktualisierte Indizes
43X19.U=L\u00f6schen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X20.U=ResultSet f\u00fcr spezifisches skalares Aggregat
# NOTE: In this message, "input" is being used as a verb
43X21.U=Eingegebene Zeilen
43X22.U=Spezifisches skalares Aggregat
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X23.U=ResultSet der spezifischen Suche f\u00fcr {0} unter Verwendung von {1} {2}
43X24.U=Integrit\u00e4tsbedingung
43X25.U=Index
43X26.U=ResultSet der spezifischen Suche f\u00fcr {0}
#NOTE: In this message, {0} will be something like "serializable" or "read
# committed", and {1} will be something like "share" or "exclusive".
43X27.U=auf der Isolationsstufe {0} unter Verwendung einer Sperre des Typs {1}
43X28.U=Suchinformationen
43X29.U=Die spezifische Spalte hat die Nummer
43X30.U=Die spezifischen Spalten haben die Nummern
43X31.U=Gr\u00f6\u00dfe der Hash-Tabelle
43X32.U=Gefilterte Zeilen
43X33.U=Zeit f\u00fcr next in Millisekunden/Zeile
43X34.U=Anfangspunkt
43X35.U=Endpunkt
43X36.U=Qualifikationsmerkmale f\u00fcr Suche
#NOTE: The message means the set of qualifiers that filter rows returned
# by the "next" operation, not the set of qualifiers that come next.
43X37.U=Qualifikationsmerkmale f\u00fcr next
#NOTE: In this message, {0} is a table name and {1} is an index name
43X38.U=f\u00fcr {0} mit {1}
43X39.U=Spezifische Suche
43X40.U=Sortierungsinformationen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X41.U=ResultSet f\u00fcr gruppiertes Aggregat
43X42.U=mit spezifischem Aggregat
43X43.U=In sortierter Reihenfolge
43X44.U=Gruppiertes Aggregat
43X45.U=EXISTS-Verkn\u00fcpfung f\u00fcr Hash-Eintr\u00e4ge
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X46.U=ResultSet f\u00fcr EXISTS-Verkn\u00fcpfung von Hash-Eintr\u00e4gen
43X47.U=Verkn\u00fcpfung von Hash-Eintr\u00e4gen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X48.U=ResultSet f\u00fcr Verkn\u00fcpfung von Hash-Eintr\u00e4gen
43X49.U=Nach links erweiterte Verkn\u00fcpfung von Hash-Eintr\u00e4gen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X50.U=ResultSet f\u00fcr nach links erweiterte Verkn\u00fcpfung von Hash-Eintr\u00e4gen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {1} is either "constraint" or "index", {0} is a table name, and {2} is a
# constraint or index name.
43X51.U=ResultSet der Hash-Suche f\u00fcr {0} unter Verwendung von {1} {2}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X52.U=ResultSet der Hash-Suche f\u00fcr {0}
43X53.U=Der Hash-Schl\u00fcssel ist die Spaltennummer
43X54.U=Die Hash-Schl\u00fcssel sind die Spaltennummern
43X55.U=Hash-Suche
43X56.U=Zugeordnete Unterabfragen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X57.U=ResultSet f\u00fcr Hash-Tabelle
43X58.U=Hash-Tabelle
43X59.U=alle
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43X60.U=ResultSet Indexzeile zu Basiszeile f\u00fcr {0}
43X61.U=Heap-Spalten, auf die zugegriffen wurde
#NOTE: {0} is a table name
43X62.U=f\u00fcr {0}
43X63.U=Indexzeile zu Basiszeile
43X64.U=Einf\u00fcgemodus: Einf\u00fcgen von Massendaten
43X65.U=Einf\u00fcgemodus: normal (das Einf\u00fcgen von Massendaten ist nicht m\u00f6glich, da die Tabelle nicht leer ist)
43X66.U=Einf\u00fcgemodus: normal
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X67.U=INSERT-ResultSet mit
43X68.U=Eingef\u00fcgte Zeilen
43X69.U=Einf\u00fcgen
43X70.U=Verkn\u00fcpfung
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43X71.U=ResultSet der letzten Schl\u00fcsselindexsuche f\u00fcr {0} unter Verwendung von Index {1}
43X72.U=bei Isolationsstufe {0} mit {1}-Sperrung wurde vom Optimizer ausgew\u00e4hlt
43X73.U=Tabellensuche
43X74.U=Indexsuche
#NOTE: {0} is a table name or class name
43X75.U=f\u00fcr {0}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X76.U=Gespeichertes ResultSet
43X77.U=Erstellungszeit f\u00fcr tempor\u00e4res Konglomerat (Millisekunden)
43X78.U=Abrufzeit f\u00fcr tempor\u00e4res Konglomerat (Millisekunden)
43X79.U=Gesehene Zeilen von links
43X80.U=Gesehene Zeilen von rechts
43X81.U=Zur\u00fcckgegebene Zeilen
43X82.U=Linke Ergebnismenge
43X83.U=Rechte Ergebnismenge
43X84.U=Verkn\u00fcpfung \u00fcber vorhandene verschachtelte Schleife
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X85.U=ResultSet f\u00fcr Verkn\u00fcpfung \u00fcber vorhandene verschachtelte Schleife
43X86.U=Verkn\u00fcpfung \u00fcber verschachtelte Schleife
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X87.U=ResultSet f\u00fcr Verkn\u00fcpfung \u00fcber verschachtelte Schleife
43X88.U=Zur\u00fcckgegebene leere rechte Zeilen
43X89.U=Nach links erweiterte Verkn\u00fcpfung \u00fcber verschachtelte Schleife
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X90.U=ResultSet f\u00fcr nach links erweiterte Verkn\u00fcpfung \u00fcber verschachtelte Schleife
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X91.U=ResultSet normalisieren
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X92.U=Einzelwert-ResultSet
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X93.U=ResultSet f\u00fcr eingeschr\u00e4nkte Projektion
43X94.U=Einschr\u00e4nkung
43X95.U=Projektion
43X96.U=Einschr\u00e4nkungszeit (Millisekunden)
43X97.U=Projektionszeit (Millisekunden)
43X98.U=Eingeschr\u00e4nkte Projektion
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X99.U=Zeilen-ResultSet
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y00.U=ResultSet f\u00fcr skalares Aggregat
43Y01.U=Optimierung f\u00fcr Indexschl\u00fcssel
43Y02.U=Skalares Aggregat
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y03.U=Scroll-unabh\u00e4ngiges ResultSet
43Y04.U=Anzahl der Lesevorg\u00e4nge in der Hash-Tabelle
43Y05.U=Anzahl der Schreibvorg\u00e4nge in der Hash-Tabelle
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y06.U=ResultSet f\u00fcr Sortierung
43Y07.U=Duplikate eliminieren
43Y08.U=Sortieren
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name, {1} is either "constraint" or "index", {2} is a
# constraint or index name.
43Y09.U=ResultSet der Indexsuche f\u00fcr {0} unter Verwendung von {1} {2}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43Y10.U=ResultSet der Tabellensuche f\u00fcr {0}
43Y11.U=Tats\u00e4chlich verwendete Sperrung: Sperrung auf Tabellenebene.
43Y12.U=Abrufgr\u00f6\u00dfe
43Y13.U=Qualifikationsmerkmale
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y14.U=ResultSet f\u00fcr Gesamtverkn\u00fcpfung
43Y15.U=Gesamtverkn\u00fcpfung
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is either "table" or "row"
43Y16.U=ResultSet mit {0}-Sperrung aktualisieren
43Y17.U=Aktualisierte Zeilen
43Y18.U=Aktualisieren
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a Java class name.
43Y19.U=VTI-ResultSet f\u00fcr {0}
43Y20.U=VTI
43Y21.U=Einbezogene Unterabfragen
43Y22.U=Name der Anweisung
43Y23.U=Text der Anweisung
# NOTE: This means the amount of time it takes to parse
43Y24.U=Zeit f\u00fcr Syntaxanalyse
# NOTE: This means the amount of time it takes to bind
43Y25.U=Bindezeit
# NOTE: This means the amount of time it takes to optimize
43Y26.U=Optimierungszeit
# NOTE: This means the amount of time it takes to generate
43Y27.U=Generierungszeit
# NOTE: This means the amount of time it takes to compile
43Y28.U=Kompilierzeit
# NOTE: This means the amount of time it takes to execute
43Y29.U=Ausf\u00fchrungszeit
43Y30.U=Anfangszeitmarke der Kompilierung
43Y31.U=Endzeitmarke der Kompilierung
43Y32.U=Anfangszeitmarke der Ausf\u00fchrung
43Y33.U=Endzeitmarke der Ausf\u00fchrung
43Y44.U=Text des Plans f\u00fcr die Anweisungsausf\u00fchrung
43Y45.U=Laufzeit 100 %, {0} Sekunden
43Y46.U=ResultSet f\u00fcr VTI einf\u00fcgen
43Y47.U=ResultSet f\u00fcr VTI l\u00f6schen
43Y49.U=VTI einf\u00fcgen
43Y50.U=VTI l\u00f6schen
43Y51.U=ResultSet f\u00fcr mehrstufiges L\u00f6schen
43Y52.U=ResultSet f\u00fcr mehrstufiges L\u00f6schen mit
43Y53.U=Referenzielle Aktionen f\u00fcr abh\u00e4ngige Tabellen
43Y54.U=Referenzielle Aktion f\u00fcr abh\u00e4ngige Tabelle beginnen
43Y55.U=Referenzielle Aktion f\u00fcr abh\u00e4ngige Tabelle beenden

54004=Die Anweisung SELECT enth\u00e4lt zu viele Elemente in GROUP BY, ORDER BY oder in der Auswahlliste.
54008=Die Anweisung CREATE INDEX gibt zu viele Spalten an. (Das Maximum liegt bei 16.)
54023=Die maximale Anzahl von Parametern f\u00fcr eine Prozedur wurde \u00fcberschritten. Die Begrenzung liegt bei {0} und die Anzahl der Parameter f\u00fcr die Prozedur {1} ist {2}.
54038=Die maximale Verschachtelungstiefe f\u00fcr Ausl\u00f6ser wurde \u00fcberschritten.

## all other org.apache.derby.catalog.types
44X00.U=Name des SQL-Typs
44X05.U=n\u00e4chster Fehler

X0X02.S=Die Tabelle ''{0}'' kann nicht im Modus ''{1}'' gesperrt werden.
X0X03.S=Ung\u00fcltiger Transaktionsstatus. Der gehaltene Cursor erfordert dieselbe Isolationsstufe.
X0X05.S=Die Tabelle ''{0}'' ist nicht vorhanden.
X0X0E.S=Die in der automatisch generierten Feldgruppe f\u00fcr Spaltenauswahl aufgelistete Spaltenposition ''{0}'' wurde in der Einf\u00fcgetabelle nicht gefunden.
X0X0F.S=Die in der automatisch generierten Feldgruppe f\u00fcr Spaltenauswahl aufgelistete Spaltenname ''{0}'' wurde in der Einf\u00fcgetabelle nicht gefunden.
X0X07.S=Die JAR-Datei ''{0}'' kann nicht gel\u00f6scht werden, weil sie im db2j.database.classpath ''{0}'' enthalten ist.
X0X10.S=Die USING-Klausel hat mehr als eine Zeile zur\u00fcckgegeben. Es sind nur aus einer Zeile bestehende ResultSets zul\u00e4ssig.
X0X11.S=Die USING-Klausel hat keine Ergebnisse geliefert. Es k\u00f6nnen keine Parameter gesetzt werden.
X0X13.S=Die JAR-Datei ''{0}'' ist nicht im Schema ''{1}'' vorhanden.
X0X57.S=Es wurde versucht, einen Java-Wert vom Typ ''{0}'' in einen SQL-Wert aufzunehmen. Es ist jedoch kein entsprechender SQL-Typ vorhanden. Der Java-Wert ist wahrscheinlich das Ergebnis eines Methodenaufrufs oder Feldzugriffs.
X0X60.S=Ein Cursor mit dem Namen ''{0}'' ist bereits vorhanden.
X0X61.S=Die Werte f\u00fcr die Spalte ''{4}'' im Index ''{0}'' und in der Tabelle ''{1}.{2}'' stimmen f\u00fcr die Zeilenposition {3} nicht \u00fcberein. Der Wert im Index ist ''{5}'', der Wert in der Basistabelle dagegen ''{6}''. Der vollst\u00e4ndige Indexschl\u00fcssel mit der Zeilenposition ist ''{7}''. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.
X0X62.S=Es wurde eine Inkonsistenz der Tabelle ''{0}'' und des Index ''{1}'' festgestellt. Bei dem Versuch, die Zeilenposition ''{2}'' aus der Tabelle abzurufen, ist ein Fehler aufgetreten. Der vollst\u00e4ndige Indexschl\u00fcssel mit der Zeilenposition ist ''{3}''. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.
X0X63.S=IOException ''{0}'' empfangen.
X0X67.S=Spalten des Typs ''{0}'' k\u00f6nnen in CREATE INDEX, ORDER BY, GROUP BY, UNION oder DISTINCT nicht verwendet werden, da f\u00fcr diesen Typ keine Vergleiche unterst\u00fctzt werden.
X0X81.S={0} ''{1}'' ist nicht vorhanden.
X0X85.S=Der Index ''{0}'' wurde nicht erstellt, weil ''{1}'' kein g\u00fcltiger Indextyp ist.
X0X86.S=0 ist ein ung\u00fcltiger Parameterwert f\u00fcr ResultSet.absolute(int row).
X0X87.S=ResultSet.relative(int row) kann nicht aufgerufen werden, wenn sich der Cursor nicht in einer Zeile befindet.
X0X95.S=Die Operation ''{0}'' kann f\u00fcr das Objekt ''{1}'' nicht ausgef\u00fchrt werden, weil es ein offenes ResultSet gibt, das von diesem Objekt abh\u00e4ngig ist.
X0X99.S=Der Index ''{0}'' ist nicht vorhanden.
X0Y16.S=''{0}'' ist keine Ansicht. Falls es sich um eine Tabelle handelt, verwenden Sie DROP TABLE.
X0Y23.S=Die Operation ''{0}'' kann nicht f\u00fcr ein Objekt ''{1}'' ausgef\u00fchrt werden, weil die Ansicht ''{2}'' von diesem Objekt abh\u00e4ngt.
X0Y24.S=Die Operation ''{0}'' kann nicht f\u00fcr ein Objekt ''{1}'' ausgef\u00fchrt werden, weil die Anweisung ''{2}'' von diesem Objekt abh\u00e4ngt.
X0Y25.S=Die Operation ''{0}'' kann nicht f\u00fcr ein Objekt ''{1}'' ausgef\u00fchrt werden, weil die {2} ''{3}'' von diesem Objekt abh\u00e4ngt.
X0Y26.S=Der Index ''{0}'' muss sich in demselben Schema wie die Tabelle ''{1}'' befinden.
X0Y28.S=Der Index ''{0}'' kann f\u00fcr die Systemtabelle ''{1}'' nicht erstellt werden. Benutzer k\u00f6nnen keine Indizes f\u00fcr Systemtabellen erstellen.
# column c already exists in table t.
X0Y32.S={0} ''{1}'' ist bereits in {2} ''{3}'' vorhanden.
X0Y38.S=Der Index ''{0}'' kann nicht erstellt werden, weil die Tabelle ''{1}'' nicht vorhanden ist.
X0Y41.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: die referenzierte Tabelle {1} hat keinen Prim\u00e4rschl\u00fcssel. F\u00fcgen Sie zu {1} einen Prim\u00e4rschl\u00fcssel hinzu oder geben Sie explizit die Spalten einer eindeutigen Integrit\u00e4tsbedingung an, auf die dieser Fremdschl\u00fcssel verweist.
X0Y42.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: die Spalten des Fremdschl\u00fcssels stimmen vom Typ her nicht mit den referenzierten Spalten \u00fcberein.
X0Y43.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: die Anzahl der Spalten in {0} ({1}) stimmt nicht mit der Anzahl der Spalten im referenzierten Schl\u00fcssel ({2}) \u00fcberein.
X0Y44.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: in der Tabelle ''{1}'' gibt es keine Integrit\u00e4tsbedingung f\u00fcr eindeutige oder Prim\u00e4rschl\u00fcssel, die nach Anzahl und Typ der Spalten mit dem Fremdschl\u00fcssel \u00fcbereinstimmt.
X0Y45.S=Die Integrit\u00e4tsbedingung ''{0}'' f\u00fcr Fremdschl\u00fcssel kann nicht zur Tabelle {1} hinzugef\u00fcgt oder f\u00fcr die Tabelle aktiviert werden, weil es f\u00fcr einen oder mehrere Fremdschl\u00fcssel keine \u00fcbereinstimmenden referenzierten Schl\u00fcssel gibt.
X0Y46.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: die referenzierte Tabelle {1} ist nicht vorhanden.
X0Y54.S=Das Schema ''{0}'' kann nicht gel\u00f6scht werden, weil es nicht leer ist.
X0Y55.S=Die Zeilenanzahl in der Basistabelle stimmt nicht mit der Zeilenanzahl in mindestens einem der Indizes f\u00fcr die Tabelle \u00fcberein. Der Index ''{0}'' f\u00fcr Tabelle ''{1}.{2}'' hat {3} Zeilen, die Basistabelle jedoch {4} Zeilen. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.
X0Y56.S=''{0}'' ist f\u00fcr die Systemtabelle ''{1}'' unzul\u00e4ssig.
X0Y57.S=Eine Spalte mit nicht aufhebbarer Eintragspflicht kann nicht zur Tabelle ''{0}'' hinzugef\u00fcgt werden, weil die Tabelle mindestens eine Zeile enth\u00e4lt. Spalten mit nicht aufhebbarer Eintragspflicht k\u00f6nnen nur zu leeren Tabellen hinzugef\u00fcgt werden.
X0Y58.S=Der Versuch, zur Tabelle ''{0}'' eine Integrit\u00e4tsbedingung f\u00fcr Prim\u00e4rschl\u00fcssel hinzuzuf\u00fcgen, ist gescheitert, weil es f\u00fcr die Tabelle bereits eine Integrit\u00e4tsbedingung dieses Typs gibt. F\u00fcr eine Tabelle kann es nur eine Integrit\u00e4tsbedingung f\u00fcr Prim\u00e4rschl\u00fcssel geben.
X0Y59.S=Der Versuch, Integrit\u00e4tsbedingungen zur Tabelle ''{1}'' hinzuzuf\u00fcgen bzw. f\u00fcr die Tabelle zu aktivieren, ist gescheitert, weil die Tabelle {2} Zeile(n) enth\u00e4lt, die die folgende(n) zu pr\u00fcfende(n) Integrit\u00e4tsbedingung(en) verletzt bzw. verletzen: {0}.
X0Y63.S=Der Befehl f\u00fcr die Tabelle ''{0}'' ist gescheitert. Im Prim\u00e4rschl\u00fcssel oder den Spalten der eindeutigen Integrit\u00e4tsbedingung bzw. des Index wurden Nulldaten gefunden. Alle Spalten eines prim\u00e4ren oder eindeutigen Indexschl\u00fcssels m\u00fcssen ungleich null sein.
X0Y66.S=In einer verschachtelten Verbindung kann keine COMMIT-Operation abgesetzt werden, solange es eine anstehende Operation in der \u00fcbergeordneten Verbindung gibt.
X0Y67.S=In einer verschachtelten Verbindung kann keine ROLLBACK-Operation abgesetzt werden, solange es eine anstehende Operation in der \u00fcbergeordneten Verbindung gibt.
X0Y68.S={0} ''{1}'' ist bereits vorhanden.
X0Y69.S={1} ist unzul\u00e4ssig, weil der Ausl\u00f6ser {0} f\u00fcr {2} aktiv ist.
X0Y70.S=INSERT, UPDATE und DELETE sind f\u00fcr die Tabelle {1} unzul\u00e4ssig, weil der Ausl\u00f6ser {0} aktiv ist.
X0Y71.S=Eine Transaktionsbearbeitung wie SET ISOLATION ist unzul\u00e4ssig, weil der Ausl\u00f6ser {0} aktiv ist.
X0Y72.S=F\u00fcr ''{0}'' gibt es einen aktivierten Ausl\u00f6ser ({1}). Eine Ersetzung durch Masseneinf\u00fcgung ist deshalb unzul\u00e4ssig.
X0Y77.S=Die Anweisung set transaction isolation kann nicht f\u00fcr eine laufende globale Transaktion abgesetzt werden, weil die globale Transaktion damit implizit festgeschrieben werden w\u00fcrde. 
X0Y78.S=Statement.executeQuery() kann nicht mit einer Anweisung ausgef\u00fchrt werden, die eine Zeilenanzahl zur\u00fcckgibt.
X0Y79.S=Statement.executeUpdate() kann nicht mit einer Anweisung ausgef\u00fchrt werden, die ein ResultSet zur\u00fcckgibt.
X0Y80.S=ALTER ist f\u00fcr die Tabelle ''{0}'' gescheitert. In der Spalte ''{1}'' wurden Nulldaten gefunden.
X0Y83.S=WARNUNG: Beim L\u00f6schen einer Zeile aus einer Tabelle wurde die Indexzeile f\u00fcr die Zeile {0} der Basistabelle im Index mit der Konglomerat-ID {1} nicht gefunden. Dieser Fehler wurde automatisch im Rahmen der L\u00f6schoperation behoben.
XCL01.S=Die Ergebnismenge gibt keine Zeilen zur\u00fcck. Die Operation {0} ist unzul\u00e4ssig.
XCL05.S=Die Aktivierung wurde geschlossen. Die Operation {0} ist unzul\u00e4ssig.
XCL07.S=Der Cursor ''{0}'' wurde geschlossen. Pr\u00fcfen Sie, ob das automatische Festschreiben inaktiviert ist.
XCL08.S=Der Cursor ''{0}'' befindet sich nicht in einer Zeile.
XCL09.S=An die Methode ''{0}'' wurde eine Aktivierung \u00fcbergeben, die nicht mit dem PreparedStatement \u00fcbereinstimmt.
XCL10.S=Ein PreparedStatement wurde kompiliert, und die Parameter wurden ge\u00e4ndert. Wenn Sie JDBC verwenden, m\u00fcssen Sie die Anweisung erneut vorbereiten.
XCL12.S=Es wurde versucht, einen Datenwert des Typs ''{0}'' in einen Datenwert des Typs ''{1}'' aufzunehmen.
XCL13.S=Die Parameterposition ''{0}'' liegt au\u00dferhalb des Bereichs. Die Parameteranzahl f\u00fcr diese vorbereitete Anweisung ist ''{1}''.
XCL15.S=Beim Aufrufen der Methode compareTo() f\u00fcr ein Objekt ''{0}'' ist eine ClassCastException eingetreten. Der Parameter f\u00fcr compareTo() geh\u00f6rt zur Klasse ''{1}''.
XCL16.S=ResultSet nicht ge\u00f6ffnet. Die Operation ''{0}'' ist unzul\u00e4ssig. Pr\u00fcfen Sie, ob das automatische Festschreiben inaktiviert ist.
XCL17.S=Die Anweisung ist in dieser Datenbank nicht zul\u00e4ssig.
XCL19.S=In der Tabelle ''{0}'' f\u00fcr den Schl\u00fcssel ''{1}'' fehlt eine Zeile.
XCL20.S=F\u00fcr Kataloge mit dem Versionsstand ''{0}'' kann kein Upgrade auf den Versionsstand ''{1}'' durchgef\u00fchrt werden.
XCL21.S=Sie versuchen, eine Datendefinitionsanweisung (CREATE, DROP oder ALTER) auszuf\u00fchren, w\u00e4hrend Sie eine andere Anweisung vorbereiten. Dies ist unzul\u00e4ssig. Dies kann geschehen, wenn Sie eine Definitionsanweisung aus einem statischen Initialisierungsoperator f\u00fcr eine Java-Klasse heraus ausf\u00fchren, der innerhalb einer SQL-Anweisung verwendet wird.
XCL22.S=Der Parameter {0} kann nicht als OUT-Parameter registriert werden, da er ein IN-Parameter ist.
XCL23.S=Die SQL-Typnummer ''{0}'' ist kein Typ, der von registerOutParameter() unterst\u00fctzt wird.
XCL24.S=Der Parameter {0} scheint ein Ausgabeparameter zu sein, wurde jedoch von registerOutParameter() nicht als solcher angegeben. Wenn der Parameter kein Ausgabeparameter ist, muss er auf den Typ {1} gesetzt werden.
XCL25.S=Der Parameter {0} kann nicht als Parameter des Typs {1} registriert werden, weil er dem Typ {2} zugeordnet wird und beide Typen inkompatibel sind.
XCL26.S=Der Parameter {0} ist kein Ausgabeparameter.
XCL27.S=Zur\u00fcckzugebende Ausgabeparameter k\u00f6nnen nicht festgelegt werden.
XCL30.S=Beim Lesen eines ''{0}'' von einem InputStream wurde eine IOException ausgel\u00f6st.
XCL31.S=Die Anweisung wurde geschlossen.

# Delete Rule Restrictions Violation Messages
XCL33.S=Aufgrund von L\u00f6schregeleinschr\u00e4nkungen kann die Tabelle nicht als abh\u00e4ngig von der Tabelle {0} definiert werden. (Die Beziehung ist selbstreferenzierend. Eine solche Beziehung besteht bereits zur L\u00f6schregel SET NULL.)

XCL34.S=Aufgrund von L\u00f6schregeleinschr\u00e4nkungen kann die Tabelle nicht als abh\u00e4ngig von der Tabelle {0} definiert werden. (Die Beziehung umfasst zwei oder mehr Tabellen, so dass die Tabelle f\u00fcr das mehrstufige L\u00f6schen auf sich selbst verweist. F\u00fcr alle \u00fcbrigen Tabellen gilt die L\u00f6schregel CASCADE.)

XCL35.S=Aufgrund von L\u00f6schregeleinschr\u00e4nkungen kann die Tabelle nicht als abh\u00e4ngig von der Tabelle {0} definiert werden. (Die Beziehung f\u00fchrt dazu, dass die Tabelle \u00fcber mehrere Beziehungen f\u00fcr das mehrstufige L\u00f6schen auf die angegebene Tabelle verweist. Die L\u00f6schregel der bestehenden Beziehung ist SET NULL.)


XCL36.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel muss {0} sein. (Die referenzielle Integrit\u00e4tsbedingung verweist auf sich selbst. Eine vorhandene auf sich selbst verweisende referenzielle Integrit\u00e4tsbedingung hat die L\u00f6schregel NO ACTION, RESTRICT oder CASCADE.)

XCL37.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel muss {0} sein. (Die referenzielle Integrit\u00e4tsbedingung verweist auf sich selbst, und die Tabelle befindet sich in einer Abh\u00e4ngigkeitsbeziehung mit der L\u00f6schregel CASCADE.)
XCL38.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel muss {0} sein. (Die Beziehung w\u00fcrde dazu f\u00fchren, dass die Tabelle \u00fcber mehrere Beziehungen f\u00fcr das mehrstufige L\u00f6schen auf dieselbe Tabelle verweist. Diese Beziehungen m\u00fcssen dieselbe L\u00f6schregel NO ACTION, RESTRICT oder CASCADE haben.)


XCL39.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel darf nicht CASCADE lauten. (Es liegt eine auf sich selbst verweisende Integrit\u00e4tsbedingung mit der L\u00f6schregel SET NULL, NO ACTION oder RESTRICT vor.)

XCL40.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel darf nicht CASCADE lauten. (Es w\u00fcrde eine Kreisbeziehung entstehen, in der eine Tabelle f\u00fcr das mehrstufige L\u00f6schen auf sich selbst verweisen w\u00fcrde.) Eine der vorhandenen L\u00f6schregeln in der Beziehung ist nicht CASCADE. Die Beziehung kann demzufolge definiert werden, wenn die L\u00f6schregel nicht CASCADE lautet.)

XCL41.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel darf nicht CASCADE lauten. (Die Beziehung w\u00fcrde dazu f\u00fchren, dass eine andere Tabelle \u00fcber mehrere Pfade mit verschiedenen L\u00f6schregeln oder der einheitlichen L\u00f6schregel SET NULL f\u00fcr das mehrstufige L\u00f6schen auf dieselbe Tabelle verweisen w\u00fcrde.)

XCL42.S="CASCADE"
XCL43.S="SET NULL"
XCL44.S="RESTRICT"
XCL45.S="NO ACTION"
XCL46.S="SET DEFAULT"

XCL47.S=Die Verwendung von ''{0}'' setzt voraus, dass Sie ein Upgrade der Datenbank von Version {1} auf Version {2} oder eine aktuellere Version durchf\u00fchren.

XCL48.S= F\u00fcr ''{0}'' ist TRUNCATE TABLE nicht zul\u00e4ssig, weil aktivierte Integrit\u00e4tsbedingungen f\u00fcr Fremdschl\u00fcssel in anderen Tabellen auf Integrit\u00e4tsbedingungen f\u00fcr eindeutige oder Prim\u00e4rschl\u00fcssel in dieser Tabelle verweisen. 
XCL49.S= F\u00fcr ''{0}'' ist TRUNCATE TABLE nicht zul\u00e4ssig, weil ein aktivierter DELETE-Ausl\u00f6ser vorliegt ({1}).
XCL50.S=Ein Upgrade f\u00fcr eine fr\u00fchere Version der Datenbank wird nicht unterst\u00fctzt. Die Datenbank, auf die zugegriffen wird, hat den Versionsstand ''{0}'' und diese Software den Versionsstand ''{1}''.


# Transaction states, matches DB2
25000=Ung\u00fcltiger Transaktionsstatus

# Authorization
25501=Das Verbindungsmerkmal f\u00fcr Lesezugriff kann nicht in einer aktiven Transaktion gesetzt werden.
25502=F\u00fcr eine Verbindung, einen Benutzer oder eine Datenbank mit Lesezugriff sind \u00c4nderungen von SQL-Daten unzul\u00e4ssig.
25503=F\u00fcr eine Verbindung, einen Benutzer oder eine Datenbank mit Lesezugriff ist die DDL unzul\u00e4ssig.
25505=Ein Benutzer mit Lesezugriff oder der Benutzer einer Datenbank mit Lesezugriff ist nicht berechtigt, den Nurlesezugriff f\u00fcr eine Verbindung zu inaktivieren.
28501=Ung\u00fcltiges Datenbankberechtigungsmerkmal ''{0}={1}''.
28502.C=Der Benutzername ''{0}'' ist ung\u00fcltig.

28503=Benutzer ''{0}'' d\u00fcrfen nicht gleichzeitig in Berechtigungslisten f\u00fcr Lesezugriff und Vollzugriff enthalten sein.
28504=Mehrfach genannte(r) Benutzer ''{1}'' in der Zugriffsliste ''{0}'';
04501.C=Die Datenbankverbindung wurde verweigert.


# Dependency Manager
XD003.S=Die Abh\u00e4ngigkeit kann nicht vom Datentr\u00e4ger zur\u00fcckgeschrieben werden. DependableFinder = ''{0}''. Weitere Informationen: ''{1}''.
XD004.S=Es k\u00f6nnen keine Abh\u00e4ngigkeiten gespeichert werden.


#../java/com/ibm/db2j/impl/Connectivity/JDBC/Local/messages.properties
24000=Ung\u00fcltiger Cursorstatus; keine aktuelle Zeile.

07000=Mindestens ein Parameter der aktuellen Anweisung wurde nicht initialisiert.

# 07004 : {0} is an number {1) is fixed text OUT or INOUT
07004=Der Parameter {0} ist ein {1}-Prozedurparameter und muss vor der Ausf\u00fchrung mit CallableStatement.registerOutParameter registriert werden.

07009=Keine Eingabeparameter.

S0022=Die Spalte ''{0}'' wurde nicht gefunden.
XJ009.S=F\u00fcr das Aufrufen einer gespeicherten Prozedur ist die Verwendung von CallableStatement oder von Ausgabeparametern erforderlich: {0}
XJ010.S=SAVEPOINT kann nicht abgesetzt werden, wenn autoCommit aktiviert ist.
XJ011.S=Null kann nicht als Name f\u00fcr den Sicherungspunkt \u00fcbergeben werden.
XJ012.S=''{0}'' ist bereits geschlossen.
XJ013.S=Keine ID f\u00fcr benannte Sicherungspunkte.
XJ014.S=Kein Name f\u00fcr nicht benannte Sicherungspunkte.
XJ016.S=Die Methode ''{0}'' ist in einer vorbereiteten Anweisung nicht zul\u00e4ssig.
XJ017.S=Innerhalb des Ausl\u00f6secodes ist ein Sicherungspunktbefehl unzul\u00e4ssig.
XJ018.S=Der Spaltenname muss ungleich null sein.
XJ020.S=Der Objekttyp kann nicht in TYPE ''{0}'' konvertiert werden. Der Wert f\u00fcr java.sql.Types ist ung\u00fcltig oder der Objektzeiger ist ein Nullzeiger.
XJ022.S=Der folgende Datenstrom kann nicht definiert werden: ''{0}''.
XJ023.S=Der Eingabedatenstrom enthielt f\u00fcr die erforderliche L\u00e4nge zu weinig Daten.
XJ025.S=Ein Eingabedatenstrom kann keine negative L\u00e4nge haben.
XJ030.S=In einer verschachtelten Verbindung kann AUTOCOMMIT ON nicht gesetzt werden.
XJ042.S=''{0}'' ist kein g\u00fcltiger Wert f\u00fcr das Merkmal ''{1}''.
XJ044.S=''{0}'' ist eine ung\u00fcltige Skala.
XJ045.S=An Connection.setTransactionIsolationLevel() wurde die ung\u00fcltige oder (derzeit) nicht unterst\u00fctzte Isolationsstufe ''{0}'' \u00fcbergeben. Derzeit unterst\u00fctzte Werte sind java.sql.Connection.TRANSACTION_SERIALIZABLE, java.sql.Connection.TRANSACTION_REPEATABLE_READ, java.sql.Connection.TRANSACTION_READ_COMMITTED und java.sql.Connection.TRANSACTION_READ_UNCOMMITTED.
XJ04B.S=Der Stapel darf keinen Befehl enthalten, der versucht, eine Ergebnismenge zur\u00fcckzugeben.
XJ04C.S=Der CallableStatement-Stapel darf keine Ausgabeparameter enthalten.
XJ056.S=In einer XA-Verbindung kann AUTOCOMMIT ON nicht gesetzt werden.
XJ057.S=Eine globale Transaktion kann nicht \u00fcber die Verbindung festgeschrieben werden. Die Verarbeitung der COMMIT-Verarbeitung muss \u00fcber die Schnittstelle XAResource erfolgen.
XJ058.S=Eine globale Transaktion kann nicht \u00fcber die Verbindung zur\u00fcckgesetzt werden. Die Verarbeitung der COMMIT-Verarbeitung muss \u00fcber die Schnittstelle XAResource erfolgen.
XJ059.S=Eine Verbindung kann nicht beendet werden, solange noch eine globale Transaktion aktiv ist.
XJ05C.S=Die Konstante ResultSet.HOLD_CURSORS_OVER_COMMIT f\u00fcr das Offenhalten kann f\u00fcr eine globale Transaktion nicht definiert werden.
XJ061.S=Die Methode ''{0}'' ist nur f\u00fcr Scroll-Cursor zul\u00e4ssig.
XJ062.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr ResultSet.setFetchSize(int rows).
XJ063.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr Statement.setMaxRows(int maxRows). Der Parameterwert muss >= 0 sein.
XJ064.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr setFetchDirection(int direction).
XJ065.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr Statement.setFetchSize(int rows).
XJ066.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr Statement.setMaxFieldSize(int max).
XJ067.S=Der SQL-Textzeiger ist null.
XJ068.S=In der Mitte eines Stapels sind nur executeBatch und clearBatch zul\u00e4ssig.
XJ069.S=Wenn Sie mit EXECUTE STATEMENT USING arbeiten, sind SetXXX-Methoden unzul\u00e4ssig.
XJ080.S=EXECUTE STATEMENT USING hat nicht {1} Parameter, sondern {0} Parameter \u00fcbergeben.
XJ070.S=In einer BLOB- oder CLOB-Methode wurde das Argument ''{0}'' mit negativer oder Nullposition \u00fcbergeben.
XJ071.S=In einer BLOB- oder CLOB-Methode wurde das Argument ''{0}'' mit Nulll\u00e4nge oder negativer L\u00e4nge \u00fcbergeben.
XJ072.S=An eine BLOB- oder CLOB-Methode wurde ein Nullmuster oder eine Nullsuchzeichenfolge \u00fcbergeben.
XJ073.S=Die Daten in diesem BLOB oder CLOB sind nicht mehr verf\u00fcgbar. Dies kann daran liegen, dass die zugeh\u00f6rige Transaktion festgeschrieben oder die zugeh\u00f6rige Verbindung beendet wurde.
XJ076.S=Das Positionsargument ''{0}'' \u00fcberschreitet die Gr\u00f6\u00dfe des BLOB/CLOB.
XJ077.S=Bei dem Versuch, mit getBytes/getSubString das erste Byte/Zeichen des BLOB/CLOB-Musters zu lesen, wurde eine Ausnahme empfangen.
XJ082.U=BLOB/CLOB-Werte sind als Methodenparameter oder Empf\u00e4nger nicht zul\u00e4ssig.

0A000.S=Nicht implementiertes Feature: {0}.

XJ004.C=Die Datenbank ''{0}'' wurde nicht gefunden.
08004=Zur\u00fcckgewiesene Verbindung: {0}
A020=Ung\u00fcltige Authentifizierung.
08003=Keine aktuelle Verbindung.
XJ028.C=Der URL ''{0}'' hat nicht das richtige Format.
XJ040.C=Die Datenbank ''{0}'' konnte nicht gestartet werden. Details k\u00f6nnen Sie der n\u00e4chsten Ausnahme entnehmen.
XJ041.C=Die Datenbank ''{0}'' konnte nicht erstellt werden. Details k\u00f6nnen Sie der n\u00e4chsten Ausnahme entnehmen.
XJ049.C=Es wurde in Konflikt stehende Erstellungsattribute angegeben.
XJ081.C=Es wurde in Konflikt stehende Erstellungs-/Wiederherstellungsattribute angegeben.
XJ05B.C=Das JDBC-Attribut ''{0}'' hat den ung\u00fcltigen Wert ''{1}''. G\u00fcltige Werte sind ''{2}''.

XXXXX.C.6=Normale Beendigung der Datenbanksitzung.

08006.D=Die Datenbank ''{0}'' wird heruntergefahren.

XJ015.M=Das Derby-System wird heruntergefahren.

01J01=Die Datenbank ''{0}'' wurde nicht erstellt. Stattdessen wurde eine Verbindung zu einer vorhandenen Datenbank hergestellt.
01J02=Scroll-Cursor sind derzeit nicht implementiert.
01J03=Aktualisierbare ResultSets sind derzeit nicht implementiert.
01J04=Die Klasse ''{0}'' f\u00fcr die Spalte ''{1}'' implementiert weder java.io.Serializable noch java.sql.SQLData. Eine dieser Schnittstellen muss von Instanzen implementiert werden, damit sie gespeichert werden k\u00f6nnen.
01J05=Der Upgrade f\u00fcr die Datenbank wurde fehlerfrei durchgef\u00fchrt. Die erweiterte Datenbank steht zur Verwendung bereit. Die gespeicherten vorbereiteten Anweisungen konnten nicht erneut ausgewertet werden. Details zu diesem Fehler enth\u00e4lt die n\u00e4chste Ausnahme. 
XJ001.U=Java-Ausnahme: ''{1}: {0}''.
XJ050.U=F\u00fcr die Datenbankversion {0} ist ein Upgrade erforderlich. Setzen Sie f\u00fcr den JDBC-Verbindungs-URL das Attribut ''upgrade=true'', um ein Upgrade auf Version {1} zu erm\u00f6glichen.


# org.apache.derby.database.UserUtility
#
XCZ00.S=Unbekannte Berechtigung ''{0}''.
XCZ01.S=Unbekannter Benutzer ''{0}''.
XCZ02.S=Ung\u00fcltiger Parameter ''{0}''=''{1}''.

# SQL J Jar support
46001=Ausnahme beim Zugriff auf die JAR-Datei mit dem URL ''{0}''.

###############################################################################
#
# Text for non-exception strings
#
###############################################################################

# Log
L001=------------  ANFANG DER FEHLERNACHRICHT -------------\n
L002=------------  ENDE DER FEHLERNACHRICHT -------------\n
L003=\n------------  ANFANG DES FEHLERBEREICHS F\u00dcR SHUTDOWN -------------\n
L004=\n------------  ENDE DES FEHLERBEREICHS F\u00dcR SHUTDOWN -------------\n
L005=\n------------  ANFANG DES FEHLERBEREICHS -------------\n
L006=\n------------  ENDE DES FEHLERBEREICHS -------------\n
L007=WARNUNG: Die Protokolldatei wurde nicht gefunden. Es wird ein neues Protokoll erstellt. M\u00f6glicherweise ist die Datenbank inkonsistent.
L008=Die inkompatible alte Protokolldatei {0} wird gel\u00f6scht
L009=Die alte Protokolldatei {0} wird gel\u00f6scht
L010=In der Datei {0} wurde ein unvollst\u00e4ndiger Protokollsatz gefunden. Der Inhalt der Protokolldatei wird von der Position {1} bis zum Dateiende bei {2} gel\u00f6scht.
L011=Der Pr\u00fcfpunktd\u00e4mon hat eine Standardausnahme abgefangen.
L012=Der Protokollsatz ist nicht als erster Satz der Transaktion markiert. Die Transaktion wurde jedoch nicht in der Transaktionstabelle gefunden. {0}
L013=Der Protokollsatz ist als erster Satz der Transaktion markiert. Die Transaktion ist jedoch bereits in der Transaktionstabelle enthalten. {0}
L014=Falsche Anfangsadresse
L015=Es ist bereits eine neue Protokolldatei vorhanden, die nicht gel\u00f6scht werden kann. {0}
L016=Die neue Protokolldatei {0} kann nicht erstellt werden.
L017=Die neue Protokolldatei {0} kann nicht erstellt werden. Grund: {1}.
L018=Das System hat m\u00f6glicherweise einen inkonsistenten Status. Fehlende Datei: {0}

# Class Manager
C000=Die Klasse {0} wurde in die Datei {1} geschrieben. Stellen Sie Unterst\u00fctzung f\u00fcr die Datei und die folgende Ausnahme bereit: {2}
C001=Die Klasse {0} enth\u00e4lt in der JAR-Datei {1} einen unbekannten Zertifikattyp. Es wurde ein X509-Zertifikat erwartet.
C002=Beim Zugriff auf die Klasse {0} in der JAR-Datei {1} wurde die folgende Sicherheitsausnahme ausgel\u00f6st: {2}
C003=Ausnahme beim Laden der Datenbank-JAR-Datei {0} - {1}
C004=Veraltetes Klassenladeprogramm f\u00fcr die Klasse {0}
C005=Das Ladeprogramm f\u00fcr Datenbankklassen wurde gestartet - derby.database.classpath=''{0}''
C006={0} wurde aus der Datenbank-JAR-Datei {1} geladen.
C007=Beim Laden der Klasse {0} aus der JAR-Datei {1} eingetretene Ausnahme: {2}

# RawStore Data

D001=:\n Booten von Derby Version {0}: Instanz {1}\nf\u00fcr das Datenbankverzeichnis {2} \n
D002=:\nDie Instanz {0} wird heruntergefahren.
D004=Die Sicherung f\u00fcr die Datenbank mit der Adresse {0} wurde gestartet.
D005=Die alte Sicherungskopie wurde von {0} nach {1} verschoben.
D006=Das Datenbankverzeichnis wurde von {0} nach {1} kopiert.
D007=F\u00fcr die Datenbank wurde service.properties editiert, um den Standardprotokollservice verwenden zu k\u00f6nnen.
D008=Fehler beim Editieren von service.properties f\u00fcr die Datenbank. Abgebrochene Sicherung: {0}
D009=Das Protokollverzeichnis wurde von {0} nach {1} kopiert.
D010=Die Sicherung wurde wegen eines Fehlers abgebrochen.
D011=Die alte Sicherungskopie mit der Adresse {0} wurde gel\u00f6scht.
D012=Die Sicherung ist abgeschlossen. Protokolladresse: {0} \n

# Connectivity 
J004=Datenbankidentit\u00e4t
J005=Derby herunterfahren
J007=Datenbank erstellen
J008=keine Details
J010=Datenbank auf Datentr\u00e4ger verschl\u00fcsseln
J013=Datenbank erweitern
J016=Verschl\u00fcsselungsserviceprovider
J017=Verschl\u00fcsselungsalgorithmus
J018=L\u00e4nge des Chiffrierschl\u00fcssels
J019=Externer Chiffrierschl\u00fcssel
J020=Geheimer Chiffrierschl\u00fcssel
J021=Gebietsschema der Datenbank
J022=Benutzername
J023=Benutzerkennwort
J025=Verzeichnispfad protokollieren
J028=Sicherungspfad f\u00fcr aktualisierende Wiederherstellung
J100=Die Netzserverklasse {0} wurde nicht gefunden. Ihr Klassenpfad sollte csnet.jar enthalten.
J101=Die Netzserverklasse {0} konnte nicht geladen werden. {1} \u00dcberpr\u00fcfen Sie die Integrit\u00e4t Ihrer Datei csnet.jar.
J102=Beim Starten des Netzservers wurde eine Ausnahme ausgel\u00f6st. {0}
J103=Beim Herunterfahren des Netzservers wurde eine Ausnahme ausgel\u00f6st. {0}

# Authentication
A001=SCHWERWIEGENDER FEHLER: Es gibt keinen Authentifizierungsservice f\u00fcr das System
A002=SCHWERWIEGENDER FEHLER: Es gibt keinen Authentifizierungsservice f\u00fcr die Datenbank
A011=WARNUNG: Im Merkmal {0} ist kein LDAP-Server-/Hostname angegeben. Es wird localhost:389 verwendet.

I015=org.apache.derby.jdbc.EmbeddedDriver wurde nicht im JDBC-Treibermanager registriert.
I024=Die Datenbank ist nicht verf\u00fcgbar.
I025=Der JDBC-Treiber ist nicht verf\u00fcgbar.

# Import/Export
XIE01.S=Es ist keine Verbindung vorhanden.
XIE03.S=In Zeile {0} f\u00fcr Spalte {1} wurden nach dem Endbegrenzer Daten gefunden.
XIE04.S=Nicht gefundene Datendatei: {0}
XIE05.S=Es muss eine Datendatei angegeben werden.
XIE06.S=Der Name der Definitionseinheit wurde nicht angegeben.
XIE07.S=Feld- und Satztrennzeichen k\u00f6nnen nicht als Unterzeichenfolge des jeweils anderen Trennzeichens verwendet werden.
XIE08.S=Es gibt keine Spalte mit dem Namen {0}.
XIE09.S=Summe der Spalten in der Zeile: {0}
XIE0B.S=Die Spalte ''{0}'' der Tabelle ist vom Typ {1}, der vom Import/Export nicht unterst\u00fctzt wird.
XIE0D.S=In Zeile {0} wurde kein Satztrennzeichen gefunden.
XIE0E.S=In Zeile {0} wurde an unerwarteter Stelle ein Dateiende gelesen.
XIE0I.S=Beim Schreiben von Daten in die Datei wurde eine E/A-Ausnahme empfangen.
XIE0J.S=Ein Begrenzer ist ung\u00fcltig oder wird mehrfach verwendet.
XIE0K.S=Als Zeichenfolgenbegrenzer wurde ein Punkt angegeben.
XIE0M.S=Die Tabelle ''{0}'' ist nicht vorhanden.

# Monitor
M001=\n# ********************************************************************\n# ***           Diese Datei darf NICHT bearbeitet werden.          ***\n# *** BEIM \u00c4NDERN DES DATEIINHALTS K\u00d6NNEN DATEN BESCH\u00c4DIGT WERDEN. ***\n# ********************************************************************




#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
#
#  DO NOT TRANSLATE MESSAGES OR TEXT BELOW THIS LINE
#
#
# ----------------------------------------------------------------------------------------------------------


