
###############################################################################
#
# Text for exceptions
#
###############################################################################

# Monitor
XBM01.D=Echec du d\u00e9marrage en raison d'une exception ; pour plus de d\u00e9tails, voir l'exception suivante.
XBM02.D=Echec du d\u00e9marrage en raison d''une fonctionnalit\u00e9 manquante pour {0}.  Assurez-vous que votre chemin de classes contient les logiciels Derby appropri\u00e9s.
XBM05.D=Echec du d\u00e9marrage en raison d''informations manquantes sur la version du produit pour {0}.
XBM06.D=Echec du d\u00e9marrage ; il est impossible d'acc\u00e9der \u00e0 une base de donn\u00e9es chiffr\u00e9e sans le mot de passe d'amor\u00e7age appropri\u00e9.
XBM07.D=Echec du d\u00e9marrage ; le mot de passe d'amor\u00e7age doit avoir une longueur minimale de 8 octets.
XBM08.D=Impossible d''instancier la classe {0} StorageFactory {1}.

XBM0G.D=Echec du d\u00e9marrage du moteur de chiffrement. Assurez-vous que vous ex\u00e9cutez Java 2 et que vous avez t\u00e9l\u00e9charg\u00e9 un fournisseur de chiffrement tel que jce et que vous l'avez plac\u00e9 dans votre chemin de classes.
XBM0H.D=Impossible de cr\u00e9er le r\u00e9pertoire {0}.
XBM0I.D=Impossible de supprimer le r\u00e9pertoire {0}.
XBM0J.D=Le r\u00e9pertoire {0} existe d\u00e9j\u00e0.
XBM0K.D=Sous-protocole inconnu pour le nom de la base de donn\u00e9es {0}.
XBM0L.D=La classe de m\u00e9thode d''authentification sp\u00e9cifi\u00e9e {0} n''impl\u00e9mente pas l''interface d''authentification {1}.
XBM0M.D=Une erreur s''est produite lors de la cr\u00e9ation d''une instance de la classe de m\u00e9thode d''authentification {0}.
XBM0N.D=Echec de l'enregistrement du pilote JDBC dans java.sql.DriverManager ; pour plus de d\u00e9tails, voir l'exception suivante.
XBM0P.D=Le fournisseur de services est en lecture seule, l'op\u00e9ration n'est pas autoris\u00e9e.
XBM0S.D=Impossible de renommer le fichier ''{0}'' en ''{1}''
XBM0T.D=Sous-protocole ambigu pour le nom de la base de donn\u00e9es {0}.
XBM0U.S=Aucune classe n''a \u00e9t\u00e9 enregistr\u00e9e pour l''identificateur {0}
XBM0V.S=Une exception a \u00e9t\u00e9 \u00e9mise pendant le chargement de la classe {1} enregistr\u00e9e pour l''identificateur {0}
XBM0W.S=Une exception a \u00e9t\u00e9 \u00e9mise pendant la cr\u00e9ation d''une instance de la classe {1} enregistr\u00e9e pour l''identificateur {0}
XBM0X.D=La description d''environnement du territoire fournie ''{0}'' n''est pas valide ; ln[_CO[_variant]] doit \u00eatre sp\u00e9cifi\u00e9\nln=code de langue ISO-639 en minuscules et en deux lettres, CO=codes pays ISO-3166 en majuscules et en deux lettres, voir java.util.Locale.
XBM0Y.D=Le r\u00e9pertoire de sauvegarde de la base de donn\u00e9es {0} est introuvable. Assurez-vous que le chemin de sauvegarde indiqu\u00e9 est correct.
XBM0Z.D=Impossible de copier le fichier ''{0}'' dans ''{1}''. Assurez-vous que l''espace est suffisant et que les droits d''acc\u00e8s sont corrects. 
XBM0Q.D=Fichier {0} introuvable. Assurez-vous que la copie de sauvegarde est la bonne et qu''elle n''est pas alt\u00e9r\u00e9e.
XBM0R.D=Impossible de supprimer le fichier {0}.

# Upgrade
XCW00.D=Mise \u00e0 niveau de ''{0}'' vers ''{1}'' non prise en charge.

# Feature not supported


# COntext service
08000=Connexion ferm\u00e9e par une interruption inconnue.

#../java/com/ibm/db2j/protocol/BasicServices/LockManager/messages.properties
40001=Aucun verrou n''a pu \u00eatre obtenu en raison d''un interblocage ; le cycle de verrous et d''unit\u00e9s en attente est :\n {0}La victime s\u00e9lectionn\u00e9e est XID : {1}

40XL1=Aucun verrou n'a pu \u00eatre obtenu dans le d\u00e9lai demand\u00e9
40XL2=Aucun verrou n''a pu \u00eatre obtenu dans le d\u00e9lai demand\u00e9.  La liste lockTable est : {0}

# ClassManager
XBCM1.S=Erreur de liaison Java \u00e9mise au cours du chargement de la classe g\u00e9n\u00e9r\u00e9e {0}.
XBCM2.S=Impossible de cr\u00e9er une instance de la classe g\u00e9n\u00e9r\u00e9e {0}.
XBCM3.S=La m\u00e9thode {1}() n''existe pas dans la classe g\u00e9n\u00e9r\u00e9e {0}.

# Properties

XCY00.S=Valeur non admise pour la propri\u00e9t\u00e9 ''{0}''=''{1}''.
XCY02.S=La modification de propri\u00e9t\u00e9 demand\u00e9e n''est pas prise en charge ''{0}''=''{1}''.
XCY03.S=La propri\u00e9t\u00e9 requise ''{0}'' n''a pas \u00e9t\u00e9 d\u00e9finie.

# Cryptography
XBCX0.S=Exception du fournisseur de chiffrement ; pour plus de d\u00e9tails, voir l'exception suivante.
XBCX1.S=Initialisation du code de chiffrement dans un mode non admis ; ce mode doit \u00eatre soit ENCRYPT, soit DECRYPT.
XBCX2.S=Initialisation du code de chiffrement avec un mot de passe d''amor\u00e7age trop court ; il doit contenir au minimum {0} caract\u00e8res
XBCX5.S=Impossible de modifier le mot de passe d'amor\u00e7age pour lui affecter la valeur null.
XBCX6.S=Impossible de modifier le mot de passe d'amor\u00e7age en un type s\u00e9rialisable qui ne soit pas de type cha\u00eene.
XBCX7.S=Format incorrect pour modifier le mot de passe d'amor\u00e7age.  Le format suivant doit \u00eatre utilis\u00e9 : ancien_motdepasse_amor\u00e7age, nouveau_motdepasse_amor\u00e7age.
XBCX8.S=Impossible de modifier le mot de passe d'amor\u00e7age pour une base de donn\u00e9es non chiffr\u00e9e.
XBCX9.S=Impossible de modifier le mot de passe d'amor\u00e7age pour une base de donn\u00e9es en lecture seule.
XBCXA.S=Mot de passe d'amor\u00e7age incorrect.
XBCXB.S=Remplissage de chiffrement incorrect ''{0}'' ou remplissage non sp\u00e9cifi\u00e9. Vous devez utiliser ''NoPadding'' (pas de remplissage).
XBCXC.S=L''algorithme de chiffrement ''{0}'' n''existe pas. V\u00e9rifiez que le fournisseur choisi ''{1}'' prend en charge cet algorithme.
XBCXD.S=L'algorithme de chiffrement ne peut pas \u00eatre modifi\u00e9 une fois que la base de donn\u00e9es est cr\u00e9\u00e9e.
XBCXE.S=Le fournisseur de chiffrement ne peut pas \u00eatre modifi\u00e9 une fois que la base de donn\u00e9es est cr\u00e9\u00e9e.
XBCXF.S=La classe ''{0}'' qui repr\u00e9sente le fournisseur de chiffrement est introuvable.
XBCXG.S=Le fournisseur de chiffrement ''{0}'' n''existe pas.
XBCXH.S=L''algorithme de chiffrement ''{0}'' n''est pas dans le format correct. Le format correct est algorithme/modeCommentaires/PasdeRemplissage.
XBCXI.S=Le mode commentaires ''{0}'' n''est pas pris en charge. Les modes commentaires pris en charge sont CBC, CFB, OFB et ECB.
XBCXJ.S=L'application utilise une version de Java Cryptography Extension (JCE) ant\u00e9rieure \u00e0 1.2.1.  Effectuez la mise \u00e0 niveau vers JCE 1.2.1, puis recommencez l'op\u00e9ration.
XBCXK.S=La cl\u00e9 de chiffrement donn\u00e9e ne concorde pas avec celle qui est utilis\u00e9e lors de la cr\u00e9ation de la base de donn\u00e9es. V\u00e9rifiez que vous utilisez la cl\u00e9 de chiffrement correcte et recommencez.

XBCXL.S=La proc\u00e9dure de v\u00e9rification de la cl\u00e9 de chiffrement n'a pas abouti. Pour plus de d\u00e9tails, reportez-vous \u00e0 l'exception suivante. Une erreur s'est peut-\u00eatre produite lors de l'acc\u00e8s au fichier appropri\u00e9 pour la proc\u00e9dure de v\u00e9rification.

#../java/com/ibm/db2j/impl/BasicServices/CacheService/Generic/messages.properties

# CacheStatementException messages
# sqlstate range: XBCA0 to XBCAZ

XBCA0.S=Impossible de cr\u00e9er un nouvel objet avec la cl\u00e9 {1} dans la cache {0} ; il existe d\u00e9j\u00e0 dans la cache.


# java/com/ibm/db2j/protocol/Database/Storage/Access/Interface.
# sqlstate range: XSAI0 to XSAIZ
XSAI2.S=Le conglom\u00e9rat ({0}) demand\u00e9 n''existe pas.
XSAI3.S=Fonction non impl\u00e9ment\u00e9e.

# java/com/ibm/db2j/protocol/Database/Storage/Access/Interface
# RunTimeStatistics properties messages.
# sqlstate range: XSAJ0 to XSAJZ
XSAJ0.U=Type d'analyse
XSAJ1.U=Nombre de pages visit\u00e9es.
XSAJ2.U=Nombre de lignes visit\u00e9es.
XSAJ3.U=Nombre de lignes supprim\u00e9es visit\u00e9es.
XSAJ4.U=Nombre de lignes qualifi\u00e9es.
XSAJ5.U=Nombre de colonnes extraites.
XSAJ6.U=Ensemble binaire de colonnes extrait
XSAJ7.U=Hauteur de l'arborescence
XSAJ8.U=Type de tri
XSAJA.U=Nombre de lignes en entr\u00e9e
XSAJB.U=Nombre de lignes en sortie
XSAJC.U=Nombre d'ex\u00e9cutions de fusion
XSAJD.U=Taille des ex\u00e9cutions de fusion
XSAJE.U=Toutes

#NOTE: The next three messages are the names of types of scans.
XSAJF.U=btree
XSAJG.U=heap
XSAJH.U=sort

#NOTE: The next two messages are types of sorts
XSAJI.U=externe
XSAJJ.U=interne

# java/com/ibm/db2j/protocol/Database/Storage/Access/XA.
# sqlstate range: XSAX0 to XSAXZ
XSAX0.S=Violation du protocole XA
XSAX1.S=Une tentative de lancement d'une transaction globale avec le Xid d'une transaction globale existante a \u00e9t\u00e9 effectu\u00e9e.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/AccessManager/Generic
# sqlstate range: XSAM0 to XSAMZ
XSAM0.S=Exception d\u00e9tect\u00e9e lors de la tentative d''amor\u00e7age du module pour ''{0}''.
XSAM2.S=Aucun index ni conglom\u00e9rat ayant pour ID de conglom ''{0}'' n''est \u00e0 supprimer.
XSAM3.S=Il n''existe aucun index ni conglom\u00e9rat ayant pour ID de conglom ''{0}''.
XSAM4.S=Il n''existe aucun tri ayant pour nom ''{0}''.
XSAM5.S=L'analyse doit \u00eatre ouverte et positionn\u00e9e par un appel de la m\u00e9thode next() avant la lancement d'autres appels.
XSAM6.S=L''enregistrement {2} de la page {1} du conteneur {0} n''a pas \u00e9t\u00e9 trouv\u00e9.


#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/Generic
# sqlstate range: XSCG0 to XSCGZ
XSCG0.S=Impossible de cr\u00e9er un mod\u00e8le.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/Heap
# sqlstate range: XSCH0 to XSCHZ

XSCH8.S=Fonction non impl\u00e9ment\u00e9e.
XSCH7.S=L'analyse n'est pas positionn\u00e9e.
XSCH6.S=Le conteneur de segments de m\u00e9moire ayant l''ID de conteneur {0} est ferm\u00e9.
XSCH5.S=Dans une table de base, le num\u00e9ro de colonne demand\u00e9 {0} et le nombre maximum de colonnes {1} ne concordaient pas.
XSCH4.S=Impossible de cr\u00e9er de conglom\u00e9rat.
XSCH1.S=Impossible de trouver le conteneur {0}.
XSCH0.S=Impossible de cr\u00e9er un conteneur.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/BTree/Generic
# sqlstate range: XSCB0 to XSCBZ
XSCB9.S=R\u00e9serv\u00e9 pour les tests.
XSCB8.S=Le conglom\u00e9rat btree {0} est ferm\u00e9.
XSCB7.S=Une erreur interne a \u00e9t\u00e9 d\u00e9tect\u00e9e au cours d''une analyse - current_rh est null = {0}, la cl\u00e9 de position est null = {1}.
XSCB6.S=Restriction : L'enregistrement d'un index secondaire btree ne peut pas \u00eatre mis \u00e0 jour ou ins\u00e9r\u00e9 en raison du manque d'espace sur la page.   Utilisez les param\u00e8tres derby.storage.pageSize et/ou derby.storage.pageReservedSpace pour contourner cette restriction.
XSCB5.S=Au cours de l'annulation logique d'une insertion ou d'une suppression btree, la ligne n'a pas pu \u00eatre trouv\u00e9e dans l'arborescence.
XSCB4.S=Une m\u00e9thode sur une analyse d''ouverture btree a \u00e9t\u00e9 appel\u00e9e avant que l''analyse ne soit positionn\u00e9e sur la premi\u00e8re ligne (c'est-\u00e0-dire qu''aucun appel de next() n''a encore \u00e9t\u00e9 effectu\u00e9).  L''\u00e9tat actuel de l''analyse est ({0}).
XSCB3.S=Fonction non impl\u00e9ment\u00e9e.
XSCB2.S=La propri\u00e9t\u00e9 requise {0} n''a pas \u00e9t\u00e9 trouv\u00e9e dans la liste de propri\u00e9t\u00e9s fournie \u00e0 createConglomerate() pour un index secondaire btree.
XSCB1.S=Impossible de trouver le conteneur {0}.
XSCB0.S=Impossible de cr\u00e9er un conteneur.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Sort/External
# sqlstate range: XSAS0 to XSASZ

XSAS6.S=Impossible d'acqu\u00e9rir des ressources pour le tri.
XSAS3.S=Le type d'une ligne ins\u00e9r\u00e9e dans un tri ne correspond pas au mod\u00e8le du tri.
XSAS1.S=Une tentative d'extraction d'une ligne avant le d\u00e9but d'un tri ou apr\u00e8s la fin d'un tri a \u00e9t\u00e9 effectu\u00e9e.
XSAS0.S=Une m\u00e9thode de l'interface de contr\u00f4leur d'analyse inad\u00e9quate pour une analyse de tri a \u00e9t\u00e9 appel\u00e9e.

# java/com/ibm/db2j/protocol/Database/Storage/RawStore/Interface.
# statement errors.
# sqlstate range: XSRS0 to XSRSZ
XSRS0.S=Impossible de geler la base de donn\u00e9es lorsqu'elle a d\u00e9j\u00e0 \u00e9t\u00e9 gel\u00e9e.
XSRS1.S=Impossible de sauvegarder la base de donn\u00e9es dans {0} car il ne s''agit pas d''un r\u00e9pertoire.
XSRS4.S=Erreur lors du changement de nom du fichier (au cours de la sauvegarde) de {0} en {1}.
XSRS5.S=Erreur lors de la copie du fichier (au cours de la sauvegarde) de {0} vers {1}.
XSRS6.S=Impossible de cr\u00e9er le r\u00e9pertoire de sauvegarde {0}.
XSRS7.S=La sauvegarde a intercept\u00e9 une exception inattendue.
XSRS8.S=L'unit\u00e9 de journalisation peut uniquement \u00eatre d\u00e9finie au cours du processus de cr\u00e9ation de la base de donn\u00e9es ; elle ne peut pas \u00eatre modifi\u00e9e \u00e0 la vol\u00e9e.
XSRS9.S=L''enregistrement {0} n''existe plus


# java/com/ibm/db2j/impl/Database/Storage/RawStore/Log/Generic
# statement errors.
# sqlstate range: XSLB0 to XSLBZ
XSLB9.S=Impossible d'\u00e9mettre d'autres modifications ; la fabrique de fichier journal a \u00e9t\u00e9 arr\u00eat\u00e9e.
XSLB8.S=Tentative de r\u00e9initialisation d''une analyse \u00e0 {0}, au-del\u00e0 de sa limite de {1}.
XSLB6.S=Tentative de consignation d'un enregistrement de longueur 0 ou -ve.
XSLB5.S=Instant de truncationLWM {1} incorrect pour le point de troncature {0}. La plage autoris\u00e9e est comprise entre {2} et {3}.
XSLB4.S=Impossible de trouver truncationLWM {0}.
XSLB2.S=L''op\u00e9ration de journalisation {0} enregistre trop de donn\u00e9es ; elle a satur\u00e9 la m\u00e9moire tampon du journal interne.
XSLB1.S=L''op\u00e9ration de journalisation {0} rencontre une erreur lors de son enregistrement dans le flux de donn\u00e9es de journalisation ; cela peut \u00eatre d\u00fb \u00e0 une op\u00e9ration de journalisation errante ou \u00e0 la saturation de la m\u00e9moire tampon du journal interne suite \u00e0 une op\u00e9ration de journalisation trop volumineuse.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Log/Generic
# database errors.
# sqlstate range: XSLA0 to XSLAZ
XSLAT.D=Le r\u00e9pertoire du journal {0} existe d\u00e9j\u00e0. Assurez-vous que l''emplacement sp\u00e9cifi\u00e9 pour la propri\u00e9t\u00e9 logDevice est correct.  
XSLAS.D=Le r\u00e9pertoire du journal {0} n''a pas \u00e9t\u00e9 trouv\u00e9 dans la sauvegarde au cours de la restauration. Assurez-vous que la copie de sauvegarde est la bonne et qu''elle n''est pas alt\u00e9r\u00e9e.
XSLAR.D=Impossible de copier le fichier journal ''{0}'' dans ''{1}'' pendant la restauration. Assurez-vous que l''espace est suffisant et que les droits d''acc\u00e8s sont corrects. 
XSLAQ.D=impossible de cr\u00e9er un fichier journal dans le r\u00e9pertoire {0}.
XSLAP.D=La base de donn\u00e9es {0} est en version {1}. Les bases de donn\u00e9es B\u00eata ne peuvent pas \u00eatre mises \u00e0 niveau.
XSLAO.D=Echec de la reprise, incident inattendu {0}.
XSLAN.D=La base de donn\u00e9es situ\u00e9e dans {0} utilise un format incompatible avec la version actuelle du logiciel.  La base de donn\u00e9es a \u00e9t\u00e9 cr\u00e9\u00e9e ou mise \u00e0 niveau par la version {1}.
XSLAM.D=Impossible de v\u00e9rifier le format de la base de donn\u00e9es situ\u00e9e dans {1} en raison d''une exception d'E/S.
XSLAL.D=La taille de l''enregistrement de journal {2} d\u00e9passe la taille de fichier journal maximale autoris\u00e9e {3}. Erreur d\u00e9tect\u00e9e dans le fichier journal {0}, \u00e0 la position {1}
XSLAK.D=La base de donn\u00e9es a d\u00e9pass\u00e9 le num\u00e9ro de fichier journal le plus grand {0}.
XSLAJ.D=A la suite d'un incident, le syst\u00e8me de journalisation est marqu\u00e9 comme devant \u00eatre arr\u00eat\u00e9 et aucune op\u00e9ration ne peut \u00eatre ex\u00e9cut\u00e9e jusqu'\u00e0 l'arr\u00eat et le red\u00e9marrage du syst\u00e8me.
XSLAI.D=Impossible de consigner l'enregistrement de journal des points de contr\u00f4le.
XSLAH.D=Une base de donn\u00e9es en lecture seule est en cours de mise \u00e0 jour.
XSLAF.D=Une base de donn\u00e9es en lecture seule a \u00e9t\u00e9 cr\u00e9\u00e9e avec des m\u00e9moires tampon de donn\u00e9es non valides.
XSLAE.D=Aucune \u00e9criture dans le fichier de contr\u00f4le situ\u00e9 dans {0}, ni aucune mise \u00e0 jour de ce fichier ne peuvent \u00eatre effectu\u00e9es.
XSLAD.D=L''enregistrement de journal \u00e0 l''instant {2} dans le fichier journal {3} est corrompu. La longueur pr\u00e9vue de l''enregistrement de journal est {0}, la longueur r\u00e9elle est {1}.
XSLAC.D=La base de donn\u00e9es situ\u00e9e dans {0} utilise un format incompatible avec la version actuelle du logiciel ; elle a peut-\u00eatre \u00e9t\u00e9 cr\u00e9\u00e9e ou mise \u00e0 niveau par une version ult\u00e9rieure.
XSLAB.D=Le fichier journal {0} est introuvable ; assurez-vous que votre propri\u00e9t\u00e9 logDevice est d\u00e9finie correctement avec le s\u00e9parateur de chemin d''acc\u00e8s appropri\u00e9 pour votre plateforme.
XSLAA.D=Une exception ant\u00e9rieure a marqu\u00e9 le stockage comme devant \u00eatre arr\u00eat\u00e9.
XSLA8.D=Impossible d''annuler la transaction {0} ; tentative de compensation de l''op\u00e9ration {1} par {2}
XSLA7.D=Impossible de r\u00e9p\u00e9ter l''op\u00e9ration {0} dans le fichier journal.
XSLA6.D=Impossible de r\u00e9cup\u00e9rer la base de donn\u00e9es.
XSLA5.D=Impossible de lire le flux de donn\u00e9es de journalisation dans le but d''annuler la transaction {0}.
XSLA4.D=Impossible d'\u00e9crire dans le journal, ce dernier est probablement satur\u00e9.  Supprimez les fichiers inutiles.  Il est \u00e9galement possible que le syst\u00e8me de fichiers soit en lecture seule, que le disque soit tomb\u00e9 en panne ou qu'un autre incident soit survenu avec le support.
XSLA3.D=Fichier journal alt\u00e9r\u00e9 ; des donn\u00e9es non valides se trouvent dans le flux de donn\u00e9es de journalisation.
XSLA2.D=Le syst\u00e8me va s'arr\u00eater ; une exception d'E-S a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9e lors de l'acc\u00e8s au fichier journal.
XSLA1.D=L''enregistrement de journal a \u00e9t\u00e9 envoy\u00e9 au flux de donn\u00e9es de journalisation, mais il ne peut pas \u00eatre appliqu\u00e9 au stockage (Objet {0}).  Des probl\u00e8mes de reprise peuvent \u00e9galement en d\u00e9couler.
XSLA0.D=Impossible de vider le fichier journal sur le disque {0}.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# statement errors.
# sqlstate range: XSTA0 to XSTAZ
# changed XSTA0 and XSTA1 to match DB2 sqlstates - bug 4466
3B501.S=Un POINT DE SAUVEGARDE portant le nom transmis existe d\u00e9j\u00e0 dans la transaction en cours.
3B502.S=Une LIBERATION ou ANNULATION JUSQU'AU POINT DE SAUVEGARDE a \u00e9t\u00e9 indiqu\u00e9e mais le point de sauvegarde n'existe pas.
3B001.S=Le POINT DE SAUVEGARDE {0} n''existe pas ou n''est pas actif dans la transaction en cours.
3B002.S=Le nombre maximal de points de sauvegarde a \u00e9t\u00e9 atteint. 
XSTA2.S=Une transaction \u00e9tait d\u00e9j\u00e0 active lorsqu'une tentative d'activation d'une autre transaction a \u00e9t\u00e9 effectu\u00e9e.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# transaction errors.
# sqlstate range: 40XT0 to 40XTZ
40XT0=Une erreur interne a \u00e9t\u00e9 identifi\u00e9e par le module RawStore.
40XT1=Une exception a \u00e9t\u00e9 \u00e9mise au cours de la validation de la transaction.
40XT2=Une exception a \u00e9t\u00e9 \u00e9mise au cours de l'annulation d'un POINT DE SAUVEGARDE.
40XT4=Une tentative de fermeture d'une transaction toujours active a \u00e9t\u00e9 effectu\u00e9e ; la transaction a \u00e9t\u00e9 abandonn\u00e9e.
40XT5=Une exception a \u00e9t\u00e9 \u00e9mise au cours d'une transaction interne.
40XT6=La base de donn\u00e9es est en \u00e9tat de repos ; impossible d'activer la transaction.  Attendez un moment qu'elle quitte cet \u00e9tat.
40XT7=Op\u00e9ration non prise en charge dans une transaction interne.

#
#java/com/ibm/db2j/internalUtil
#	Id Parse Errors       			XCXA0-XCXAZ
#  	Db Class Path Parse Errors 	 	XCXB0-XCXBZ
# 	Id List Parse Errors			XCXC0-XCXCZ
#  	IO Errors						XCXD0-XCXDZ
#	LocaleFinder Errors				XCXE0-XCXEZ
XCXA0.S=Identificateur non valide.
XCXB0.S=Chemin de classes de base de donn\u00e9es non valide : ''{0}''.
XCXC0.S=Liste d'ID non valide.
XCXE0.S=Vous essayez d'effectuer une op\u00e9ration qui utilise le territoire de la base de donn\u00e9es, mais cette derni\u00e8re ne poss\u00e8de pas encore de territoire.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# system errors.
# sqlstate range: XSTB0 to XSTBZ
XSTB0.M=Une exception a \u00e9t\u00e9 \u00e9mise au cours de l'abandon de la transaction.
XSTB2.M=Impossible de consigner les modifications de transaction ; il s'agit peut-\u00eatre d'une tentative d'\u00e9criture dans une base de donn\u00e9es en lecture seule.
XSTB3.M=Impossible d'abandonner la transaction parce que le gestionnaire des journaux est nul, probablement en raison d'une erreur ant\u00e9rieure.
XSTB5.M=Un incident inattendu s'est produit lors la cr\u00e9ation d'une base de donn\u00e9es pour laquelle la journalisation est d\u00e9sactiv\u00e9e.
XSTB6.M=Impossible de remplacer une table de transactions par une autre tant qu'une table est d\u00e9j\u00e0 en cours d'utilisation.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# transaction errors.
# sqlstate range: 40XD0 to 40XDZ
40XD0=Le conteneur a \u00e9t\u00e9 ferm\u00e9
40XD1=Le conteneur \u00e9tait ouvert en mode lecture seule
40XD2=Impossible d''ouvrir le conteneur {0} ; soit il a \u00e9t\u00e9 supprim\u00e9, soit il est inexistant


# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# statement errors.
# sqlstate range: XSDA0 to XSDAZ
XSDA1.S=Une tentative d'acc\u00e8s \u00e0 un emplacement situ\u00e9 en dehors des limites d'une page a \u00e9t\u00e9 effectu\u00e9e
XSDA2.S=Une tentative de mise \u00e0 jour d'un enregistrement supprim\u00e9 a \u00e9t\u00e9 effectu\u00e9e
XSDA3.S=Restriction : L'enregistrement ne peut pas \u00eatre mis \u00e0 jour ou ins\u00e9r\u00e9 en raison du manque d'espace sur la page. Utilisez les param\u00e8tres derby.storage.pageSize et/ou derby.storage.pageReservedSpace pour contourner cette restriction.
XSDA4.S=Une exception impr\u00e9vue a \u00e9t\u00e9 \u00e9mise
XSDA5.S=Une tentative d'annulation de la suppression d'un enregistrement non supprim\u00e9 a \u00e9t\u00e9 effectu\u00e9e.
XSDA6.S=La colonne {0} de la ligne a la valeur null alors qu''elle doit d\u00e9signer un objet.
XSDA7.S=La restauration d''un objet s\u00e9rialisable ou SQLData de classe {0} a tent\u00e9 de lire plus de donn\u00e9es que la quantit\u00e9 initialement enregistr\u00e9e
XSDA8.S=Exception au cours de la restauration d'un objet s\u00e9rialisable ou SQLData de classe {0}
XSDA9.S=Classe introuvable au cours de la restauration d''un objet s\u00e9rialisable ou SQLData de classe {0}
XSDAA.S=Horodatage {0} non valide ; il provient soit d''une page diff\u00e9rente, soit d''une impl\u00e9mentation incompatible
XSDAB.S=Impossible de d\u00e9finir un horodatage NULL
XSDAC.S=Tentative de d\u00e9placement de lignes ou de pages d'un conteneur \u00e0 un autre.
XSDAD.S=Tentative de d\u00e9placement de z\u00e9ro ligne d'une page vers une autre.
XSDAE.S=Il est uniquement possible de cr\u00e9er un descripteur d'enregistrement pour un ID de descripteur d'enregistrement sp\u00e9cial.
XSDAF.S=Utilisation d'un descripteur d'enregistrement sp\u00e9cial comme s'il s'agissait d'un descripteur d'enregistrement ordinaire.
XSDAG.S=La transaction sup\u00e9rieure imbriqu\u00e9e dans l'allocation ne peut pas ouvrir le conteneur.
XSDAI.S=La page {0} en cours de suppression est d\u00e9j\u00e0 verrouill\u00e9e pour une suppression d''affectation.
XSDAJ.S=Exception au cours de l'\u00e9criture d'un objet s\u00e9rialisable ou SQLData
XSDAK.S=La mauvaise page a \u00e9t\u00e9 extraite pour le descripteur d''enregistrement {0}.
XSDAL.S=Le descripteur d'enregistrement {0} pointe de fa\u00e7on inattendue vers la page de d\u00e9passement.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# database errors.
# sqlstate range: XSDB0 to XSDBZ
XSDB0.D=Exception inattendue sur la page en m\u00e9moire {0}
XSDB1.D=Format de page inconnu \u00e0 la page {0}
XSDB2.D=Format de conteneur inconnu au niveau du conteneur {0} : {1}
XSDB3.D=Les informations relatives au conteneur ne peuvent pas \u00eatre modifi\u00e9es une fois enregistr\u00e9es :  pr\u00e9c\u00e9demment {0}, d\u00e9sormais {1}
XSDB4.D=La page {0} est en version {1}, le fichier journal contient des modifications en version {2} ; soit des enregistrements de journal de cette page sont manquants, soit cette page n''a pas \u00e9t\u00e9 enregistr\u00e9e sur le disque correctement.
XSDB5.D=Le fichier journal comprend un enregistrement de modification \u00e0 la page {0}, c''est-\u00e0-dire au-del\u00e0 de la fin du conteneur.
XSDB6.D=Il est possible qu''une autre instance de Derby ait d\u00e9j\u00e0 amorc\u00e9 la base de donn\u00e9es {0}.
XSDB7.D=AVERTISSEMENT : Derby (instance {0}) tente d''amorcer la base de donn\u00e9es {1} bien que Derby (instance {2}) soit peut-\u00eatre encore actif.   Une seule instance de Derby peut amorcer une base de donn\u00e9es \u00e0 la fois. Une alt\u00e9ration grave et irr\u00e9m\u00e9diable peut r\u00e9sulter de cette situation et s''est peut-\u00eatre d\u00e9j\u00e0 produite.
XSDB8.D=AVERTISSEMENT : Derby (instance {0}) tente d''amorcer la base de donn\u00e9es {1} bien que Derby (instance {2}) soit peut-\u00eatre encore actif.   Une seule instance de Derby peut amorcer une base de donn\u00e9es \u00e0 la fois.  Une alt\u00e9ration grave et irr\u00e9m\u00e9diable peut r\u00e9sulter si 2 instances de Derby amorcent la m\u00eame base de donn\u00e9es en m\u00eame temps. La propri\u00e9t\u00e9 db2j.database.forceDatabaseLock=true a \u00e9t\u00e9 d\u00e9finie, de sorte que la base de donn\u00e9es ne s''amorcera pas tant que le fichier db.lck sera pr\u00e9sent.  Normalement, ce fichier est supprim\u00e9 lorsque la premi\u00e8re instance de Derby devant amorcer la base de donn\u00e9es est ferm\u00e9e, mais il est possible qu''il reste pr\u00e9sent suite \u00e0 certaines proc\u00e9dures d''arr\u00eat. Dans ce cas, il est n\u00e9cessaire de supprimer le fichier manuellement.  Il est important de v\u00e9rifier qu''aucune autre machine VM n''acc\u00e8de \u00e0 la base de donn\u00e9es tant que le fichier db.lck n''a pas \u00e9t\u00e9 supprim\u00e9 manuellement.
XSDB9.D=Le conteneur de flux {0} est alt\u00e9r\u00e9.
XSDBA.D=Echec de la tentative d''affectation de l'objet {0}.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/FileSystem
# statment errors.
# sqlstate range: XSDF0 to XSDFZ
XSDF0.S=Impossible de cr\u00e9er le fichier {0} car il existe d\u00e9j\u00e0.
XSDF1.S=Exception au cours de la cr\u00e9ation du fichier {0} pour le conteneur
XSDF2.S=Exception au cours de la cr\u00e9ation du fichier {0} pour le conteneur ; le fichier n''a pas pu \u00eatre supprim\u00e9.  Exception : {1}.
XSDF3.S=Impossible de cr\u00e9er le segment {0}.
XSDF4.S=Exception au cours de la suppression du fichier {0} pour le conteneur supprim\u00e9 ; le fichier n''a pas pu \u00eatre supprim\u00e9 {1}.
XSDF6.S=Impossible de trouver la page d''allocation {0}.
XSDF7.S=Echec de l''acc\u00e8s \u00e0 la page nouvellement cr\u00e9\u00e9e {0}
XSDF8.S=Impossible de trouver la page {0} \u00e0 r\u00e9utiliser.
XSDFB.S=Op\u00e9ration non prise en charge par une base de donn\u00e9es en lecture seule
XSDFD.S=Diff\u00e9rentes lectures d''image de page lors de 2 E/S \u00e0 la page {0} ; la premi\u00e8re image pr\u00e9sente un total de contr\u00f4le incorrect, la deuxi\u00e8me image pr\u00e9sente un total de contr\u00f4le correct. Les images de page sont les suivantes : {1} {2}
XSDFF.S=L'op\u00e9ration demand\u00e9e a \u00e9chou\u00e9 en raison d'une exception inattendue.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/FileSystem
# database errors.
# sqlstate range: XSDG0 to XSDGZ
XSDG0.D=Impossible de lire la page {0} \u00e0 partir du disque.
XSDG1.D=Impossible d''enregistrer la page {0} sur le disque. V\u00e9rifiez si le disque est satur\u00e9.
XSDG2.D=Total de contr\u00f4le non valide dans la page {0}, valeur pr\u00e9vue={1}, version sur disque={2}, vidage de la page : {3}
XSDG3.D=Impossible d''acc\u00e9der aux m\u00e9tadonn\u00e9es pour le conteneur {0}
XSDG5.D=La base de donn\u00e9es n'est pas en mode cr\u00e9ation lorsque createFinished est appel\u00e9.
XSDG6.D=Le r\u00e9pertoire du segment de donn\u00e9es n''a pas \u00e9t\u00e9 trouv\u00e9 dans la sauvegarde {0} pendant la restauration. Assurez-vous que la copie de sauvegarde est la bonne et qu''elle n''est pas alt\u00e9r\u00e9e.
XSDG7.D=Le r\u00e9pertoire {0} n''a pas pu \u00eatre supprim\u00e9 pendant la restauration. Assurez-vous que les droits d''acc\u00e8s sont corrects.
XSDG8.D=Impossible de copier le r\u00e9pertoire ''{0}'' dans ''{1}'' pendant la restauration. Assurez-vous que l''espace est suffisant et que les droits d''acc\u00e8s sont corrects. 

# language
01500=La contrainte {0} sur la table {1} a \u00e9t\u00e9 supprim\u00e9e.
01501=La vue {0} a \u00e9t\u00e9 supprim\u00e9e.
01502=Le d\u00e9clencheur {0} sur la table {1} a \u00e9t\u00e9 supprim\u00e9.
01503=La colonne {0} de la table {1} a \u00e9t\u00e9 modifi\u00e9e par ajout d''une contrainte non nulle.
01504=Le nouvel index est un double d''un index existant : {0}.
01505=La valeur {0} est peut-\u00eatre tronqu\u00e9e.
01003=Les valeurs null ont \u00e9t\u00e9 \u00e9limin\u00e9es de l'argument d'une fonction de colonne.
0100E=XX a tent\u00e9 de renvoyer un trop grand nombre d'ensembles de r\u00e9sultats.
02000=Aucune ligne n'a \u00e9t\u00e9 trouv\u00e9e pour FETCH, UPDATE ou DELETE ou le r\u00e9sultat d'une requ\u00eate est une table vide.
21000=Une sous-requ\u00eate scalaire n'est autoris\u00e9e que pour renvoyer une seule ligne.
22001=Une erreur de troncature a \u00e9t\u00e9 d\u00e9tect\u00e9e lors de la tentative de r\u00e9duction de {0} ''{1}'' \u00e0 une longueur de {2}.
54006=La longueur r\u00e9sultant de l''op\u00e9ration {0} est sup\u00e9rieure \u00e0 {1}.
22003=La valeur r\u00e9sultante se situe hors de la fourchette admise pour le type de donn\u00e9es {0}.
22005=Une tentative d''extraction d''une valeur de donn\u00e9es de type ''{0}'' \u00e0 partir d''une valeur de donn\u00e9es de type ''{1}'' a \u00e9t\u00e9 effectu\u00e9e.
22007.S.180=La repr\u00e9sentation de la cha\u00eene d'une valeur date/heure se situe hors de la fourchette admise.
22007.S.181=La syntaxe de la repr\u00e9sentation de la cha\u00eene d'une valeur date/heure n'est pas correcte.
22011=Le deuxi\u00e8me ou troisi\u00e8me argument de la fonction SUBSTR se situe hors de la fourchette admise.
22012=Tentative de division par z\u00e9ro.
22013=Tentative d''extraction de la racine carr\u00e9e d''un nombre n\u00e9gatif, ''{0}''.
22014=La position de d\u00e9but pour LOCATE est incorrecte ; cette valeur doit \u00eatre un entier positif.  L''index \u00e0 partir duquel la recherche doit commencer est ''{2}''.  La cha\u00eene \u00e0 rechercher est ''{0}''.  La cha\u00eene \u00e0 partir de laquelle la recherche doit commencer est ''{1}''. 
22015=La fonction ''{0}'' n''est pas autoris\u00e9e sur l''ensemble de types suivant.  Le premier op\u00e9rande est de type ''{1}''.  Le deuxi\u00e8me op\u00e9rande est de type ''{2}''.  Le troisi\u00e8me op\u00e9rande (position de d\u00e9but) est de type ''{3}''.
22018=Le format de la cha\u00eene de caract\u00e8res n''est pas valide pour le type {0}.
22019=La s\u00e9quence d''\u00e9chappement ''{0}'' n''est pas valide. Cette cha\u00eene doit comporter un seul caract\u00e8re. Elle ne doit pas avoir la valeur null ni comporter plusieurs caract\u00e8res.
22025=Le caract\u00e8re d'\u00e9chappement doit \u00eatre suivi d'un caract\u00e8re d'\u00e9chappement, '_' ou '%'. Il ne peut \u00eatre suivi d'aucun autre caract\u00e8re, ni se trouver \u00e0 la fin du masque.
22027=La fonction TRIM() int\u00e9gr\u00e9e ne prend en charge qu'un seul caract\u00e8re d'enl\u00e8vement des espaces de d\u00e9but et de fin.  Les fonctions int\u00e9gr\u00e9es LTRIM() et RTRIM() prennent en charge plusieurs caract\u00e8res d'enl\u00e8vement des espaces de d\u00e9but et de fin.
22500=Impossible d'utiliser des param\u00e8tres ? \u00e0 la fois pour le masque LIKE et pour la clause ESCAPE.
22501=Une clause ESCAPE ayant pour valeur NULL renvoie des r\u00e9sultats non d\u00e9finis et n'est pas autoris\u00e9e.
23502=La colonne ''{0}''  ne peut pas accepter de valeur NULL.
23505=L''instruction a \u00e9t\u00e9 abandonn\u00e9e parce qu''elle aurait entra\u00een\u00e9 la duplication d''une valeur de cl\u00e9 dans une contrainte de cl\u00e9 ou d''index unique identifi\u00e9 par ''{0}'' d\u00e9finie sur ''{1}''.
23503={2} sur la table ''{1}'' a entra\u00een\u00e9 la violation de la contrainte de cl\u00e9 externe ''{0}'' pour la cl\u00e9 {3}.  L''instruction a \u00e9t\u00e9 annul\u00e9e.
23513=La contrainte de v\u00e9rification ''{1}'' a \u00e9t\u00e9 viol\u00e9e au cours de l''ex\u00e9cution d''une op\u00e9ration INSERT ou UPDATE sur la table ''{0}''.
38000=L''exception ''{0}'' a \u00e9t\u00e9 \u00e9mise au cours de l''\u00e9valuation d''une expression.
38001=La routine externe n'est pas autoris\u00e9e \u00e0 ex\u00e9cuter des instructions SQL.
38002=La routine a tent\u00e9 de modifier des donn\u00e9es, cependant elle n'a pas \u00e9t\u00e9 d\u00e9finie en ce sens (MODIFIES SQL DATA).
38004=La routine a tent\u00e9 de lire des donn\u00e9es, cependant elle n'a pas \u00e9t\u00e9 d\u00e9finie en ce sens (READS SQL DATA).
39004=Une valeur NULL ne peut pas \u00eatre transmise \u00e0 une m\u00e9thode qui accepte un param\u00e8tre de type primitif ''{0}''.
40XC0=Instruction supprim\u00e9e. Cela peut r\u00e9sulter de l'interception d'une erreur de gravit\u00e9 concernant la transaction dans cette instruction.
# this error is retired in 1.3
42000=Erreur de syntaxe ou violation des r\u00e8gles d'acc\u00e8s ; pour plus de d\u00e9tails, voir les autres erreurs.

# DB2 error for max length violation by char, varchar and long varchar. In future, this error message will be used for other purposes too
42601=Dans une instruction ALTER TABLE, la colonne ''{0}'' a \u00e9t\u00e9 d\u00e9finie par la valeur NOT NULL et la clause DEFAULT n''a pas \u00e9t\u00e9 sp\u00e9cifi\u00e9e ou a \u00e9t\u00e9 sp\u00e9cifi\u00e9e comme DEFAULT NULL.
42601.S.372=L''instruction ALTER TABLE ne peut pas ajouter de colonne d''identit\u00e9 (IDENTITY) \u00e0 la table. 
42606=Une constante hexad\u00e9cimale non valide commen\u00e7ant par ''{0}'' a \u00e9t\u00e9 d\u00e9tect\u00e9e.
54002=Une constante de cha\u00eene commen\u00e7ant par ''{0}'' est trop longue.
42611=L''attribut de longueur, de pr\u00e9cision ou d''\u00e9chelle de la colonne, ou le mappage de type ''{0}'' n''est pas valide. 

42605=Le nombre d''arguments pour la fonction ''{0}'' est incorrect.
42610=Les arguments de la fonction COALESC/VALUE ne peuvent pas tous \u00eatre des param\u00e8tres. Vous devez sp\u00e9cifier au moins un argument autre qu'un param\u00e8tre.

42613=Pr\u00e9sence de mots cl\u00e9s multiples ou incompatibles impliquant la clause ''{0}''.
42621=Une contrainte de v\u00e9rification ou une colonne g\u00e9n\u00e9r\u00e9e d\u00e9finie par ''{0}'' n''est pas valide.
42734=Le nom ''{0}'' sp\u00e9cifi\u00e9 dans le contexte ''{1}'' n''est pas unique.
# DB2 error for invalid set schema
42802=Le nombre de valeurs attribu\u00e9es n'est pas le m\u00eame que le nombre de colonnes sp\u00e9cifi\u00e9es ou implicites.
42815.S.713=La valeur de remplacement d\u00e9finie pour ''{0}'' n''est pas valide.
42815.S.171=Les types de donn\u00e9es, les longueurs ou les valeurs des arguments ''{0}'' et ''{1}'' sont incompatibles.
42820=Le litt\u00e9ral \u00e0 virgule flottante ''{0}'' contient plus de 30 caract\u00e8res.
42824=Un op\u00e9rande de LIKE n'est pas une cha\u00eene ou le premier op\u00e9rande n'est pas une colonne.
42831=''{0}'' ne peut pas \u00eatre une colonne de cl\u00e9 primaire ou unique car elle peut contenir des valeurs ''null''.
42834=SET NULL ne peut \u00eatre indiqu\u00e9 car la CLE EXTERNE ''{0}'' ne peut pas contenir de valeurs nulles.  
42884=Une routine non autoris\u00e9e, nomm\u00e9e ''{0}'', de type ''{1}'' et comportant des arguments compatibles a \u00e9t\u00e9 trouv\u00e9e.
42886=''{0}'' param\u00e8tre ''{1}'' requiert un marqueur de param\u00e8tre ''?''.
42894=La valeur DEFAULT ou l''attribut IDENTITY n''est pas valide pour la colonne ''{0}''.
428C1=Seule une colonne d''identit\u00e9 est admise dans une table.
42903=Utilisation non valide d'une fonction d'agr\u00e9gat.
42908=L'instruction CREATE VIEW n'inclut pas de liste de colonnes.
42915=La cl\u00e9 externe ''{0}'' n''est pas valide car ''{1}''. 
42972=Une clause ON associ\u00e9e \u00e0 un op\u00e9rateur JOIN n'est pas valide.
42X01=Erreur de syntaxe : {0}.
42X02={0}.
42X03=Le nom de colonne ''{0}'' se trouve dans plusieurs tables de la liste FROM.
42X04=La colonne ''{0}'' ne se trouve dans aucune table de la liste FROM ou elle figure dans une sp\u00e9cification de jointure et se trouve en dehors de la port\u00e9e de cette sp\u00e9cification ou elle figure dans une clause HAVING mais ne se trouve pas dans la liste GROUP BY.  S''il s''agit d''une instruction CREATE ou ALTER TABLE, alors ''{0}'' n''est pas une colonne de la table cible.
42X05=La table ''{0}'' n''existe pas.
42X06=Trop grand nombre de colonnes de r\u00e9sultats sp\u00e9cifi\u00e9 pour la table ''{0}''.
42X07=La valeur NULL est uniquement autoris\u00e9e dans une clause VALUES \u00e0 l'int\u00e9rieur d'une instruction INSERT.
42X08=Le constructeur de la classe ''{0}'' ne peut pas \u00eatre utilis\u00e9 en tant que table virtuelle externe \u00e9tant donn\u00e9 que la classe n''impl\u00e9mente pas ''{1}''
42X09=Le nom de table ou d''alias ''{0}'' est utilis\u00e9 plusieurs fois dans la liste FROM.
42X10=''{0}'' n''est pas un nom de table expos\u00e9 dans la port\u00e9e o\u00f9 il figure.
42622=Le nom ''{0}'' est trop long. La longueur maximale admise est ''{1}''.
42X12=Le nom de colonne ''{0}'' figure plusieurs fois dans l''instruction de cr\u00e9ation de table.
54011=Trop de colonnes ({0}) ont \u00e9t\u00e9 sp\u00e9cifi\u00e9es pour la table ou la vue {1}. La limite est {2}.
42Z9F=Trop d'index ({0}) pour la table {1}. La limite est {2}.
42X13=Le nom de colonne ''{0}'' figure plusieurs fois dans la liste des colonnes d''une instruction d''insertion.
42X14=''{0}'' n''est pas une colonne de la table ou du VTI ''{1}''.
42X15=Le nom de colonne ''{0}'' figure dans une instruction ne contenant pas de liste FROM.
42X16=Le nom de colonne ''{0}'' figure plusieurs fois dans la clause SET d''une instruction de mise \u00e0 jour.
42X17=La valeur ''{0}'' n''est pas valide en tant que sp\u00e9cification joinOrder dans la liste Propri\u00e9t\u00e9s d'une clause FROM. Seules les valeurs FIXED et UNFIXED sont valides.
42803=Une expression contenant la colonne ''{0}'' appara\u00eet dans la liste SELECT et ne fait pas partie d''une clause GROUP BY.
42818=Les comparaisons entre ''{0}'' et ''{1}'' ne sont pas prises en charge.
42X19=La clause WHERE ou HAVING ou la d\u00e9finition CHECK CONSTRAINT est une expression ''{0}''.  Il faut que ce soit une expression BOOLEENNE.
42X23=Le curseur {0} ne peut pas \u00eatre mis \u00e0 jour.
#42X24=The unary ''-'' operator is not allowed on the ''{0}'' type.
42X25=La fonction ''{0}'' n''est pas autoris\u00e9e sur le type ''{1}''.
42X26=La classe ''{0}'' pour la colonne ''{1}'' n''existe pas ou n''est pas accessible. Cela peut se produire si la classe n''est pas publique.
42X28=La table de suppression ''{0}'' n''est pas la cible du curseur ''{1}''.
42X29=La table de mise \u00e0 jour ''{0}'' n''est pas la cible du curseur ''{1}''.
42X30=Le curseur ''{0}'' est introuvable. V\u00e9rifiez que la fonction de validation automatique est d\u00e9sactiv\u00e9e (OFF).
42X31=La colonne ''{0}'' ne figure pas dans la liste FOR UPDATE du curseur ''{1}''.
42X32=Le nombre de colonnes de la liste de colonnes d\u00e9riv\u00e9es doit correspondre au nombre de colonnes de la table ''{0}''.
42X33=La liste de colonnes d\u00e9riv\u00e9es contient un nom de colonne en double ''{0}''.
42X34=La liste de s\u00e9lection contient un param\u00e8tre ?.  Ce param\u00e8tre n'est pas admis.
42X35=Il n''est pas admis que les deux op\u00e9randes de ''{0}'' soient des param\u00e8tres ?.
42X36=L''op\u00e9rateur ''{0}'' ne peut pas utiliser un param\u00e8tre ? en tant qu''op\u00e9rande.
42X37=L''op\u00e9rateur unaire ''{0}'' n''est pas autoris\u00e9 sur le type ''{1}''.
42X38=''SELECT *'' est uniquement autoris\u00e9 dans les sous-requ\u00eates EXISTS et NOT EXISTS.
42X39=La sous-requ\u00eate est uniquement autoris\u00e9e \u00e0 renvoyer une seule colonne.
42X40=Un NOT poss\u00e8de un op\u00e9rande non bool\u00e9en. L'op\u00e9rande de NOT doit avoir pour r\u00e9sultat TRUE, FALSE ou UNKNOWN.
42X41=La propri\u00e9t\u00e9 ''{0}'' n''est pas valide dans la clause Propri\u00e9t\u00e9s d'une liste FROM (la propri\u00e9t\u00e9 \u00e9tait d\u00e9finie \u00e0 ''{1}'').
42821=Les colonnes de type ''{0}'' ne peuvent pas contenir de valeurs de type ''{1}''. 
42X43=Le ResultSetMetaData renvoy\u00e9 pour la classe/objet ''{0}'' \u00e9tait NULL. Le ResultSetMetaData doit \u00eatre non nul pour que cette classe puisse \u00eatre utilis\u00e9e en tant que table virtuelle externe.
42X44=Longueur incorrecte ''{0}'' dans la sp\u00e9cification de colonne.
# 42X45=
# 42X46=
# 42X47=
42X48=La valeur ''{1}'' n''est pas une pr\u00e9cision correcte pour {0}.
42X49=La valeur ''{0}'' n''est pas un litt\u00e9ral entier valide.
42X50=Aucune m\u00e9thode pouvant correspondre \u00e0 l''appel de m\u00e9thode{0}.{1}({2}) n''a \u00e9t\u00e9 trouv\u00e9e ; toutes les combinaisons de types d''objet et de types primitifs, ainsi que toute conversion de type possible pour tous les param\u00e8tres que l''appel de m\u00e9thode pourrait contenir ont m\u00eame \u00e9t\u00e9 essay\u00e9s.  Il est possible que la m\u00e9thode existe, mais qu''elle ne soit pas publique et/ou pas statique, ou que les types de param\u00e8tres ne puissent pas \u00eatre convertis en appel de m\u00e9thode.
42X51=La classe ''{0}'' n''existe pas ou est inaccessible. Cela peut se produire si la classe n''est pas publique.
42X52=L'appel de la m\u00e9thode (''{0}'') \u00e0 l'aide d''un r\u00e9cepteur de type primitif Java ''{1}'' n''est pas autoris\u00e9.
42X53=Le pr\u00e9dicat LIKE peut uniquement avoir les op\u00e9randes ''CHAR'' ou ''VARCHAR''. Le type ''{0}'' n''est pas admis.
42X54=La m\u00e9thode Java ''{0}'' utilise un ? en tant que r\u00e9cepteur.  Ce caract\u00e8re n''est pas admis.
42X55=Le nom de table ''{1}'' doit \u00eatre le m\u00eame que ''{0}''.
42X56=Le nombre de colonnes de la liste des colonnes de vue doit correspondre au nombre de colonnes de l''expression de requ\u00eate sous-jacente dans la d\u00e9finition de vue pour ''{0}''.
42X57=La m\u00e9thode getColumnCount() pour la table virtuelle externe ''{0}'' a renvoy\u00e9 une valeur non valide ''{1}''.  Les valeurs valides sont >= 1.
42X58=Le nombre de colonnes situ\u00e9es \u00e0 gauche et \u00e0 droite de l'UNION doit \u00eatre le m\u00eame.
42X59=Le nombre de colonnes de chaque constructeur VALUES doit \u00eatre le m\u00eame.
42X60=Valeur non valide ''{0}'' pour la propri\u00e9t\u00e9 insertMode sp\u00e9cifi\u00e9e pour la table ''{1}''.
42X61=Les types ''{0}'' et ''{1}'' ne sont pas compatibles avec l''op\u00e9ration UNION.
42X62=''{0}'' n''est pas autoris\u00e9 dans le sch\u00e9ma ''{1}''.
42X63=La clause USING n'a pas renvoy\u00e9 de r\u00e9sultats ; aucun param\u00e8tre ne peut \u00eatre d\u00e9fini.
42X64=Valeur non valide ''{0}'' sp\u00e9cifi\u00e9e pour la propri\u00e9t\u00e9 useStatistics dans la liste Propri\u00e9t\u00e9s. TRUE ou FALSE sont les seules valeurs admises.
42X65=L''index ''{0}'' n''existe pas.
42X66=Le nom de colonne ''{0}'' figure plusieurs fois dans l''instruction de cr\u00e9ation d''index.
42X68=Aucune zone ''{0}'' appartenant \u00e0 la classe ''{1}'' n''a \u00e9t\u00e9 trouv\u00e9e.  Il est possible que cette zone existe, mais qu''elle ne soit pas publique, ou que la classe n''existe pas ou qu''elle ne soit pas publique.
42X69=Il n''est pas permis de r\u00e9f\u00e9rencer une zone (''{0}'') \u00e0 l''aide d''une expression de r\u00e9f\u00e9rencement du type primitif Java ''{1}''.
42X72=Aucune zone statique ''{0}'' appartenant \u00e0 la classe ''{1}'' n''a \u00e9t\u00e9 trouv\u00e9e.  Il est possible que cette zone existe, mais qu''elle ne soit pas publique et/ou pas statique, ou que la classe n''existe pas ou qu''elle ne soit pas publique.
42X73=La r\u00e9solution de m\u00e9thode pour la signature {0}.{1}({2}) \u00e9tait ambigu\u00eb. (Plus d''une m\u00e9thode correspondait \u00e0 la requ\u00eate.)
42X74=Syntaxe de l'instruction CALL incorrecte.
42X75=Aucun constructeur ayant la signature {0}({1}) n''a \u00e9t\u00e9 trouv\u00e9.  Il est possible que les types de param\u00e8tres ne puissent pas \u00eatre convertis en appel de m\u00e9thode.
42X76=Une colonne au moins, ''{0}'', de la cl\u00e9 primaire ajout\u00e9e peut avoir une valeur null. Aucune colonne d''une cl\u00e9 primaire ne peut avoir une valeur nulle.
42X77=La position de la colonne ''{0}'' est en dehors des limites pour l''expression de requ\u00eate.
42X78=La colonne ''{0}'' ne figure pas dans le r\u00e9sultat de l''expression de requ\u00eate.
42X79=Le nom de colonne ''{0}'' figure plusieurs fois dans le r\u00e9sultat de l''expression de requ\u00eate.
42877=Un nom de colonne complet ''{0}'' n''est pas admis dans la clause ORDER BY.
42X80=La clause VALUES doit contenir au moins 1 \u00e9l\u00e9ment et tous les \u00e9l\u00e9ments doivent \u00eatre non vides.
42X82=La clause USING a renvoy\u00e9 plusieurs lignes ; seuls les ResultSets d''une seule ligne sont autoris\u00e9s.
42X83=Les contraintes s''appliquant \u00e0 la colonne ''{0}'' n\u00e9cessitent que celle-ci soit \u00e0 la fois autoris\u00e9e et non autoris\u00e9e \u00e0 contenir des valeurs nulles.
42X84=L''index ''{0}'' a \u00e9t\u00e9 cr\u00e9\u00e9 pour appliquer la contrainte ''{1}''.  Il ne peut \u00eatre supprim\u00e9 que par la suppression de la contrainte.
42X85=La contrainte ''{0}'' doit obligatoirement se trouver dans le m\u00eame sch\u00e9ma que la table ''{1}''.
42X86=Echec de l''op\u00e9ration ALTER sur la table. Aucune contrainte ''{0}'' ne s''applique \u00e0 la table ''{1}''.
42X87=Au moins une expression de r\u00e9sultat (then ou else) de l''expression ''{0}'' ne doit pas \u00eatre un ''?''.
42X88=Un Conditional poss\u00e8de un op\u00e9rande non bool\u00e9en. L'op\u00e9rande de Conditional doit avoir pour r\u00e9sultat TRUE, FALSE ou UNKNOWN.
42X89=Les types ''{0}'' et ''{1}'' ne sont pas compatibles. (Aucun de ces deux types ne peut \u00eatre affect\u00e9 \u00e0 l''autre.)
42X90=Plus d''1 contrainte de cl\u00e9 primaire est sp\u00e9cifi\u00e9e pour la table ''{0}''.
42X91=Le nom de contrainte ''{0}'' figure plusieurs fois dans l''instruction de cr\u00e9ation de table.
42X92=Le nom de colonne ''{0}'' figure plusieurs fois dans la liste de colonnes d''une contrainte.
42X93=La table ''{0}'' contient une d\u00e9finition de contrainte avec la colonne ''{1}'', laquelle ne se trouve pas dans la table.
42Z93=Les contraintes ''{0}'' et ''{1}'' poss\u00e8dent le m\u00eame ensemble de colonnes, ce qui n''est pas autoris\u00e9.
42Z96=Les VTI en lecture-\u00e9criture ne sont pas pris en charge dans les environnements JDK 1.1/JDBC 1.2 : ''{0}''
42Z9B=L''interface VTI (Virtual Table Interface) externe ne prend pas en charge les colonnes Blob ou Clob. ''{0}'' colonne ''{1}''.
42Z9D=Les instructions ''{0}'' ne sont pas admises dans les d\u00e9clencheurs ''{1}''.
42Z9E=La contrainte ''{0}'' n''est pas une contrainte {1}.
42X94={0} ''{1}'' n''existe pas.
42X96=Le chemin d''acc\u00e8s aux classes de la base de donn\u00e9es contient un fichier jar inconnu ''{0}''.
42X98=Les param\u00e8tres ne sont pas autoris\u00e9s dans une d\u00e9finition VIEW.
42Y00=La classe ''{0}'' n''impl\u00e9mente pas org.apache.derby.iapi.db.AggregateDefinition et par cons\u00e9quent ne peut pas \u00eatre utilis\u00e9e en tant qu''expression d''agr\u00e9gat.
42Y01=La contrainte ''{0}'' n''est pas valide.
42Y03=''{0}'' n''est pas reconnu en tant que fonction ou proc\u00e9dure.

# EXTERNAL NAME is SQL keyword - do not translate
42Y04=Impossible de cr\u00e9er une proc\u00e9dure ou une fonction dont le NOM EXTERNE est ''{0}'' car il ne s''agit pas d''une liste dont les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par un point. Le format attendu est <chemin d''acc\u00e8s java complet>.<nom de m\u00e9thode> .

42Y05=Aucune cl\u00e9 externe n''a pour nom ''{0}''.
42Y07=Le sch\u00e9ma ''{0}'' n''existe pas.
42Y08=Les contraintes de cl\u00e9 externe ne sont pas autoris\u00e9es sur les tables syst\u00e8me.
42Y09=Les m\u00e9thodes void sont uniquement autoris\u00e9es dans une instruction CALL.
42Y10=Un constructeur de table qui ne se trouve pas dans une instruction INSERT contient tous les param\u00e8tres ? dans l'une de ses colonnes.  Pour chaque colonne, au moins l'une des lignes doit contenir un non-param\u00e8tre.
42Y11=Une sp\u00e9cification de jointure est requise avec la clause ''{0}''.
42Y12=La clause ON d''un JOIN est une expression ''{0}''.  Il faut que ce soit une expression BOOLEENNE.
42Y13=Le nom de colonne ''{0}'' figure plusieurs fois dans l''instruction de cr\u00e9ation de vue.
42Z97=Le changement de nom de la colonne ''{0}'' entra\u00eenera la rupture de la contrainte de v\u00e9rification ''{1}''.
42Z99=Une cha\u00eene ou un litt\u00e9ral hex ne peut pas d\u00e9passer 64 Ko.
42Y16=Aucune m\u00e9thode statique publique ''{0}'' n''a \u00e9t\u00e9 trouv\u00e9e dans la classe ''{1}''.  Il est possible que la m\u00e9thode existe, mais qu''elle ne soit pas publique, ou qu''elle ne soit pas statique.
42846=Impossible de convertir les types ''{0}'' en ''{1}''.
42Y19=''{0}'' figure plusieurs fois dans la liste GROUP BY. Les colonnes de la liste GROUP BY doivent \u00eatre non ambigu\u00ebs.
42Y22=L''agr\u00e9gat {0} ne peut pas fonctionner sur le type {1}.
42Y23=Informations sur le type JDBC incorrectes renvoy\u00e9es pour la colonne {0}.
42Y24=La vue ''{0}'' ne peut pas \u00eatre mise \u00e0  jour. (Les vues ne peuvent pas \u00eatre mises \u00e0 jour actuellement.)
42Y25=''{0}'' est une table syst\u00e8me.  Les utilisateurs ne sont pas autoris\u00e9s \u00e0 modifier le contenu de cette table.
#42Y26=Parameters are not allowed in the WHEN clause of a trigger.
42Y27=Les param\u00e8tres ne sont pas autoris\u00e9s dans l'action du d\u00e9clencheur.
42Y29=La liste SELECT d'une requ\u00eate non group\u00e9e contient au moins 1 expression non valide.   Lorsque la liste SELECT contient au moins 1 agr\u00e9gat, toutes les entr\u00e9es doivent \u00eatre des expressions d'agr\u00e9gat valides.
42Y30=La liste SELECT d'une requ\u00eate group\u00e9e contient au moins 1 expression non valide.   Pour un SELECT associ\u00e9 \u00e0 un GROUP BY, la liste SELECT ne peut contenir que des colonnes de regroupement et des expressions d'agr\u00e9gat valides.
42Y32=La classe d''agr\u00e9gateur ''{0}'' pour l''agr\u00e9gat ''{1}'' sur le type {2} n''impl\u00e9mente pas com.ibm.db2j.aggregates.Aggregator. 
42Y33=L''agr\u00e9gat {0} contient un ou plusieurs agr\u00e9gats.
42Y34=Le nom de colonne ''{0}'' correspond \u00e0 plusieurs colonnes de r\u00e9sultats dans la table ''{1}''.
42Y35=La r\u00e9f\u00e9rence de colonne ''{0}'' est incorrecte. Lorsque la liste SELECT contient au moins 1 agr\u00e9gat, toutes les entr\u00e9es doivent \u00eatre des expressions d''agr\u00e9gat valides.
42Y36=La r\u00e9f\u00e9rence de colonne ''{0}'' est incorrecte.  Pour un SELECT associ\u00e9 \u00e0 un GROUP BY, la liste SELECT ne peut contenir que des colonnes de regroupement et des expressions d''agr\u00e9gat valides.
42Y37=''{0}'' est de type Java primitif et ne peut pas \u00eatre utilis\u00e9 avec cet op\u00e9rateur.
42Y38=insertMode = replace n''est pas autoris\u00e9 sur une insertion lorsque la table cible, ''{0}'', est r\u00e9f\u00e9renc\u00e9e dans le SELECT.
# NOTE: The parameter to this message is a keyword used as a noun phrase.
# Some possible values are "subquery", "CurrentDate", and "?".
42Y39=''{0}'' ne peut pas figurer dans une d\u00e9finition CHECK CONSTRAINT car il pourrait renvoyer des r\u00e9sultats non d\u00e9terministes.
42Y40=''{0}'' figure plusieurs fois dans la liste de colonnes UPDATE OF pour le d\u00e9clencheur ''{1}''.
42Y41=''{0}'' ne peut pas \u00eatre appel\u00e9 directement via EXECUTE STATEMENT parce qu''il fait partie d''un d\u00e9clencheur.
42Y42=L'\u00e9chelle ''{1}'' n''est pas une \u00e9chelle admise pour un {0}.
42Y43=L'\u00e9chelle ''{1}'' n''est pas une \u00e9chelle valide avec une pr\u00e9cision de {0}.
42Y44=Une cl\u00e9 non valide, ''{0}'', est sp\u00e9cifi\u00e9e dans la liste Propri\u00e9t\u00e9s de la liste FROM. Les cl\u00e9s ne prenant pas en compte la diff\u00e9rence majuscules/minuscules prises en charge actuellement sont ''{1}''.
42Y45=Le VTI ''{0}'' ne peut pas \u00eatre li\u00e9 parce qu''il s''agit d''un VTI de d\u00e9clencheur sp\u00e9cial et que cette instruction ne fait pas partie d''une action de d\u00e9clencheur ou d''une clause WHEN.
42Y46=Liste Propri\u00e9t\u00e9s non valide dans la liste FROM.  Aucun index ''{0}'' dans la table ''{1}''.
42Y48=Liste Propri\u00e9t\u00e9s non valide dans la liste FROM.  Soit aucune contrainte nomm\u00e9e ''{0}'' ne s''applique \u00e0 la table ''{1}'', soit la contrainte ne poss\u00e8de pas d''index de secours.
42Y49=Plusieurs valeurs sont sp\u00e9cifi\u00e9es pour la cl\u00e9 de propri\u00e9t\u00e9 ''{0}''. 
42Y50=La liste Propri\u00e9t\u00e9s pour la table ''{0}'' peut contenir des valeurs pour l''index ou pour la contrainte, mais pas pour les deux.
42Y55=''{0}'' ne peut pas \u00eatre ex\u00e9cut\u00e9 sur ''{1}'' parce qu''il n''existe pas.
42Y56=joinStrategy non valide, ''{0}'', sp\u00e9cifi\u00e9e dans la liste Propri\u00e9t\u00e9s de la table ''{1}''. Les valeurs actuellement prises en charge pour joinStrategy sont ''hash'', ''nestedloop''.
42Y58=L''exception NumberFormatException s''est produite lors de la conversion de la valeur ''{0}'' pour l''\u00e9l\u00e9ment de substitution d''optimiseur ''{1}''.
42Y59=Valeur non valide, ''{0}'', sp\u00e9cifi\u00e9e pour l''\u00e9l\u00e9ment de substitution de hashInitialCapacity. La valeur doit \u00eatre > 0.
42Y60=Valeur non valide, ''{0}'', sp\u00e9cifi\u00e9e pour l''\u00e9l\u00e9ment de substitution de hashLoadFactor. La valeur doit \u00eatre > 0.0 et <= 1.0.
42Y61=Valeur non valide, ''{0}'', sp\u00e9cifi\u00e9e pour l''\u00e9l\u00e9ment de substitution de hashMaxCapacity. La valeur doit \u00eatre > 0.
42Y62=''{0}'' n''est pas autoris\u00e9 sur ''{1}'' parce qu''il s''agit d''une vue.
42Y63=Une jointure par hachage n\u00e9cessite un pr\u00e9dicat equijoin optimisable sur une colonne dans l''index ou le segment de m\u00e9moire s\u00e9lectionn\u00e9.  Un pr\u00e9dicat equijoin optimisable n''existe dans aucune colonne de la table ou de l''index ''{0}''. Utilisez l''\u00e9l\u00e9ment de substitution d''optimiseur ''index'' pour sp\u00e9cifier cet index ou ce segment de m\u00e9moire sur la table ''{1}''.
42Y64=La valeur bulkFetch de ''{0}'' n''est pas valide : la valeur minimale pour bulkFetch est 1.
42Y65=bulkFetch n''est pas autoris\u00e9 sur les jointures ''{0}''.
42Y66=bulkFetch n'est pas autoris\u00e9 sur les curseurs pouvant \u00eatre mis \u00e0 jour.
42Y67=Le sch\u00e9ma ''{0}'' ne peut pas \u00eatre supprim\u00e9.
42Y69=Aucun plan d'ex\u00e9cution valide n'a \u00e9t\u00e9 trouv\u00e9 pour cette instruction. Cela peut s'expliquer de l'une des deux fa\u00e7ons suivantes : soit vous avez sp\u00e9cifi\u00e9 une strat\u00e9gie de jointure par hachage alors que les jointures par hachage ne sont pas autoris\u00e9es (pas d'equijoin optimisable), soit vous essayez de joindre deux ExternalVirtualTables dont chacune fait r\u00e9f\u00e9rence \u00e0 l'autre, de sorte que l'instruction ne peut pas \u00eatre \u00e9valu\u00e9e.
42Y70=L'ordre de jointure sp\u00e9cifi\u00e9 par l'utilisateur n'est pas valide. Cela peut \u00eatre d\u00fb au fait qu'une colonne de jointure d'une table interne est transmise en tant que param\u00e8tre \u00e0 une table virtuelle externe.
42Y71=La proc\u00e9dure ou la fonction syst\u00e8me ''{0}'' ne peut pas \u00eatre supprim\u00e9e.
42Y82=L''instruction pr\u00e9par\u00e9e stock\u00e9e g\u00e9n\u00e9r\u00e9e par le syst\u00e8me ''{0}'' ne peut pas \u00eatre supprim\u00e9e \u00e0 l''aide de DROP STATEMENT.  Elle fait partie d''un d\u00e9clencheur.
42Y83=Une valeur NULL non typ\u00e9e n''est pas autoris\u00e9e en tant qu''argument pour l''agr\u00e9gat {0}.  Affectez la valeur NULL \u00e0 un type appropri\u00e9.
# NOTE: The parameter to this message is a keyword used as a noun phrase.
# Some possible values are "subquery", "CurrentDate", and "?".
42Y84=''{0}'' ne peut pas figurer dans une d\u00e9finition DEFAULT.
42Y85=Le mot cl\u00e9 DEFAULT n'est pas autoris\u00e9 dans une clause VALUES lorsque cette clause figure dans une instruction INSERT.
42Y90=FOR UPDATE n'est pas autoris\u00e9 sur ce type d'instruction.
42Y91=La clause USING n'est pas autoris\u00e9e dans un EXECUTE STATEMENT pour une action de d\u00e9clencheur.
42Y92=Les d\u00e9clencheurs {0} peuvent uniquement faire r\u00e9f\u00e9rence aux variables/tables de transition {1}.
42Y93=Clause REFERENCING incorrecte : un seul nom est autoris\u00e9 pour chaque type de variable/table de transition.
42Y94=Un AND ou OR poss\u00e8de un op\u00e9rande non bool\u00e9en. Les op\u00e9randes de AND et OR doivent avoir pour r\u00e9sultat TRUE, FALSE ou UNKNOWN.
42Y95=L''op\u00e9rateur ''{0}'' ayant comme type d''op\u00e9rande de gauche ''{1}'' et comme type d''op\u00e9rande de droite ''{2}'' n''est pas pris en charge.
42Y96.U=UNKNOWN
42Y97=Caract\u00e8re d''\u00e9chappement non valide \u00e0 la ligne ''{0}'', colonne ''{1}''.
42Y98.U="{0}" d\u00e9tect\u00e9 \u00e0 la ligne {1}, colonne {2}
42Y99.U=Erreur lexicale \u00e0 la ligne {0}, colonne {1}. Exception rencontr\u00e9e : {2}
42Z00.U=Appel de m\u00e9thode Java ou r\u00e9f\u00e9rence de zone
# This message is put into message 42X75 when a parameter doesn't have a
# datatype. For example, from the parameterWidening test:
#
# values (java.lang.Integer::toString(?, null));
# ERROR 42X50: No method was found with the signature
# java.lang.Integer.toString(UNTYPED, UNTYPED).  It may be that the method
# exists, but it is not public and/or static, or that the parameter types
# are not method invocation convertible.
42Z01.U=UNTYPED
42Z02=Plusieurs agr\u00e9gats DISTINCT ne sont pas pris en charge \u00e0 ce stade.
42Z07=Les agr\u00e9gats ne sont pas autoris\u00e9s dans la clause ON.
42Z08=Une op\u00e9ration d''insertion/remplacement globale n''est pas autoris\u00e9e  sur ''{0}'' parce qu''il contient un d\u00e9clencheur activ\u00e9 ({1}).
42Z09.U=le COLUMN DEFAULT pour
#
# The following message is used in error messages where we want to say that
# certain operations on streams are illegal. The word "stream" is not a
# keyword or method name, so it should be translated.
42Z11.U=flux

# alter table modify column error messages.
#####
42Z15=Type non valide sp\u00e9cifi\u00e9 pour la colonne ''{0}''. Le type d''une colonne ne peut pas \u00eatre modifi\u00e9.
42Z16=Seule la longueur des colonnes de type VARCHAR peut \u00eatre modifi\u00e9e. 
42Z17=Longueur incorrecte sp\u00e9cifi\u00e9e pour la colonne ''{0}''. La longueur doit \u00eatre sup\u00e9rieure \u00e0 la longueur de colonne actuelle.
42Z18=La colonne ''{0}'' fait partie d''une contrainte de cl\u00e9 externe ''{1}''. Pour modifier la longueur de cette colonne, vous devez d''abord supprimer la contrainte, ex\u00e9cuter ALTER TABLE, puis recr\u00e9er la contrainte.
42Z19=La colonne ''{0}'' est r\u00e9f\u00e9renc\u00e9e par au moins une contrainte de cl\u00e9 externe ''{1}''. Pour modifier la longueur de cette colonne, vous devez d''abord supprimer les contraintes faisant r\u00e9f\u00e9rence, ex\u00e9cuter ALTER TABLE, puis recr\u00e9er la contrainte.
42Z20=La colonne ''{0}'' ne peut pas accepter de valeur NULL. Elle fait partie d''une cl\u00e9 primaire qui ne peut pas contenir de colonnes ayant une valeur nulle.

#####
# end of alter table modify constraints.
# identity error message (from 42Z21-42Z29)
#####
42837=ALTER TABLE ''{0}'' a sp\u00e9cifi\u00e9 des attributs pour la colonne ''{1}'' qui ne sont pas compatibles avec la colonne existante.
42Z21=Incr\u00e9ment non valide sp\u00e9cifi\u00e9 pour l''identit\u00e9 de la colonne ''{0}''. L''incr\u00e9ment doit \u00eatre une valeur autre que z\u00e9ro.
42Z22=Type non valide sp\u00e9cifi\u00e9 pour la colonne d''identit\u00e9 ''{0}''. Les seuls types valides pour les colonnes d''identit\u00e9 sont BIGINT, INT et SMALLINT.
42Z23=Tentative de modification d''une colonne d''identit\u00e9 ''{0}''. 
42Z24=Un d\u00e9passement de la valeur d''identit\u00e9 est survenu pour la colonne ''{1}'' dans la table ''{0}''.
42Z25=ERREUR INTERNE - Compteur d'identit\u00e9 : Une mise \u00e0 jour a \u00e9t\u00e9 appel\u00e9e sans argument avec la valeur en cours = NULL.
42Z26=Une colonne ''{0}'' associ\u00e9e \u00e0 une valeur d''identit\u00e9 par d\u00e9faut ne peut pas prendre la valeur ''null''.
42Z27=Une colonne pouvant prendre la valeur ''null'' ''{0}'' ne peut pas \u00eatre modifi\u00e9e pour prendre une valeur d''identit\u00e9 par d\u00e9faut.

#####
# end of identity error messages.

42Z30.U=temps pass\u00e9 dans ce ResultSet =
42Z31.U=temps pass\u00e9 dans ce ResultSet et plus bas =
42Z32.U=r\u00e9partition de la dur\u00e9e totale : 
42Z33.U=dur\u00e9e du constructeur (millisecondes) =
42Z34.U=dur\u00e9e d'ouverture (millisecondes) =
42Z35.U=dur\u00e9e next (millisecondes) =
42Z36.U=dur\u00e9e de fermeture (millisecondes) =
42Z37.U=Aucun
42Z38.U=Aucune information de positionnement n'est disponible parce que ce ResultSet n'a jamais \u00e9t\u00e9 ouvert.
42Z39.U=Exception impr\u00e9vue {0} lors de l''extraction du positionneur.
## NOTE: In the following message, {0} will be either >= or >
42Z40.U={0} sur les premi\u00e8res {1} colonne(s).
42Z41.U=S\u00e9mantique des valeurs NULL ordonn\u00e9es dans les colonnes suivantes : 
42Z42.U=ID de colonne
42Z43.U=Op\u00e9rateur
42Z44.U=Valeurs NULL ordonn\u00e9es
42Z45.U=Valeur de retour inconnue
42Z46.U=Inverser la fen\u00eatre des r\u00e9sultats de la comparaison
42Z47.U=L''extraction du plan de requ\u00eate sous forme de cha\u00eene n''est pas prise en charge actuellement pour {0}
## NOTE: In the following message, {0} and {1} are integer indexes into a 2-d array
42Z48.U=Id de colonne[{0}][{1}]

# matches DB2
42939=Un objet ne peut pas \u00eatre cr\u00e9\u00e9 avec le nom du sch\u00e9ma ''{0}''.




42Z50=ERREUR INTERNE : Impossible de g\u00e9n\u00e9rer du code pour {0}.
42Z53=ERREUR INTERNE : Ne sait pas quel type d''activation g\u00e9n\u00e9rer pour la s\u00e9lection du noeud {0}.
42Z54.U=Cette exception arr\u00eate l'instruction apr\u00e8s l'analyse syntaxique - aucun autre traitement n'est requis.
42Z55.U=L'ex\u00e9cution a \u00e9t\u00e9 arr\u00eat\u00e9e apr\u00e8s l'analyse syntaxique par l'indicateur de d\u00e9bogage StopAfterParsing.
42Z56.U=L'ex\u00e9cution a \u00e9t\u00e9 arr\u00eat\u00e9e apr\u00e8s la liaison par l'indicateur de d\u00e9bogage StopAfterBinding.
42Z57.U=L'ex\u00e9cution a \u00e9t\u00e9 arr\u00eat\u00e9e apr\u00e8s l'optimisation par l'indicateur de d\u00e9bogage StopAfterOptimizing.
42Z58.U=L'ex\u00e9cution a \u00e9t\u00e9 arr\u00eat\u00e9e apr\u00e8s la g\u00e9n\u00e9ration par l'indicateur de d\u00e9bogage StopAfterGenerating.

## More RUNTIMESTATISTICS messages
42Z80.U=s\u00e9rialisable
42Z81.U=lecture valid\u00e9e
42Z82.U=exclusif
42Z83.U=partage instantan\u00e9
42Z84.U=partager
42Z85.U=table
42Z86.U=ligne
42Z87.U=partager la table
42Z88.U=partager la ligne

# More generic language stuff
42Z90=La classe ''{0}'' ne renvoie pas de ResultSet pouvant \u00eatre mis \u00e0 jour.
42Z91=sous-requ\u00eate
42Z92=lecture reproductible
42Z9A=lecture non valid\u00e9e

# Declare global temporary table language stuff. Does not match DB2, specific to Derby behavior
XCL478.S=La fonction demand\u00e9e ne peut pas faire r\u00e9f\u00e9rence \u00e0 des tables du sch\u00e9ma SESSION.
# Declare global temporary table language stuff. Matches DB2
428EK=Le qualifiant d'une table temporaire globale d\u00e9clar\u00e9e doit obligatoirement \u00eatre SESSION.
42995=La fonction demand\u00e9e ne s'applique pas aux tables temporaires globales.
42962=Une colonne de type Long ou un param\u00e8tre ''{0}'' n''est pas autoris\u00e9 dans des tables temporaires globales d\u00e9clar\u00e9es, ni des d\u00e9finitions de proc\u00e9dure. 

## org.apache.derby.impl.sql.execute.rts
43X00.U=Connect\u00e9 \u00e0
43X01.U=Num\u00e9ro de sous-requ\u00eate de d\u00e9but
# NOTE: In this case, the name of the type of ResultSet is "Any". ResultSet
# is the name of an interface, so it should not be translated.
43X02.U=Tout ResultSet
43X03.U=Nombre d'ouvertures
43X04.U=Lignes affich\u00e9es
43X05.U=Ensemble de r\u00e9sultats source
43X06.U=Num\u00e9ro de sous-requ\u00eate de fin
43X07.U=nombre de lignes estim\u00e9 par l'optimiseur
43X08.U=co\u00fbt estim\u00e9 par l'optimiseur
43X09.U=secondes
43X10.U=Total
43X11.U=Noeud
43X12.U={0} non impl\u00e9ment\u00e9 actuellement pour {1}
# NOTE: In this case, the name of the type of ResultSet is "Any". ResultSet
# is the name of an interface, so it should not be translated.
43X13.U=Supprimer ResultSet \u00e0 l'aide de
43X14.U=verrouillage des tables
43X15.U=verrouillage des lignes
43X16.U=mise en diff\u00e9r\u00e9
43X17.U=Lignes supprim\u00e9es
43X18.U=Index mis \u00e0 jour
43X19.U=Supprimer
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X20.U=ResultSet d'agr\u00e9gat scalaire distinct
# NOTE: In this message, "input" is being used as a verb
43X21.U=Lignes entr\u00e9es
43X22.U=Agr\u00e9gat scalaire distinct
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X23.U=ResultSet d''analyse distincte pour {0} en utilisant {1} {2}
43X24.U=contrainte
43X25.U=index
43X26.U=ResultSet d''analyse distincte pour {0}
#NOTE: In this message, {0} will be something like "serializable" or "read
# committed", and {1} will be something like "share" or "exclusive".
43X27.U=au niveau d''isolement {0} \u00e0 l''aide du verrouillage {1}
43X28.U=informations d'analyse
43X29.U=La colonne distincte est le num\u00e9ro de colonne
43X30.U=Les colonnes distinctes sont les num\u00e9ros de colonne
43X31.U=Taille de la table de hachage
43X32.U=Lignes filtr\u00e9es
43X33.U=dur\u00e9e next en millisecondes/ligne
43X34.U=position de d\u00e9but
43X35.U=position d'arr\u00eat
43X36.U=qualifiants d'analyse
#NOTE: The message means the set of qualifiers that filter rows returned
# by the "next" operation, not the set of qualifiers that come next.
43X37.U=qualifiants next
#NOTE: In this message, {0} is a table name and {1} is an index name
43X38.U=sur {0} \u00e0 l''aide de {1}
43X39.U=Analyse distincte
43X40.U=Informations de tri
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X41.U=ResultSet d'agr\u00e9gat regroup\u00e9
43X42.U=Poss\u00e8de un agr\u00e9gat distinct
43X43.U=Par ordre de tri
43X44.U=Agr\u00e9gat regroup\u00e9
43X45.U=Jointure Exists par hachage
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X46.U=ResultSet de jointure Exists par hachage
43X47.U=Jointure par hachage
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X48.U=ResultSet de jointure par hachage
43X49.U=Jointure externe gauche par hachage
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X50.U=ResultSet de jointure externe gauche par hachage
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {1} is either "constraint" or "index", {0} is a table name, and {2} is a
# constraint or index name.
43X51.U=ResultSet d''analyse du hachage pour {0} en utilisant {1} {2}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X52.U=ResultSet d''analyse du hachage pour {0}
43X53.U=La cl\u00e9 de hachage est le num\u00e9ro de colonne
43X54.U=Les cl\u00e9s de hachage sont les num\u00e9ros de colonne
43X55.U=Analyse du hachage
43X56.U=Sous-requ\u00eates associ\u00e9es
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X57.U=ResultSet de table de hachage
43X58.U=Table de hachage
43X59.U=tous
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43X60.U=ResultSet de la ligne de base vers la ligne d''index pour {0}
43X61.U=Colonnes accessible \u00e0 partir du segment de m\u00e9moire
#NOTE: {0} is a table name
43X62.U=pour {0}
43X63.U=Ligne de base vers ligne d'index
43X64.U=mode d'insertion : insertion globale
43X65.U=mode d'insertion : normal (impossible d'effectuer une insertion globale car la table est non vide)
43X66.U=mode d'insertion : normal
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X67.U=Ins\u00e9rer ResultSet \u00e0 l'aide de
43X68.U=Lignes ins\u00e9r\u00e9es
43X69.U=Ins\u00e9rer
43X70.U=Joindre
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43X71.U=ResultSet de derni\u00e8re analyse de l''index des cl\u00e9s pour {0} en utilisant l''index {1}
43X72.U=au niveau d''isolement {0} \u00e0 l''aide du verrouillage {1} choisi par l''optimiseur
43X73.U=Analyse de table
43X74.U=Analyse d'index
#NOTE: {0} is a table name or class name
43X75.U=sur {0}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X76.U=ResultSet mat\u00e9rialis\u00e9
43X77.U=dur\u00e9e de cr\u00e9ation du conglom\u00e9rat temporaire (millisecondes)
43X78.U=dur\u00e9e d'extraction du conglom\u00e9rat temporaire (millisecondes)
43X79.U=Lignes vues de la gauche
43X80.U=Lignes vues de la droite
43X81.U=Lignes renvoy\u00e9es
43X82.U=Ensemble de r\u00e9sultats de gauche
43X83.U=Ensemble de r\u00e9sultats de droite
43X84.U=Jointure Exists en boucle imbriqu\u00e9e
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X85.U=ResultSet de jointure Exists en boucle imbriqu\u00e9e
43X86.U=Jointure en boucle imbriqu\u00e9e
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X87.U=ResultSet de jointure en boucle imbriqu\u00e9e
43X88.U=Lignes de droite vides renvoy\u00e9es
43X89.U=Jointure externe gauche en boucle imbriqu\u00e9e
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X90.U=ResultSet de jointure externe gauche en boucle imbriqu\u00e9e
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X91.U=ResultSet normalis\u00e9
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X92.U=ResultSet \u00e0 valeur unique
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X93.U=ResultSet de projection-limitation
43X94.U=limitation
43X95.U=projection
43X96.U=dur\u00e9e de limitation (millisecondes)
43X97.U=dur\u00e9e de projection (millisecondes)
43X98.U=Limitation-projection
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X99.U=ResultSet de ligne
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y00.U=ResultSet d'agr\u00e9gat scalaire
43Y01.U=Optimisation de cl\u00e9 d'index
43Y02.U=Agr\u00e9gat scalaire
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y03.U=ResultSet insensible au d\u00e9filement
43Y04.U=Nombre de lectures \u00e0 partir de la table de hachage
43Y05.U=Nombre d'\u00e9critures dans la table de hachage
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y06.U=ResultSet de tri
43Y07.U=Eliminer les \u00e9l\u00e9ments en double
43Y08.U=Tri
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name, {1} is either "constraint" or "index", {2} is a
# constraint or index name.
43Y09.U=ResultSet d''analyse d''index pour {0} en utilisant {1} {2}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43Y10.U=ResultSet d''analyse de table pour {0}
43Y11.U=Verrouillage effectif utilis\u00e9 : verrouillage au niveau de la table
43Y12.U=Taille d'extraction
43Y13.U=qualifiants
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y14.U=ResultSet d'union
43Y15.U=Union
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is either "table" or "row"
43Y16.U=ResultSet de mise \u00e0 jour utilisant le verrouillage {0}
43Y17.U=Lignes mises \u00e0 jour
43Y18.U=Mettre \u00e0 jour
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a Java class name.
43Y19.U=ResultSet de VTI pour {0}
43Y20.U=VTI
43Y21.U=Sous-requ\u00eates mat\u00e9rialis\u00e9es
43Y22.U=Nom de l'instruction
43Y23.U=Texte de l'instruction
# NOTE: This means the amount of time it takes to parse
43Y24.U=Dur\u00e9e de l'analyse
# NOTE: This means the amount of time it takes to bind
43Y25.U=Dur\u00e9e de la liaison
# NOTE: This means the amount of time it takes to optimize
43Y26.U=Dur\u00e9e de l'optimisation
# NOTE: This means the amount of time it takes to generate
43Y27.U=Dur\u00e9e de la g\u00e9n\u00e9ration
# NOTE: This means the amount of time it takes to compile
43Y28.U=Dur\u00e9e de la compilation
# NOTE: This means the amount of time it takes to execute
43Y29.U=Dur\u00e9e de l'ex\u00e9cution
43Y30.U=Horodatage du d\u00e9but de la compilation
43Y31.U=Horodatage de la fin de la compilation
43Y32.U=Horodatage du d\u00e9but de l'ex\u00e9cution
43Y33.U=Horodatage de la fin de l'ex\u00e9cution
43Y44.U=Texte du plan d'ex\u00e9cution de l'instruction
43Y45.U=Phase d''ex\u00e9cution 100%, {0} secondes
43Y46.U=Ins\u00e9rer le ResultSet du VTI
43Y47.U=Supprimer le ResultSet du VTI
43Y49.U=Ins\u00e9rer le VTI
43Y50.U=Supprimer le VTI
43Y51.U=Supprimer le ResultSet en cascade
43Y52.U=Supprimer le ResultSet en cascade \u00e0 l'aide de
43Y53.U=Actions de r\u00e9f\u00e9rentiel dans des tables d\u00e9pendantes
43Y54.U=D\u00e9but de l'action de r\u00e9f\u00e9rentiel dans un num\u00e9ro de table d\u00e9pendante
43Y55.U=Fin de l'action de r\u00e9f\u00e9rentiel dans un num\u00e9ro de table d\u00e9pendante

54004=L'instruction SELECT contient trop d'\u00e9l\u00e9ments dans la liste select, ORDER BY ou GROUP BY.
54008=L'instruction CREATE INDEX sp\u00e9cifie un trop grand nombre de colonnes (le maximum est 16).
54023=Le nombre de param\u00e8tres maximal admis pour une proc\u00e9dure a \u00e9t\u00e9 d\u00e9pass\u00e9. La limite est de {0} et le nombre de param\u00e8tres pour la proc\u00e9dure {1} est {2}.
54038=La profondeur maximale de d\u00e9clencheurs imbriqu\u00e9s a \u00e9t\u00e9 d\u00e9pass\u00e9e.

## all other org.apache.derby.catalog.types
44X00.U=Nom du type SQL
44X05.U=erreur suivante

X0X02.S=La table ''{0}'' ne peut pas \u00eatre verrouill\u00e9e en mode ''{1}''.
X0X03.S=Etat de transaction non valide - la conservation du curseur requiert le m\u00eame niveau d'isolement
X0X05.S=La table ''{0}'' n''existe pas.
X0X0E.S=L''emplacement de la colonne ''{0}'' r\u00e9pertori\u00e9 dans le tableau de s\u00e9lection des colonnes \u00e0 g\u00e9n\u00e9ration automatique n''a pas \u00e9t\u00e9 trouv\u00e9 dans la table d''insertion.
X0X0F.S=Le nom de colonne ''{0}'' r\u00e9pertori\u00e9 dans le tableau de s\u00e9lection des colonnes \u00e0 g\u00e9n\u00e9ration automatique n''a pas \u00e9t\u00e9 trouv\u00e9 dans la table d''insertion.
X0X07.S=Impossible de supprimer le fichier JAR ''{0}'' parce qu''il se trouve dans votre db2j.database.classpath ''{0}''.
X0X10.S=La clause USING a renvoy\u00e9 plusieurs lignes ; seuls les ResultSets d'une seule ligne sont autoris\u00e9s.
X0X11.S=La clause USING n'a pas renvoy\u00e9 de r\u00e9sultats ; aucun param\u00e8tre ne peut \u00eatre d\u00e9fini.
X0X13.S=Le fichier JAR ''{0}'' n''existe pas dans le sch\u00e9ma ''{1}''.
X0X57.S=Une tentative de placement d''une valeur Java de type ''{0}'' dans une valeur SQL a \u00e9t\u00e9 effectu\u00e9e alors qu''il n''existe pas de type SQL correspondant.  La valeur Java est probablement le r\u00e9sultat d''un appel de m\u00e9thode ou de l''acc\u00e8s \u00e0 une zone.
X0X60.S=Un curseur ayant pour nom ''{0}'' existe d\u00e9j\u00e0.
X0X61.S=Les valeurs pour la colonne ''{4}'' dans l''index ''{0}'' et la table ''{1}.{2}'' ne correspondent pas \u00e0 l''emplacement de ligne {3}.  La valeur dans l''index est ''{5}'', tandis que la valeur dans la table de base est ''{6}''.  La cl\u00e9 d''index compl\u00e8te, qui comprend l''emplacement de ligne, est ''{7}''.  L''intervention sugg\u00e9r\u00e9e consiste \u00e0 recr\u00e9er l''index.
X0X62.S=Incoh\u00e9rence d\u00e9tect\u00e9e entre la table ''{0}'' et l''index ''{1}''.  Erreur lors de la tentative d''extraction de l''emplacement de ligne ''{2}'' \u00e0 partir de la table.  La cl\u00e9 d''index compl\u00e8te, qui comprend l''emplacement de ligne, est ''{3}''. L''intervention sugg\u00e9r\u00e9e consiste \u00e0 recr\u00e9er l''index.
X0X63.S=Exception d''E/S ''{0}'' intercept\u00e9e.
X0X67.S=Les colonnes de type ''{0}'' ne peuvent pas \u00eatre utilis\u00e9es dans CREATE INDEX, ORDER BY, GROUP BY, UNION ou DISTINCT, parce que les comparaisons ne sont pas prises en charge pour ce type.
X0X81.S={0} ''{1}'' n''existe pas.
X0X85.S=L''index ''{0}'' n'a pas \u00e9t\u00e9 cr\u00e9\u00e9 parce que ''{1}'' n''est pas un type d''index valide.
X0X86.S=0 est une valeur de param\u00e8tre incorrecte pour ResultSet.absolute(int row).
X0X87.S=ResultSet.relative(int row) ne peut pas \u00eatre appel\u00e9e lorsque le curseur n'est pas positionn\u00e9 sur une ligne.
X0X95.S=L'op\u00e9ration ''{0}'' ne peut pas \u00eatre ex\u00e9cut\u00e9e sur l''objet ''{1}'' parce qu''il existe un ResultSet ouvert d\u00e9pendant de cet objet.
X0X99.S=L''index ''{0}'' n''existe pas.
X0Y16.S=''{0}'' n''est pas une vue.  S''il s'agit d''une table, utilisez plut\u00f4t DROP TABLE.
X0Y23.S=L''op\u00e9ration ''{0}'' ne peut pas \u00eatre ex\u00e9cut\u00e9e sur l''objet ''{1}'' parce que la VUE ''{2}'' est d\u00e9pendante de cet objet.
X0Y24.S=L''op\u00e9ration ''{0}'' ne peut pas \u00eatre ex\u00e9cut\u00e9e sur l''objet ''{1}'' parce que l''INSTRUCTION ''{2}'' est d\u00e9pendante de cet objet.
X0Y25.S=L''op\u00e9ration ''{0}'' ne peut pas \u00eatre ex\u00e9cut\u00e9e sur l''objet ''{1}'' parce que {2} ''{3}'' est d\u00e9pendant de cet objet.
X0Y26.S=L''index ''{0}'' doit obligatoirement se trouver dans le m\u00eame sch\u00e9ma que la table ''{1}''.
X0Y28.S=L''index ''{0}'' ne peut pas \u00eatre cr\u00e9\u00e9 sur une table syst\u00e8me ''{1}''.  Les utilisateurs ne peuvent pas cr\u00e9er d''index sur les tables syst\u00e8me.
# column c already exists in table t.
X0Y32.S={0} ''{1}'' existe d\u00e9j\u00e0 dans {2} ''{3}''.
X0Y38.S=Impossible de cr\u00e9er l''index ''{0}'' parce que la table ''{1}'' n''existe pas.
X0Y41.S=La contrainte ''{0}'' n''est pas valide : la table r\u00e9f\u00e9renc\u00e9e {1} ne poss\u00e8de pas de cl\u00e9 primaire.  Vous pouvez soit ajouter une cl\u00e9 primaire \u00e0 {1}, soit sp\u00e9cifier explicitement les colonnes d''une contrainte unique \u00e0 laquelle cette cl\u00e9 externe fait r\u00e9f\u00e9rence.
X0Y42.S=La contrainte ''{0}'' n''est pas valide : les types des colonnes de cl\u00e9s externes ne correspondent pas aux types des colonnes r\u00e9f\u00e9renc\u00e9es.
X0Y43.S=La contrainte ''{0}'' n''est pas valide : le nombre de colonnes de {0} ({1}) ne correspond pas au nombre de colonnes de la cl\u00e9 r\u00e9f\u00e9renc\u00e9e ({2}).
X0Y44.S=La contrainte ''{0}'' n''est pas valide : aucune contrainte de cl\u00e9 unique ou primaire de la table ''{1}'' ne correspond au nombre et aux types des colonnes de la cl\u00e9 externe.
X0Y45.S=La contrainte de cl\u00e9 externe ''{0}'' ne peut pas \u00eatre ajout\u00e9e ni activ\u00e9e dans la table {1} parce que 1 ou plusieurs cl\u00e9s externes ne poss\u00e8dent pas de cl\u00e9s r\u00e9f\u00e9renc\u00e9es correspondantes.
X0Y46.S=La contrainte ''{0}'' n''est pas valide : la table r\u00e9f\u00e9renc\u00e9e {1} n''existe pas.
X0Y54.S=Le sch\u00e9ma ''{0}'' ne peut pas \u00eatre supprim\u00e9 parce qu''il n''est pas vide.
X0Y55.S=Le nombre de lignes de la table de base ne correspond pas au nombre de lignes d''au moins 1 des index de la table. L''index ''{0}'' de la table ''{1}.{2}'' comprend {3} lignes, mais la table de base en comprend {4}.  L''intervention sugg\u00e9r\u00e9e consiste \u00e0 recr\u00e9er l''index.
X0Y56.S=''{0}'' n''est pas autoris\u00e9 sur la table syst\u00e8me ''{1}''.
X0Y57.S=Une colonne n''acceptant pas de valeurs NULL ne peut pas \u00eatre ajout\u00e9e \u00e0 la table ''{0}'' \u00e9tant donn\u00e9 que la table contient au moins 1 ligne.  Les colonnes n''acceptant pas de valeurs NULL peuvent uniquement \u00eatre ajout\u00e9es \u00e0 des tables vides.
X0Y58.S=La tentative d''ajout d''une contrainte de cl\u00e9 primaire \u00e0 la table ''{0}'' a \u00e9chou\u00e9 parce que la table contient d\u00e9j\u00e0 une contrainte de ce type.  Une table ne peut avoir qu''une seule contrainte de cl\u00e9 primaire.
X0Y59.S=La tentative d''ajout ou d''activation d''une ou plusieurs contraintes sur la table ''{1}'' a \u00e9chou\u00e9 parce que la table contient {2} ligne(s) qui violent la ou les contraintes de v\u00e9rification suivantes : {0}.
X0Y63.S=La commande sur la table ''{0}'' a \u00e9chou\u00e9. Des donn\u00e9es NULL ont \u00e9t\u00e9 trouv\u00e9es dans une ou plusieurs colonnes d''index/de contrainte de cl\u00e9 primaire ou unique. Toutes les colonnes d''une cl\u00e9 d''index primaire ou unique doivent comporter de valeurs non nulles.
X0Y66.S=Impossible d'\u00e9mettre une validation dans une connexion imbriqu\u00e9e dont la connexion parent contient une op\u00e9ration en attente.
X0Y67.S=Impossible d'\u00e9mettre une annulation dans une connexion imbriqu\u00e9e dont la connexion parent contient une op\u00e9ration en attente.
X0Y68.S={0} ''{1}'' existe d\u00e9j\u00e0.
X0Y69.S={1} n''est pas autoris\u00e9 parce que le d\u00e9clencheur {0} est actif sur {2}.
X0Y70.S=INSERT, UPDATE et DELETE ne sont pas autoris\u00e9s sur la table {1} parce que le d\u00e9clencheur {0} est actif.
X0Y71.S=La manipulation de transaction, telle que SET ISOLATION, n''est pas autoris\u00e9e parce que le d\u00e9clencheur {0} est actif.
X0Y72.S=Une op\u00e9ration d''insertion/remplacement globale n''est pas autoris\u00e9e  sur ''{0}'' parce qu''il contient un d\u00e9clencheur activ\u00e9 ({1}).
X0Y77.S=Impossible d'\u00e9mettre une instruction de d\u00e9finition de l'isolement d'une transaction sur une transaction globale qui est en cours car cela entra\u00eenerait implicitement la validation de la transaction globale. 
X0Y78.S=Statement.executeQuery() ne peut pas \u00eatre appel\u00e9e avec une instruction qui renvoie un nombre de lignes.
X0Y79.S=Statement.executeUpdate() ne peut pas \u00eatre appel\u00e9e avec une instruction qui renvoie un ResultSet.
X0Y80.S=Echec de l''op\u00e9ration ALTER sur la table ''{0}''. Des donn\u00e9es NULL ont \u00e9t\u00e9 trouv\u00e9es dans la colonne ''{1}''.
X0Y83.S=AVERTISSEMENT : Lors de la suppression d''une ligne d''une table, la ligne d''index correspondant \u00e0 la ligne de la table de base {0} n''a pas \u00e9t\u00e9 trouv\u00e9e dans l''index avec l''ID de conglom\u00e9rat {1}.  Ce probl\u00e8me a \u00e9t\u00e9 corrig\u00e9 automatiquement dans le cadre de l''op\u00e9ration de suppression.
XCL01.S=L''ensemble de r\u00e9sultats ne renvoie pas de lignes ; l''op\u00e9ration {0} n'est pas autoris\u00e9e.
XCL05.S=L''activation est ferm\u00e9e, l''op\u00e9ration {0} n''est pas autoris\u00e9e.
XCL07.S=Le curseur ''{0}'' est ferm\u00e9. V\u00e9rifiez que la fonction de validation automatique est d\u00e9sactiv\u00e9e (OFF).
XCL08.S=Le curseur ''{0}'' ne se trouve pas sur une ligne.
XCL09.S=Une activation qui ne correspond pas \u00e0 l''instruction pr\u00e9par\u00e9e (PreparedStatement) a \u00e9t\u00e9 transmise \u00e0 la m\u00e9thode ''{0}''.
XCL10.S=Une instruction pr\u00e9par\u00e9e (PreparedStatement) a \u00e9t\u00e9 recompil\u00e9e et les param\u00e8tres ont chang\u00e9.  Si vous utilisez JDBC, vous devez de nouveau pr\u00e9parer l'instruction.
XCL12.S=Une tentative de placement d''une valeur de donn\u00e9es de type ''{0}'' dans une valeur de donn\u00e9es de type ''{1}'' a \u00e9t\u00e9 effectu\u00e9e.
XCL13.S=La position de param\u00e8tre ''{0}'' est en dehors des limites.  Le nombre de param\u00e8tres pour cette instruction pr\u00e9par\u00e9e est ''{1}''.
XCL15.S=Une exception ClassCastException s''est produite lors de l''appel de la m\u00e9thode compareTo() sur un objet ''{0}''.  Le param\u00e8tre pour compareTo() est de classe ''{1}''.
XCL16.S=Le ResultSet n''est pas ouvert, l''op\u00e9ration ''{0}'' n''est pas autoris\u00e9e. V\u00e9rifiez que la fonction de validation automatique est d\u00e9sactiv\u00e9e (OFF).
XCL17.S=Instruction non autoris\u00e9e dans cette base de donn\u00e9es.
XCL19.S=Ligne manquante dans la table ''{0}'' pour la cl\u00e9 ''{1}''.
XCL20.S=Les catalogues dont le niveau de version est ''{0}'' ne peuvent pas \u00eatre mis \u00e0 niveau vers le niveau de version ''{1}''.
XCL21.S=Vous essayez d'ex\u00e9cuter une instruction de d\u00e9finition de donn\u00e9es (CREATE, DROP ou ALTER) tandis que vous pr\u00e9parez une instruction diff\u00e9rente.  Cette op\u00e9ration n'est pas autoris\u00e9e. Cette situation peut se produire si vous ex\u00e9cutez une instruction de d\u00e9finition de donn\u00e9es \u00e0 partir d'un initialiseur statique d'une classe Java qui est en cours d'utilisation depuis une instruction SQL.
XCL22.S=Le param\u00e8tre {0} ne peut pas \u00eatre enregistr\u00e9 en tant que param\u00e8tre OUT car il s''agit d''un param\u00e8tre IN.
XCL23.S=Le type SQL num\u00e9ro ''{0}'' n''est pas un type pris en charge par registerOutParameter().
XCL24.S=Le param\u00e8tre {0} semble \u00eatre un param\u00e8tre de sortie, mais il n''a pas \u00e9t\u00e9 d\u00e9sign\u00e9 ainsi par registerOutParameter().  S''il ne s''agit pas d''un param\u00e8tre de sortie, alors il doit \u00eatre d\u00e9fini sur le type {1}.
XCL25.S=Le param\u00e8tre {0} ne peut pas \u00eatre enregistr\u00e9 pour \u00eatre de type {1} parce qu''il est mapp\u00e9 vers le type {2} et qu''ils sont incompatibles.
XCL26.S=Le param\u00e8tre {0} n''est pas un param\u00e8tre de sortie.
XCL27.S=Les param\u00e8tres de sortie en renvoi ne peuvent pas \u00eatre d\u00e9finis.
XCL30.S=Une exception d''E/S a \u00e9t\u00e9 \u00e9mise lors de la lecture d''un ''{0}'' \u00e0 partir d''un flux d''entr\u00e9e (InputStream).
XCL31.S=Instruction ferm\u00e9e.

# Delete Rule Restrictions Violation Messages
XCL33.S=La table ne peut pas \u00eatre d\u00e9finie comme \u00e9tant d\u00e9pendante de la table {0} en raison des limitations de la r\u00e8gle de suppression. (La relation est auto-r\u00e9f\u00e9renc\u00e9e et ce type de relation est d\u00e9j\u00e0 associ\u00e9 \u00e0 la r\u00e8gle de suppression SET NULL.) 
XCL34.S=La table ne peut pas \u00eatre d\u00e9finie comme \u00e9tant d\u00e9pendante de la table {0} en raison des limitations de la r\u00e8gle de suppression. La relation engendre un cycle de deux ou plusieurs tables qui \u00e9tablit une d\u00e9pendance en cas de suppression entre chaque table (toutes les autres r\u00e8gles de suppression du cycle sont en CASCADE).  
XCL35.S=La table ne peut pas \u00eatre d\u00e9finie comme \u00e9tant d\u00e9pendante de la table {0} en raison des limitations de la r\u00e8gle de suppression. Dans le cadre de la relation, une d\u00e9pendance en cas de suppression s''\u00e9tablit entre cette table et la table indiqu\u00e9e en vertu de plusieurs relations et la r\u00e8gle de suppression de la relation existante est SET NULL.  

XCL36.S=la r\u00e8gle de suppression de la cl\u00e9 externe doit \u00eatre {0}. La contrainte r\u00e9f\u00e9rentielle est auto-r\u00e9f\u00e9renc\u00e9e et une contrainte de ce type est d\u00e9j\u00e0 associ\u00e9e \u00e0 la r\u00e8gle de suppression indiqu\u00e9e (NO ACTION, RESTRICT ou CASCADE). 
XCL37.S=la r\u00e8gle de suppression de la cl\u00e9 externe doit \u00eatre {0}. La contrainte r\u00e9f\u00e9rentielle est auto-r\u00e9f\u00e9renc\u00e9e et la table est d\u00e9pendante dans le cadre d''une relation avec la r\u00e8gle de suppression CASCADE.
XCL38.S=la r\u00e8gle de suppression de la cl\u00e9 externe doit \u00eatre {0}. Dans le cadre de la relation, une d\u00e9pendance en cas de suppression est \u00e9tablie entre cette table et une table identique en vertu de plusieurs relations qui doivent \u00eatre associ\u00e9es \u00e0 la m\u00eame r\u00e8gle de suppression (NO ACTION, RESTRICT ou CASCADE). 

XCL39.S=la r\u00e8gle de suppression de la cl\u00e9 primaire ne peut pas \u00eatre CASCADE. Une contrainte auto-r\u00e9f\u00e9renc\u00e9e associ\u00e9e \u00e0 une r\u00e8gle de suppression SET NULL, NO ACTION ou RESTRICT existe d\u00e9j\u00e0. 
XCL40.S=la r\u00e8gle de suppression de la cl\u00e9 primaire ne peut pas \u00eatre CASCADE. La relation engendre un cycle \u00e9tablissant une d\u00e9pendance en cas de suppression de la table avec elle-m\u00eame. Etant donn\u00e9 que l'une des r\u00e8gles de suppression du cycle n'est pas CASCADE, cette relation peut \u00eatre d\u00e9finie. 
XCL41.S=la r\u00e8gle de suppression de la cl\u00e9 primaire ne peut pas \u00eatre CASCADE. Dans le cadre de la relation, une d\u00e9pendance en cas de suppression est \u00e9tablie entre une autre table et la m\u00eame table par le biais de plusieurs chemins associ\u00e9s \u00e0 des r\u00e8gles de suppression diff\u00e9rentes ou \u00e0 une r\u00e8gle de suppression SET NULL.) 
XCL42.S="CASCADE"
XCL43.S="SET NULL"
XCL44.S="RESTRICT"
XCL45.S="NO ACTION"
XCL46.S="SET DEFAULT"

XCL47.S=L''utilisation de ''{0}'' requiert que la base de donn\u00e9es soit mise \u00e0 niveau de la version {1} en version {2} ou ult\u00e9rieure.

XCL48.S= L''instruction TRUNCATE TABLE n''est pas autoris\u00e9e sur ''{0}'' parce que sur cette table, des contraintes de cl\u00e9s uniques/primaires sont r\u00e9f\u00e9renc\u00e9s par des contraintes de cl\u00e9s externes activ\u00e9es \u00e0 partir d''autres tables. 
XCL49.S= L''instruction TRUNCATE TABLE n''est pas autoris\u00e9e sur ''{0}'' parce qu''elle contient un d\u00e9clencheur DELETE activ\u00e9 ({1}).
XCL50.S=La mise \u00e0 niveau de la base de donn\u00e9es \u00e0 partir d''une version ant\u00e9rieure n''est pas prise en charge.  Le niveau de version de la base de donn\u00e9es est ''{0}'' et celui de ce logiciel est ''{1}''.


# Transaction states, matches DB2
25000=Etat de transaction non valide.

# Authorization
25501=Impossible de d\u00e9finir la propri\u00e9t\u00e9 en lecture seule de la connexion dans une transaction active.
25502=Une modification des donn\u00e9es SQL n'est pas autoris\u00e9e pour une connexion, un utilisateur ou une base de donn\u00e9es en lecture seule.
25503=Une DDL n'est pas autoris\u00e9e pour une connexion, un utilisateur ou une base de donn\u00e9es en lecture seule.
25505=Un utilisateur en lecture seule ou un utilisateur dans une base de donn\u00e9es en lecture seule n'est pas autoris\u00e9 \u00e0 d\u00e9sactiver le mode lecture seule sur une connexion.
28501=Propri\u00e9t\u00e9 d''autorisation de la base de donn\u00e9es incorrecte ''{0}={1}''.
28502.C=Le nom d''utilisateur ''{0}'' n''est pas valide. 
28503=Le ou les utilisateurs ''{0}'' ne doivent pas figurer \u00e0 la fois dans les listes d''autorisation d''acc\u00e8s en lecture seule et d''acc\u00e8s int\u00e9gral.
28504=Le ou les utilisateurs ''{1}'' sont r\u00e9p\u00e9t\u00e9s dans la liste d''acc\u00e8s ''{0}'' ;
04501.C=Connexion \u00e0 la base de donn\u00e9es refus\u00e9.


# Dependency Manager
XD003.S=Impossible de restaurer la d\u00e9pendance \u00e0 partir du disque. DependableFinder = ''{0}''. Informations suppl\u00e9mentaires : ''{1}''.
XD004.S=Impossible de stocker les d\u00e9pendances.


#../java/com/ibm/db2j/impl/Connectivity/JDBC/Local/messages.properties
24000=Etat du curseur non valide - pas de ligne en cours.

07000=Au moins un param\u00e8tre de l'instruction en cours n'est pas initialis\u00e9.

# 07004 : {0} is an number {1) is fixed text OUT or INOUT
07004=Le param\u00e8tre {0} est un param\u00e8tre de proc\u00e9dure {1} et doit \u00eatre enregistr\u00e9 avec CallableStatement.registerOutParameter avant son ex\u00e9cution.

07009=Aucun param\u00e8tre d'entr\u00e9e.

S0022=La colonne ''{0}'' est introuvable.
XJ009.S=Utilisation de CallableStatement requise pour un appel de proc\u00e9dure stock\u00e9e ou l''utilisation de param\u00e8tres de sortie : {0}
XJ010.S=Impossible de g\u00e9n\u00e9rer un point de sauvegarde lorsque autoCommit est activ\u00e9.
XJ011.S=Impossible de transmettre une valeur null comme nom du point de sauvegarde.
XJ012.S=''{0}'' est d\u00e9j\u00e0 ferm\u00e9.
XJ013.S=Aucun ID pour les points de sauvegarde nomm\u00e9s.
XJ014.S=Aucun nom pour les points de sauvegarde dont le nom n'est pas indiqu\u00e9.
XJ016.S=La m\u00e9thode ''{0}'' n''est pas autoris\u00e9e sur une instruction pr\u00e9par\u00e9e.
XJ017.S=Aucune commande savepoint autoris\u00e9e dans le code de d\u00e9clenchement.
XJ018.S=Le nom de colonne ne peut pas \u00eatre nul.
XJ020.S=Le type d''objet n''est pas convertible en TYPE ''{0}'', la valeur java.sql.Types est incorrecte ou l''objet \u00e9tait NULL.
XJ022.S=Impossible de d\u00e9finir le flux : ''{0}''.
XJ023.S=Le flux en entr\u00e9e contenait moins de donn\u00e9es que la longueur demand\u00e9e.
XJ025.S=La longueur du flux en entr\u00e9e ne peut pas \u00eatre n\u00e9gative.
XJ030.S=Impossible de d\u00e9finir AUTOCOMMIT sur ON dans une connexion imbriqu\u00e9e.
XJ042.S=''{0}'' n''est pas une valeur admise pour la propri\u00e9t\u00e9 ''{1}''.
XJ044.S=''{0}'' est une \u00e9chelle non valide.
XJ045.S=Un niveau d''isolement non valide ou non pris en charge (actuellement), ''{0}'', a \u00e9t\u00e9 transmis \u00e0 Connection.setTransactionIsolationLevel(). Les valeurs actuellement prises ne charge sont java.sql.Connection.TRANSACTION_SERIALIZABLE, java.sql.Connection.TRANSACTION_REPEATABLE_READ, java.sql.Connection.TRANSACTION_READ_COMMITTED et java.sql.Connection.TRANSACTION_READ_UNCOMMITTED.
XJ04B.S=Le fichier de commandes ne peut pas contenir de commande qui essaye de renvoyer un ensemble de r\u00e9sultats.
XJ04C.S=Le fichier de commandes CallableStatement ne peut pas contenir de param\u00e8tres de sortie.
XJ056.S=Impossible de d\u00e9finir AUTOCOMMIT sur ON dans une connexion XA.
XJ057.S=Impossible de valider une transaction globale qui utilise la connexion ; le traitement de la validation doit passer par l'interface XAResource.
XJ058.S=Impossible d''annuler une transaction globale qui utilise la connexion ; le traitement de la validation doit passer par l'interface XAResource.
XJ059.S=Impossible de fermer une connexion tandis qu'une transaction globale est toujours active.
XJ05C.S=Impossible de d\u00e9finir la conservation de ResultSet.HOLD_CURSORS_OVER_COMMIT pour une transaction globale.
XJ061.S=La m\u00e9thode ''{0}'' est uniquement autoris\u00e9e sur les curseurs de d\u00e9filement.
XJ062.S=Valeur de param\u00e8tre non admise ''{0}'' pour ResultSet.setFetchSize(int rows).
XJ063.S=Valeur de param\u00e8tre non admise ''{0}'' pour Statement.setMaxRows(int maxRows).  La valeur du param\u00e8tre doit \u00eatre >= 0.
XJ064.S=Valeur de param\u00e8tre non admise ''{0}'' pour setFetchDirection(int direction).
XJ065.S=Valeur de param\u00e8tre non admise ''{0}'' pour Statement.setFetchSize(int rows).
XJ066.S=Valeur de param\u00e8tre non admise ''{0}'' pour Statement.setMaxFieldSize(int max).
XJ067.S=Le pointeur de text SQL est nul.
XJ068.S=Seuls executeBatch et clearBatch sont autoris\u00e9s au milieu d'un fichier de commandes.
XJ069.S=Aucune m\u00e9thode SetXXX autoris\u00e9e avec Execute Statement Using.
XJ080.S=Execute Statement Using a transmis {0} param\u00e8tres au lieu de {1}.
XJ070.S=Un argument de position n\u00e9gatif ou \u00e9gal \u00e0 z\u00e9ro ''{0}'' a \u00e9t\u00e9 transmis dans une m\u00e9thode Blob ou Clob.
XJ071.S=Un argument de longueur n\u00e9gatif ou \u00e9gal \u00e0 z\u00e9ro ''{0}'' a \u00e9t\u00e9 transmis dans une m\u00e9thode Blob ou Clob.
XJ072.S=Un sch\u00e9ma ou un searchStr nul a \u00e9t\u00e9 transmis dans une m\u00e9thode de position Blob ou Clob.
XJ073.S=Les donn\u00e9es de data de ce Blob ou Clob ne sont plus disponibles. Cela peut r\u00e9sulter du fait que sa transaction a \u00e9t\u00e9 valid\u00e9e ou que sa connexion a \u00e9t\u00e9 arr\u00eat\u00e9e.
XJ076.S=L''argument de position ''{0}'' d\u00e9passe la taille du Blob/Clob.
XJ077.S=Une exception s'est produite lors de la tentative de lecture du premier octet/caract\u00e8re du sch\u00e9ma Blob/Clob en utilisant getBytes/getSubString.
XJ082.U=Les valeurs BLOB/CLOB ne sont pas autoris\u00e9es en tant que param\u00e8tres de m\u00e9thode ou r\u00e9cepteur.

0A000.S=Fonction non impl\u00e9ment\u00e9e : {0}.

XJ004.C=La base de donn\u00e9es ''{0}'' est introuvable.
08004=Connexion refus\u00e9e : {0}
A020=Authentification non valide.
08003=Aucune connexion en cours.
XJ028.C=L''URL ''{0}'' n'est pas dans un format appropri\u00e9.
XJ040.C=Echec du d\u00e9marrage de la base de donn\u00e9es ''{0}'' ; pour plus de d\u00e9tails, voir l''exception suivante.
XJ041.C=Echec de la cr\u00e9ation de la base de donn\u00e9es ''{0}'' ; pour plus de d\u00e9tails, voir l''exception suivante.
XJ049.C=Des attributs de cr\u00e9ation incompatibles ont \u00e9t\u00e9 sp\u00e9cifi\u00e9s.
XJ081.C=Des attributs de cr\u00e9ation/restauration/r\u00e9cup\u00e9ration incompatibles ont \u00e9t\u00e9 sp\u00e9cifi\u00e9s.
XJ05B.C=L''attribut JDBC ''{0}'' a une valeur incorrecte ''{1}'' ; les valeurs admises sont ''{2}''.

XXXXX.C.6=La session de base de donn\u00e9es normale est ferm\u00e9e.

08006.D=Arr\u00eat de la base de donn\u00e9es ''{0}''.

XJ015.M=Arr\u00eat du syst\u00e8me Derby.

01J01=La base de donn\u00e9es ''{0}'' n''est pas cr\u00e9\u00e9e ; la connexion a donc \u00e9t\u00e9 \u00e9tablie avec un base de donn\u00e9es existante.
01J02=Les curseurs sensibles au d\u00e9filement ne sont pas impl\u00e9ment\u00e9s actuellement.
01J03=Les ResultSets pouvant \u00eatre mis \u00e0 jour ne sont pas impl\u00e9ment\u00e9s actuellement.
01J04=La classe ''{0}'' pour la colonne ''{1}'' n''impl\u00e9mente pas java.io.Serializable ou java.sql.SQLData. Des instances doivent impl\u00e9menter l''une de ces interfaces pour permettre leur enregistrement.
01J05=La mise \u00e0 niveau de la base de donn\u00e9es a abouti. La base de donn\u00e9es mise \u00e0 niveau est d\u00e9sormais pr\u00eate \u00e0 \u00eatre utilis\u00e9e. Echec de la revalidation des instructions pr\u00e9par\u00e9es stock\u00e9es. Pour plus de d\u00e9tails sur cet \u00e9chec, reportez-vous \u00e0 l'exception suivante.

XJ001.U=Exception Java : ''{1}: {0}''.
XJ050.U=La base de donn\u00e9es n\u00e9cessite une mise \u00e0 niveau de la version {0}. D\u00e9finissez l''attribut ''upgrade=true'' sur l''URL de connexion JDBC pour permettre une mise \u00e0 niveau en version {1}.


# org.apache.derby.database.UserUtility
#
XCZ00.S=Droit d''acc\u00e8s ''{0}'' inconnu.
XCZ01.S=Utilisateur ''{0}'' inconnu.
XCZ02.S=Param\u00e8tre ''{0}''=''{1}'' non valide.

# SQL J Jar support
46001=Exception au cours de l''acc\u00e8s \u00e0 un fichier JAR en utilisant l''URL ''{0}''.

###############################################################################
#
# Text for non-exception strings
#
###############################################################################

# Log
L001=----------- DEBUT MESSAGE D'ERREUR ------------\n
L002=----------  FIN MESSAGE D'ERREUR -------------\n
L003=\n------------  DEBUT PILE D'ERREURS D'ARRET -----------\n
L004=\n------------  FIN PILE D'ERREURS D'ARRET -----------\n
L005=\n------------  DEBUT PILE D'ERREURS ----------\n
L006=\n------------  FIN PILE D'ERREURS ----------\n
L007=AVERTISSEMENT : Fichier journal introuvable, cr\u00e9ation d'un nouveau fichier journal. Possibilit\u00e9 d'incoh\u00e9rences dans la base de donn\u00e9es.
L008=Suppression d''un ancien fichier journal incompatible {0}
L009=Suppression d''un ancien fichier journal {0}
L010=Enregistrement de journal incomplet d\u00e9tect\u00e9 dans le fichier {0} ; effacement du fichier journal de la position {1} jusqu''au signal eof \u00e0 la position {2}.
L011=Le d\u00e9mon des points de contr\u00f4le a intercept\u00e9 une exception standard.
L012=l''enregistrement de journal n''est pas premier, mais la transaction n''est pas dans la table de transaction : {0}
L013=l''enregistrement de journal est premier, mais la transaction est d\u00e9j\u00e0 dans la table de transaction : {0}
L014=Instant du d\u00e9part incorrect
L015=le nouveau fichier journal existe et ne peut pas \u00eatre supprim\u00e9 {0}
L016=impossible de cr\u00e9er de nouveau fichier journal {0}
L017=impossible de cr\u00e9er de nouveau fichier journal {0} en raison de {1}
L018=Le syst\u00e8me peut se trouver dans un \u00e9tat incoh\u00e9rent ; fichier manquant {0}

# Class Manager
C000=La classe {0} a \u00e9t\u00e9 enregistr\u00e9e dans le fichier {1}. Indiquez le fichier et les informations suivantes relatives \u00e0 l''exception au support technique : {2}
C001=La classe {0} a un type de certificat inconnu dans le fichier JAR {1} ; le certificat X509 est escompt\u00e9.
C002=Exception de s\u00e9curit\u00e9 \u00e9mise lors de l''acc\u00e8s \u00e0 la classe {0} dans le fichier JAR {1} : {2}
C003=Exception lors du chargement du fichier JAR de la base de donn\u00e9es {0} - {1}
C004=Chargeur de classe p\u00e9rim\u00e9 pour la classe {0}
C005=Chargeur de classe de la base de donn\u00e9es d\u00e9marr\u00e9 - derby.database.classpath=''{0}''
C006={0} a \u00e9t\u00e9 charg\u00e9 \u00e0 partir du fichier JAR de la base de donn\u00e9es {1}
C007=Exception lors du chargement de la classe {0} \u00e0 partir du fichier JAR {1} - {2}

# RawStore Data

D001=:\n Amor\u00e7age de Derby version {0} : instance {1}\nsur le r\u00e9pertoire de la base de donn\u00e9es {2} \n
D002=:\nArr\u00eat de l''instance {0}
D004=La sauvegarde de la base de donn\u00e9es situ\u00e9e \u00e0 {0} a commenc\u00e9
D005=l''ancienne copie de sauvegarde a \u00e9t\u00e9 d\u00e9plac\u00e9e de {0} vers {1}
D006=le r\u00e9pertoire de la base de donn\u00e9es a \u00e9t\u00e9 copi\u00e9 de {0} dans {1}
D007=la base de donn\u00e9es service.properties a \u00e9t\u00e9 \u00e9dit\u00e9e pour utiliser l'unit\u00e9 de journalisation par d\u00e9faut
D008=erreur lors de l''\u00e9dition de la base de donn\u00e9es service.properties, abandon de la sauvegarde : {0}
D009=le r\u00e9pertoire de journalisation a \u00e9t\u00e9 copi\u00e9 de {0} dans {1}
D010=Sauvegarde abandonn\u00e9e en raison d'une erreur
D011=l''ancienne copie de sauvegarde situ\u00e9e \u00e0 {0} a \u00e9t\u00e9 supprim\u00e9e
D012=Sauvegarde termin\u00e9e, l''instant de journalisation est situ\u00e9 \u00e0 {0} \n

# Connectivity 
J004=identit\u00e9 de la base de donn\u00e9es
J005=arr\u00eater Derby
J007=cr\u00e9er une base de donn\u00e9es
J008=aucun d\u00e9tail
J010=chiffrer la base de donn\u00e9es sur disque
J013=mettre la base de donn\u00e9es \u00e0 niveau
J016=fournisseur de service cryptographique
J017=algorithme de cryptographie
J018=longueur de la cl\u00e9 de cryptographie
J019=cl\u00e9 de cryptographie externe
J020=cl\u00e9 de cryptographie secr\u00e8te
J021=territoire de la base de donn\u00e9es
J022=nom d'utilisateur
J023=mot de passe de l'utilisateur
J025=chemin d'acc\u00e8s du r\u00e9pertoire du fichier journal
J028=chemin de sauvegarde pour r\u00e9cup\u00e9ration aval
J100=Impossible de trouver la classe de serveur de r\u00e9seau, {0}. Votre chemin d''acc\u00e8s aux classes doit contenir le fichier csnet.jar.
J101=Impossible de charger la classe du serveur de r\u00e9seau, {0}. {1}  V\u00e9rifiez l''int\u00e9grit\u00e9 de votre fichier csnet.jar.
J102=Une exception a \u00e9t\u00e9 \u00e9mise au cours du d\u00e9marrage du serveur de r\u00e9seau. {0}
J103=Une exception a \u00e9t\u00e9 \u00e9mise lors de l''arr\u00eat du serveur de r\u00e9seau. {0}

# Authentication
A001=FATAL : Aucun service d'authentification n'existe pour le syst\u00e8me
A002=FATAL : Aucun service d'authentification n'existe pour la base de donn\u00e9es
A011=AVERTISSEMENT : Aucun nom de serveur LDAP/d''h\u00f4te n''est mentionn\u00e9 dans la propri\u00e9t\u00e9 {0} ; adoption par d\u00e9faut du syst\u00e8me h\u00f4te local:389

I015=org.apache.derby.jdbc.EmbeddedDriver n'est pas enregistr\u00e9 aupr\u00e8s du gestionnaire de pilotes JDBC.
I024=La base de donn\u00e9es n'est pas disponible.
I025=Pilote JDBC non disponible

# Import/Export
XIE01.S=La connexion \u00e9tait nulle.
XIE03.S=Donn\u00e9es trouv\u00e9es sur la ligne {0} pour la colonne {1} apr\u00e8s le d\u00e9limiteur d''arr\u00eat
XIE04.S=Fichier de donn\u00e9es introuvable : {0}
XIE05.S=Le fichier de donn\u00e9es ne peut pas \u00eatre nul.
XIE06.S=Le nom de l'entit\u00e9 \u00e9tait nul.
XIE07.S=Les s\u00e9parateurs de zone et d'enregistrements ne peuvent pas \u00eatre des sous-cha\u00eenes les uns des autres.
XIE08.S=Aucune colonne n''a pour nom : {0}
XIE09.S=Nombre total de colonnes de la ligne : {0}
XIE0B.S=La colonne ''{0}'' de la table est de type {1} et n''est pas prise en charge par les fonctions d''importation et d''exportation.
XIE0D.S=Impossible de trouver de s\u00e9parateur d''enregistrements sur la ligne {0}
XIE0E.S=Fin de fichier lue en un point inattendu de la ligne {0}
XIE0I.S=Exception d'E/S obtenue lors de l'\u00e9criture des donn\u00e9es dans le fichier
XIE0J.S=Un d\u00e9limiteur n'est pas valide ou est utilis\u00e9 plusieurs fois.
XIE0K.S=Le point a \u00e9t\u00e9 sp\u00e9cifi\u00e9 comme d\u00e9limiteur de cha\u00eene de caract\u00e8res.
XIE0M.S=La table ''{0}'' n''existe pas.

# Monitor
M001=\n# *********************************************************************************\n# ***                Veuillez ne PAS \u00e9diter ce fichier.                 ***\n# *** LA MODIFICATION DE SON CONTENU PEUT ENTRAINER UNE ALTERATION DES DONNEES. ***\n# *********************************************************************************




#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
#
#  DO NOT TRANSLATE MESSAGES OR TEXT BELOW THIS LINE
#
#
# ----------------------------------------------------------------------------------------------------------


