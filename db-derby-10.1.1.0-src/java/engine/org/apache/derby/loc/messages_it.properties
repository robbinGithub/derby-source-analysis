
###############################################################################
#
# Text for exceptions
#
###############################################################################

# Monitor
XBM01.D=Avvio non riuscito a causa di un'eccezione; per ulteriori dettagli consultare l'eccezione successiva.
XBM02.D=Avvio non riuscito a causa della mancata funzionalit\u00e0 di {0}. Assicurarsi che il percorso classe comprenda il software Derby corretto.
XBM05.D=Avvio non riuscito a causa della non disponibilit\u00e0 delle informazioni della versione del prodotto per {0}.
XBM06.D=Avvio non riuscito, impossibile accedere al database codificato senza la password di avvio corretta.
XBM07.D=Avvio non riuscito, la password di avvio deve avere una lunghezza di almeno 8 byte.
XBM08.D=Impossibile avviare {0} classe StorageFactory {1}.

XBM0G.D=Impossibile avviare il motore di codifica. Assicurarsi di eseguire Java 2, di aver scaricato un provider di codifica, ad esempio jce, e di averlo inserito nel percorso classe.
XBM0H.D=Impossibile creare la directory {0}.
XBM0I.D=Impossibile eliminare la directory {0}.
XBM0J.D=Directory {0} gi\u00e0 esistente.
XBM0K.D=Sotto protocollo per il nome database {0} sconosciuto.
XBM0L.D=La classe {0} specificata dello schema di autenticazione non implementa l''interfaccia di autenticazione {1}.
XBM0M.D=Errore durante la creazione dell''istanza della classe dello schema di autenticazione {0}.
XBM0N.D=Registrazione driver JDBC con java.sql.DriverManager non riuscita, per i dettagli consultare l'eccezione successiva.
XBM0P.D=Operazione non consentita, il provider di servizi \u00e8 di sola lettura.
XBM0S.D=Impossibile rinominare il file ''{0}'' in ''{1}''
XBM0T.D=Sotto protocollo ambiguo per il nome database {0}.
XBM0U.S=Nessuna classe registrata per l''identificatore {0}
XBM0V.S=\u00c8 stata generata un''eccezione durante il caricamento della classe {1}, registrata per l''identificatore {0}
XBM0W.S=\u00c8 stata generata un''eccezione durante la creazione di un''istanza della classe {1}, registrata per l''identificatore {0}
XBM0X.D=La descrizione delle impostazioni internazionali fornita ''{0}'' non \u00e8 valida; previsto ln[_CO[_variant]]\n ln=codice lingua ISO-639 di due lettere minuscole, CO=codici nazione ISO-3166 di due lettere maiuscole, consultare java.util.Locale.
XBM0Y.D=Directory del database di backup {0} non trovata. Verificare che il percorso del database di backup specificato sia corretto.
XBM0Z.D=Impossibile copiare il file ''{0}'' in ''{1}''. Verificare di disporre dello spazio necessario e delle autorizzazioni richieste. 
XBM0Q.D=File {0} non trovato. Verificare che la copia di backup sia corretta e che non sia danneggiata.
XBM0R.D=Impossibile eliminare il file {0}.

# Upgrade
XCW00.D=Aggiornamento non supportato da ''{0}'' a ''{1}''.

# Feature not supported


# COntext service
08000=Connessione chiusa a causa di un'interruzione sconosciuta.

#../java/com/ibm/db2j/protocol/BasicServices/LockManager/messages.properties
40001=Impossibile ottenere un blocco a causa di un altro blocco, ciclo di blocchi e programmi di attesa \u00e8:\n {0}La vittima selezionata \u00e8 XID : {1}

40XL1=Impossibile ottenere un blocco nel tempo richiesto
40XL2=Impossibile ottenere un blocco nel tempo richiesto.  Il dump lockTable \u00e8: {0}

# ClassManager
XBCM1.S=Errore di collegamento Java rilevato durante il caricamento della classe {0} generata.
XBCM2.S=Impossibile creare un''istanza della classe {0} generata.
XBCM3.S=Il metodo {1}() non esiste nella classe {0} generata.

# Properties

XCY00.S=Valore non valido per la propriet\u00e0 ''{0}''=''{1}''.
XCY02.S=La modifica della propriet\u00e0 richiesta non \u00e8 supportata ''{0}''=''{1}''.
XCY03.S=Propriet\u00e0 richiesta ''{0}'' non impostata.

# Cryptography
XBCX0.S=Eccezione generata dal provider Crittografia; per i dettagli consultare l'eccezione successiva.
XBCX1.S=Inizializzazione della crittografia con modalit\u00e0 non valida, \u00e8 necessario utilizzare la modalit\u00e0 ENCRYPT o DECRYPT.
XBCX2.S=Inizializzazione della crittografia con una password di avvio troppo breve, la password deve avere almeno {0} caratteri
XBCX5.S=Impossibile modificare la password di avvio in un carattere nullo.
XBCX6.S=Impossibile modificare la password di avvio in un tipo serializzabile non-string.
XBCX7.S=Formato errato per la modifica della password di avvio.  Il formato corretto \u00e8: vecchia_password_avvio, nuova_password_avvio.
XBCX8.S=Impossibile modificare la password di avvio di un database non codificato.
XBCX9.S=Impossibile modificare la password di avvio di un database di sola lettura.
XBCXA.S=Password di avvio errata.
XBCXB.S=Spaziatura interna della codifica ''{0}'' errata o non specificata. \u00c8 necessario utilizzare 'NoPadding'.
XBCXC.S=L''algoritmo di codifica ''{0}'' non esiste. Verificare che il provider ''{1}'' scelto supporti quest''algoritmo.
XBCXD.S=Impossibile modificare l'algoritmo di codifica dopo la creazione del database.
XBCXE.S=Impossibile modificare il provider di codifica dopo la creazione del database.
XBCXF.S=Impossibile trovare la classe ''{0}'' che rappresenta il provider di codifica.
XBCXG.S=Il provider di codifica ''{0}'' non esiste.
XBCXH.S=Il formato di encryptionAlgorithm ''{0}'' non \u00e8 corretto. Il formato corretto \u00e8 algorithm/feedbackMode/NoPadding.
XBCXI.S=La modalit\u00e0 commenti ''{0}'' non \u00e8 supportata. Le modalit\u00e0 commenti supportate sono CBC, CFB, OFB e ECB.
XBCXJ.S=L'applicazione sta utilizzando una versione di JCE (Java Cryptography Extension) precedente alla 1.2.1.  Aggiornare JCE 1.2.1 e ripetere l'operazione.
XBCXK.S=La chiave di cifratura fornita non corrisponde alla chiave di cifratura durante la creazione del database. Accertarsi di utilizare la chiave di cifratura appropriata e riprovare. 
XBCXL.S=Il processo di verifica per la chiave di cifratura non \u00e8 corretto, consultare l'eccezione successiva per dettagli. Le cause possibili potrebbero indicare un errore durante l'accesso al file appropriato per eseguire il processo di verifica.

#../java/com/ibm/db2j/impl/BasicServices/CacheService/Generic/messages.properties

# CacheStatementException messages
# sqlstate range: XBCA0 to XBCAZ

XBCA0.S=Impossibile creare un nuovo oggetto con la chiave {1} nella cache {0}; \u00e8 gi\u00e0 esistente.


# java/com/ibm/db2j/protocol/Database/Storage/Access/Interface.
# sqlstate range: XSAI0 to XSAIZ
XSAI2.S=Il conglomerato ({0}) richiesto non esiste.
XSAI3.S=Funzione non implementata.

# java/com/ibm/db2j/protocol/Database/Storage/Access/Interface
# RunTimeStatistics properties messages.
# sqlstate range: XSAJ0 to XSAJZ
XSAJ0.U=Tipo di scansione
XSAJ1.U=Numero di pagine visitate
XSAJ2.U=Numero di righe visitate
XSAJ3.U=Numero di righe eliminate visitate
XSAJ4.U=Numero di righe completate
XSAJ5.U=Numero di colonne lette in sequenza
XSAJ6.U=Bit impostato di colonne lette in sequenza
XSAJ7.U=Altezza albero
XSAJ8.U=Tipo di ordinamento
XSAJA.U=Numero di righe in input
XSAJB.U=Numero di righe in output
XSAJC.U=Numero di esecuzioni unione
XSAJD.U=Dimensione delle esecuzioni unione
XSAJE.U=All

#NOTE: The next three messages are the names of types of scans.
XSAJF.U=btree
XSAJG.U=heap
XSAJH.U=sort

#NOTE: The next two messages are types of sorts
XSAJI.U=esterno
XSAJJ.U=interno

# java/com/ibm/db2j/protocol/Database/Storage/Access/XA.
# sqlstate range: XSAX0 to XSAXZ
XSAX0.S=Violazione protocollo XA.
XSAX1.S=\u00c8 stato effettuato un tentativo di avvio di una transazione globale con un Xid di una transazione globale esistente.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/AccessManager/Generic
# sqlstate range: XSAM0 to XSAMZ
XSAM0.S=Eccezione riscontrata durante il tentativo di avviare il modulo per ''{0}''.
XSAM2.S=Non esistono indici o conglomerati con ID conglom ''{0}'' da eliminare.
XSAM3.S=Non esistono indici o conglomerati con ID conglom ''{0}''.
XSAM4.S=Non esiste alcun ordinamento denominato ''{0}''.
XSAM5.S=\u00c8 necessario aprire e posizionare una scansione chiamando next() prima di eseguire altre chiamate.
XSAM6.S=Il record {2} sulla pagina {1} nel contenitore {0}, non \u00e8 stato trovato.


#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/Generic
# sqlstate range: XSCG0 to XSCGZ
XSCG0.S=Impossibile creare una maschera.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/Heap
# sqlstate range: XSCH0 to XSCHZ

XSCH8.S=Funzione non implementata.
XSCH7.S=Scansione non posizionata.
XSCH6.S=Contenitore heap con ID contenitore {0} chiuso.
XSCH5.S=In una tabella di base si \u00e8 verificata una mancata corrispondenza tra il numero di colonne richiesto, {0}, e il numero massimo di colonne, {1}.
XSCH4.S=Impossibile creare il conglomerato.
XSCH1.S=Il contenitore {0} non \u00e8 stato trovato.
XSCH0.S=Impossibile creare il contenitore.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/BTree/Generic
# sqlstate range: XSCB0 to XSCBZ
XSCB9.S=Riservato per scopi di test.
XSCB8.S=Il conglomerato btree {0} \u00e8 chiuso.
XSCB7.S=\u00c8 stato riscontrato un errore interno durante una scansione btree - current_rh \u00e8 null = {0}, la chiave posizione \u00e8 null = {1}.
XSCB6.S=Limitazione: impossibile aggiornare o inserire il record di un indice secondario btree a causa della mancanza di spazio sulla pagina.  Utilizzare i parametri derby.storage.pageSize e/o derby.storage.pageReservedSpace per evitare questa limitazione.
XSCB5.S=Durante l'annullamento logico di un'operazione di inserimento o eliminazione di btree, \u00e8 impossibile trovare la riga nell'albero.
XSCB4.S=\u00c8 stato chiamato un metodo su una scansione aperta btree prima di posizionare la scansione sulla prima riga (ad esempio, non \u00e8 ancora stata effettuata alcuna chiamata next()).  Lo stato corrente della scansione \u00e8 ({0}).
XSCB3.S=Funzione non implementata.
XSCB2.S=La propriet\u00e0 richiesta {0} non \u00e8 stata trovata nell''elenco propriet\u00e0 fornito a createConglomerate() per un indice secondario btree.
XSCB1.S=Il contenitore {0} non \u00e8 stato trovato.
XSCB0.S=Impossibile creare il contenitore.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Sort/External
# sqlstate range: XSAS0 to XSASZ

XSAS6.S=Impossibile acquisire le risorse per l'ordinamento.
XSAS3.S=Il tipo di riga inserita in un ordinamento non corrisponde all relativo modello.
XSAS1.S=\u00c8 stato effettuato un tentativo di lettura in sequenza di una riga prima dell'avvio o al termine di un ordinamento.
XSAS0.S=\u00c8 stato chiamato un metodo interfaccia controller di scansione non appropriato per una scansione su un ordinamento.

# java/com/ibm/db2j/protocol/Database/Storage/RawStore/Interface.
# statement errors.
# sqlstate range: XSRS0 to XSRSZ
XSRS0.S=Impossibile bloccare il database dopo che \u00e8 gi\u00e0 stato bloccato.
XSRS1.S=Impossibile eseguire il backup del database su {0}, poich\u00e9 non \u00e8 una directory.
XSRS4.S=Errore durante la ridenominazione del file (durante il backup) da {0} a {1}.
XSRS5.S=Errore durante la copia del file (durante il backup) da {0} a {1}.
XSRS6.S=Impossibile creare la directory di backup {0}.
XSRS7.S=Il backup ha determinato un'eccezione imprevista.
XSRS8.S=L'Unit\u00e0 di log pu\u00f2 essere impostata solo durante il periodo di creazione del database e non pu\u00f2 essere modificata durante l'esecuzione.
XSRS9.S=Il record {0} non esiste pi\u00f9


# java/com/ibm/db2j/impl/Database/Storage/RawStore/Log/Generic
# statement errors.
# sqlstate range: XSLB0 to XSLBZ
XSLB9.S=Impossibile immettere ulteriori modifiche, la produzione di log \u00e8 stata arrestata.
XSLB8.S=Tentativo di ripristinare una scansione su {0}, oltre il limite di {1}.
XSLB6.S=Tentativo di registrare un Record di log di lunghezza 0 o -ve.
XSLB5.S=Classe instant truncationLWM {1} non valida per il punto di interruzione {0}. L''intervallo valido \u00e8 compreso tra  {2} e {3}.
XSLB4.S=Impossibile trovare truncationLWM {0}.
XSLB2.S=Operazione di log {0} con registrazione di dati in eccesso; buffer interno del log saturo.
XSLB1.S=L''operazione di log {0} riscontra degli errori durante la scrittura al di fuori del flusso di log; ci\u00f2 pu\u00f2 essere determinato da un''operazione di log errata o dal buffer log interno saturo a causa di un''operazione di log di dimensioni eccessive.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Log/Generic
# database errors.
# sqlstate range: XSLA0 to XSLAZ
XSLAT.D=La directory di log {0} esiste. Verificare che il percorso di logDevice specificato sia corretto.  
XSLAS.D=Directory di log {0} non trovata nella copia di backup durante il ripristino. Verificare che la copia di backup sia corretta e che non sia danneggiata.
XSLAR.D=Impossibile copiare il file di log ''{0}'' in ''{1}'' durante il ripristino. Verificare di disporre dello spazio necessario e delle autorizzazioni richieste. 
XSLAQ.D=Impossibile creare il file di log sulla directory {0}.
XSLAP.D=La versione del database su {0} \u00e8 {1}. Le versioni beta dei database non possono essere aggiornate.
XSLAO.D=Ripristino del problema imprevisto {0} non riuscito.
XSLAN.D=Il database su {0} dispone di un formato non compatibile con la versione corrente del software.  Il database \u00e8 stato creato o aggiornato tramite la versione {1}.
XSLAM.D=Impossibile verificare il formato del database su {1} a causa di IOException.
XSLAL.D=La dimensione del record di log {2} ha superato la dimensione massima consentita {3}. Errore riscontrato nel file di log {0}, posizione {1}
XSLAK.D=Il database ha superato il numero massimo di file di log {0}.
XSLAJ.D=Il sistema di registrazione \u00e8 stato contrassegnato per l'arresto a causa di un problema precedente e non consentir\u00e0 di eseguire altre operazioni fino a quando il sistema non verr\u00e0 arrestato e riavviato.
XSLAI.D=Impossibile registrare il record di log dei controlli
XSLAH.D=Database di sola lettura in fase di aggiornamento.
XSLAF.D=Database di sola lettura creato con buffer dati danneggiati.
XSLAE.D=Impossibile scrivere o aggiornare il file di controllo su {0}.
XSLAD.D=Record di log nella classe instant {2} nel file di log {3} corrotto. Lunghezza prevista record di log {0}, lunghezza effettiva {1}.
XSLAC.D=Il database su {0} dispone di un formato non compatibile con la versione corrente del software; \u00e8 possibile che sia stato creato o aggiornato con una versione successiva.
XSLAB.D=Impossibile trovare il file di log {0}, assicurarsi che la propriet\u00e0 logDevice sia impostata correttamente con l''adeguato separatore di percorso compatibile con la piattaforma utilizzata.
XSLAA.D=La memoria \u00e8 stata contrassegnata per l'arresto da un'eccezione precedente.
XSLA8.D=Impossibile eseguire il rollback della transazione {0}; tentativo di compensare l''operazione {1} con {2}
XSLA7.D=Impossibile ripetere l''operazione {0} nel log.
XSLA6.D=Impossibile ripristinare il database.
XSLA5.D=Impossibile leggere il flusso di log per eseguire il rollback della transazione {0}.
XSLA4.D=Impossibile scrivere sul log, probabilmente il log \u00e8 pieno.  Eliminare i file inutili.  Inoltre, \u00e8 possibile che il  file system sia di sola lettura, che il disco presenti degli errori o che si siano verificati dei problemi con i supporti.
XSLA3.D=Log corrotto, dati non validi presenti nel flusso di log.
XSLA2.D=Il sistema verr\u00e0 arrestato, rilevata eccezione I/O durante l'accesso al file di log.
XSLA1.D=Record di log inviato al flusso ma non applicabile alla memoria (Oggetto {0}).  Ci\u00f2 pu\u00f2 causare dei problemi di ripristino.
XSLA0.D=Impossibile scaricare il file di log sul disco {0}.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# statement errors.
# sqlstate range: XSTA0 to XSTAZ
# changed XSTA0 and XSTA1 to match DB2 sqlstates - bug 4466
3B501.S=SAVEPOINT con il nome inoltrato gi\u00e0 esistente nella transazione corrente.
3B502.S=\u00c8 stato specificato RELEASE or ROLLBACK TO SAVEPOINT, ma il savepoint non esiste.
3B001.S=SAVEPOINT, {0} non esistente o non attivo nella transazione corrente.
3B002.S=E' stato raggiunto il numero massimo di savepoint. 
XSTA2.S=Una transazione era gi\u00e0 attiva, durante il tentativo di attivarne un'altra.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# transaction errors.
# sqlstate range: 40XT0 to 40XTZ
40XT0=\u00c8 stato identificato un errore interno dal modulo RawStore.
40XT1=Si \u00e8 verificata un'eccezione durante l'operazione di commit della transazione.
40XT2=Si \u00e8 verificata un'eccezione durante l'operazione di rollback di SAVEPOINT.
40XT4=\u00c8 stato effettuato un tentativo di chiudere una transazione ancora attiva, la transazione \u00e8 stata interrotta.
40XT5=Si \u00e8 verificata un'eccezione durante una transazione interna.
40XT6=Il database si trova in stato inattivo, impossibile attivare la transazione.  Attendere uscita dallo stato inattivo.
40XT7=Operazione non supportata in una transazione interna.

#
#java/com/ibm/db2j/internalUtil
#	Id Parse Errors       			XCXA0-XCXAZ
#  	Db Class Path Parse Errors 	 	XCXB0-XCXBZ
# 	Id List Parse Errors			XCXC0-XCXCZ
#  	IO Errors						XCXD0-XCXDZ
#	LocaleFinder Errors				XCXE0-XCXEZ
XCXA0.S=Identificatore non valido.
XCXB0.S=Percorso classe database non valido: ''{0}''.
XCXC0.S=Elenco ID non valido.
XCXE0.S=Si sta tentando di eseguire un'operazione che utilizza le impostazioni internazionali del database, che non sono ancora state impostate.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# system errors.
# sqlstate range: XSTB0 to XSTBZ
XSTB0.M=Si \u00e8 verificata un'eccezione durante l'interruzione della transazione.
XSTB2.M=Impossibile registrare le modifiche della transazione, probabilmente si \u00e8 tentato di effettuare la scrittura su un database di sola lettura.
XSTB3.M=Impossibile interrompere la transazione poich\u00e9 il gestore log \u00e8 nullo, probabilmente a causa di un errore precedente.
XSTB5.M=\u00c8 stato riscontrato un errore imprevisto durante il tentativo di creare un database con la registrazione disattivata.
XSTB6.M=Impossibile sostituire una tabella transazioni con un'altra quando una \u00e8 gi\u00e0 in uso.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# transaction errors.
# sqlstate range: 40XD0 to 40XDZ
40XD0=Il contenitore \u00e8 stato chiuso
40XD1=Il contenitore \u00e8 stato aperto in modalit\u00e0 sola lettura
40XD2=Impossibile aprire il contenitore {0}, \u00e8 stato eliminato oppure non esiste


# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# statement errors.
# sqlstate range: XSDA0 to XSDAZ
XSDA1.S=\u00c8 stato effettuato un tentativo di accedere ad uno slot fuori intervallo su una pagina
XSDA2.S=\u00c8 stato effettuato un tentativo di aggiornare un record eliminato
XSDA3.S=Limitazione: impossibile aggiornare o inserire un record a causa della mancanza di spazio sulla pagina. Utilizzare i parametri derby.storage.pageSize e/o derby.storage.pageReservedSpace per evitare questa limitazione.
XSDA4.S=Si \u00e8 verificata un'eccezione imprevista
XSDA5.S=\u00c8 stato effettuato un tentativo di annullare l'eliminazione di un record non eliminato.
XSDA6.S=La colonna {0} della riga \u00e8 nulla, \u00e8 necessario impostarla per puntare a un oggetto.
XSDA7.S=Ripristino di un oggetto serializzabile o SQLData della classe {0}; tentativo di leggere una quantit\u00e0 di dati maggiore di quelli memorizzati
XSDA8.S=Eccezione durante il ripristino di un oggetto serializzabile o SQLData della classe {0}
XSDA9.S=Classe non trovata durante il ripristino di un oggetto serializzabile o SQLData della classe {0}
XSDAA.S=Data/ora {0} non valida, \u00e8 possibile che provenga da una pagina differente o da un''implementazione non compatibile
XSDAB.S=impossibile impostare una data/ora nulla
XSDAC.S=Tentativo di spostare le righe o le pagine da un contenitore ad un altro.
XSDAD.S=Tentativo di spostare zero righe da una pagina all'altra.
XSDAE.S=\u00c8 possibile eseguire un handle di record solo per un ID handle di record speciale
XSDAF.S=Uso di un handle di record speciale come se fosse normale.
XSDAG.S=Impossibile aprire il contenitore durante l'esecuzione di una transazione interna nidificata che alloca ulteriore spazio a una tabella.
XSDAI.S=La pagina {0} da eliminare \u00e8 gi\u00e0 bloccata per il rilascio.
XSDAJ.S=Eccezione durante la scrittura di un oggetto serializzabile o SQLData
XSDAK.S=Pagina errata richiamata per l''handle di record {0}.
XSDAL.S=L''handle di record {0} punta inaspettatamente alla pagina di overflow.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# database errors.
# sqlstate range: XSDB0 to XSDBZ
XSDB0.D=Eccezione imprevista sulla pagina in-memoria {0}
XSDB1.D=Formato pagina sconosciuto alla pagina {0}
XSDB2.D=Formato contenitore sconosciuto nel contenitore {0} : {1}
XSDB3.D=Impossibile modificare le informazioni sul contenitore una volta scritte: erano {0}, ora sono {1}
XSDB4.D=La pagina {0} si trova sulla versione {1}, il file di log contiene la versione modificata {2}, oppure esistono dei record di log mancanti di questa pagina, o questa pagina non \u00e8 stata scritta in modo corretto sul disco.
XSDB5.D=Il log contiene record modifiche sulla pagina {0}, oltre il limite del contenitore.
XSDB6.D=Un''altra istanza di Derby potrebbe avere avviato il database {0}.
XSDB7.D=AVVERTENZA: Derby (istanza {0}) sta tentando di avviare il database {1} anche se Derby (istanza {2}) potrebbe essere ancora attivo.  Solo un'istanza alla volta di Derby deve avviare un database. Ci\u00f2 pu\u00f2 determinare un errore grave o irreversibile, oppure tale errore potrebbe essersi gi\u00e0 verificato.
XSDB8.D=AVVERTENZA: Derby (istanza {0}) sta tentando di avviare il database {1} anche se Derby (istanza {2}) potrebbe essere ancora attivo.  Solo un'istanza alla volta di Derby deve avviare un database. Ci\u00f2 pu\u00f2 determinare un errore grave o irreversibile se due istanze di Derby avviano lo stesso database contemporaneamente.  La propriet\u00e0 db2j.database.forceDatabaseLock=true \u00e8 stata impostata, quindi il database non verr\u00e0 avviato finch\u00e9 db.lck non \u00e8 presente.  Solitamente questo file viene eliminato alla chiusura della prima istanza di Derby che avvia il database, ma in alcune occasioni la chiusura non elimina tale file.  Quindi, dovr\u00e0 essere eliminato manualmente.  \u00c8 importante verificare che nessun altro VM acceda al database prima di eliminare il file db.lck manualmente.
XSDB9.D=Il contenitore di flusso {0} \u00e8 corrotto.
XSDBA.D=Tentativo di assegnare l''oggetto {0} non riuscito.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/FileSystem
# statment errors.
# sqlstate range: XSDF0 to XSDFZ
XSDF0.S=Impossibile creare il file {0} poich\u00e9 gi\u00e0 esistente.
XSDF1.S=Eccezione durante la creazione del file {0} per il contenitore
XSDF2.S=Eccezione durante la creazione del file {0} per il contenitore, impossibile eliminare il file.  L''eccezione era: {1}.
XSDF3.S=Impossibile creare il segmento {0}.
XSDF4.S=Eccezione durante la rimozione del file {0} per il contenitore rilasciato; impossibile eliminare il file {1}.
XSDF6.S=Impossibile trovare la pagina di allocazione {0}.
XSDF7.S=Non \u00e8 stato possibile bloccare la pagina appena creata {0}
XSDF8.S=Impossibile trovare la pagina {0} da riutilizzare.
XSDFB.S=Operazione non supportata da un database di sola lettura
XSDFD.S=Lettura immagini pagine differenti su 2 I/Os sulla Pagina {0}, la prima immagine ha un checksum errato, la seconda ha un checksum corretto. Di seguito vengono riportate le immagini delle pagine: {1} {2}
XSDFF.S=Operazione richiesta non riuscita a causa di un'eccezione imprevista.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/FileSystem
# database errors.
# sqlstate range: XSDG0 to XSDGZ
XSDG0.D=Impossibile leggere la pagina {0} dal disco.
XSDG1.D=Impossibile scrivere la pagina {0} sul disco, controllare se il disco \u00e8 pieno.
XSDG2.D=Checksum non valido sulla Pagina {0}, previsto={1}, versione su disco={2}, segue dump di pagina: {3}
XSDG3.D=Impossibile accedere ai metadati per il Contenitore {0}
XSDG5.D=Il database non si trova in modalit\u00e0 di creazione quando viene chiamato createFinished.
XSDG6.D=Directory di segmenti di dati non trovata nella copia di backup {0} durante il ripristino. Verificare che la copia di backup sia corretta e che non sia danneggiata.
XSDG7.D=Impossibile eliminare la directory {0} durante il ripristino. Verificare di disporre delle autorizzazioni richieste per la directory.
XSDG8.D=Impossibile copiare la directory ''{0}'' in ''{1}'' durante il ripristino. Verificare di disporre dello spazio necessario e delle autorizzazioni richieste. 

# language
01500=La restrizione {0} sulla tabella {1} \u00e8 stata eliminata.
01501=La vista {0} \u00e8 stata eliminata.
01502=Il trigger {0} sulla tabella {1} \u00e8 stato eliminato.
01503=La colonna {0} sulla tabella {1} \u00e8 stata modificata aggiungendo una restrizione non nulla.
01504=Il nuovo indice \u00e8 un duplicato di uno esistente: {0}.
01505=Il valore {0} potr\u00e0 essere interrotto.
01003=I valori nulli sono stati eliminati dall'argomento di una funzione della colonna.
0100E=XX Tentativo di restituire un numero eccessivo di insiemi di risultati
02000=Nessuna riga \u00e8 stata trovata per FETCH, UPDATE o DELETE; o il risultato di una query \u00e8 una tabella vuota.
21000=La query secondaria scalare pu\u00f2 restituire solo una riga singola.
22001=\u00c8 stato riscontrato un errore di interruzione durante il tentativo di abbassare {0} ''{1}'' alla lunghezza di {2}.
54006=La lunghezza proveniente dall'operazione {0} \u00e8 superiore a {1}.
22003=Il valore derivante \u00e8 esterno all'intervallo per il tipo di dati {0}.
22005=\u00c8 stato effettuato un tentativo di ottenere un valore dati di tipo ''{0}'' da uno di tipo ''{1}''.
22007.S.180=La rappresentazione della stringa di un valore datetime \u00e8 esterno all'intervallo.
22007.S.181=La sintassi della rappresentazione della stringa di un valore datetime non \u00e8 corretto.
22011=Il secondo o il terzo argomento della funzione SUBSTR \u00e8 esterno all'intervallo.
22012=Tentativo di dividere per zero.
22013=Tentativo di ottenere la radice quadrata di un numero negativo, ''{0}''.
22014=La posizione iniziale di LOCATE non \u00e8 valida; \u00e8 necessario che sia un numero intero positivo.  L''indice da cui iniziare la ricerca \u00e8 ''{2}''.  La stringa da ricercare \u00e8 ''{0}''.  La stringa da cui effettuare la ricerca \u00e8 ''{1}''. 
22015=La funzione ''{0}'' non \u00e8 consentita sul seguente insieme di tipi.  Il primo operando \u00e8 di tipo ''{1}''.  Il secondo \u00e8 di tipo ''{2}''.  Il terzo operando (posizione iniziale) \u00e8 di tipo ''{3}''.
22018=Formato stringa del carattere errato per il tipo {0}.
22019=Sequenza escape non valida, ''{0}''. La stringa escape deve essere esattamente un carattere. Non pu\u00f2 essere vuota o contenere pi\u00f9 di un carattere.
22025=Il carattere escape deve essere seguito da un carattere escape, '_', o '%'. Non pu\u00f2 essere seguito da altri caratteri o trovarsi alla fine del modello.
22027=La funzione integrata TRIM() consente di eliminare un solo carattere.  Le funzioni integrate LTRIM() e RTRIM() consentono di eliminare pi\u00f9 caratteri.
22500=Impossibile utilizzare i parametri ? per il modello LIKE e la clausola ESCAPE.
22501=Una clausola ESCAPE di NULL restituisce risultati non definiti e non \u00e8 consentita.
23502=La colonna ''{0}'' non pu\u00f2 accettare un valore NULL.
23505=L''isruzione \u00e8 stata interrotta poich\u00e9 potrebbe aver causato un valore di chiave duplicata in una restrizione di chiave univoca o primaria i indice univoco or identificato da ''{0}'' definito su ''{1}''.
23503={2} sulla tabella ''{1}'' ha causato una violazione della restrizione di chiave esterna ''{0}'' per la chiave {3}.  L'istruzione \u00e8 stata sottoposta a rollback.
23513=La restrizione di controllo ''{1}'' \u00e8 stata violata durante l''esecuzione di INSERT o UPDATE sulla tabella ''{0}''.
38000=\u00c8 stata riscontrata l''eccezione ''{0}'' durante la valutazione di un''espressione.
38001=La routine esterna non pu\u00f2 eseguire le istruzioni SQL.
38002=La routine ha tentato di modificare i dati, ma non era definita come MODIFIES SQL DATA.
38004=La routine ha tentato di leggere i dati, ma non era definita come READS SQL DATA.
39004=Un valore NULL non pu\u00f2 essere inoltrato ad un metodo che utilizza un parametro di tipo primitivo ''{0}''.
40XC0=Istruzione inattiva. Pu\u00f2 essere causato dal rilevamento di un errore di gravit\u00e0 della transazione all'interno di tale istruzione.
# this error is retired in 1.3
42000=Errore di sintassi o violazione della regola di accesso; per i dettagli, vedere ulteriori errori.

# DB2 error for max length violation by char, varchar and long varchar. In future, this error message will be used for other purposes too
42601=Nell''istruzione ALTER TABLE, la colonna ''{0}'' \u00e8 stata specificata come NOT NULL e la clausola DEFAULT non \u00e8 stata specificata o \u00e8 stata specificata come DEFAULT NULL.
42601.S.372=L'istruzione ALTER TABLE non pu\u00f2 aggiungere una colonna IDENTITY ad una tabella. 
42606=Una costante esadecimale errata che inizia con ''{0}'' \u00e8 stata rilevata.
54002=Una costante di stringa che inizia con ''{0}'' \u00e8 troppo lunga.
42611=L''attributo di lunghezza, precisione o di scala per la colonna o il mapping del tipo ''{0}'' non \u00e8 valido. 

42605=Il numero di argomenti per la funzione ''{0}'' non \u00e8 corretto.
42610=Tutti gli argomenti alla funzione COALESC/VALUE non possono essere parametri. E' necessario disporre almeno di un argomento diverso dal parametro.

42613=La clausola ''{0}'' contiene molte parole chiave o parole chiave in conflitto.
42621=Una restrizione di verifica o una colonna generata definita con ''{0}'' non \u00e8 valida.
42734=Il nome ''{0}'' specificato nel contesto ''{1}'' non \u00e8 univoco.
# DB2 error for invalid set schema
42802=Il numero di valori assegnato non coincide con il numero delle colonne specificate.
42815.S.713=Il valore di sostituzione per ''{0}'' non \u00e8 valido.
42815.S.171=La lunghezza, il tipo di dati o il valore di argomenti ''{0}'' e ''{1}'' non \u00e8 compatibile.
42820=Il valore letterale mobile ''{0}'' contiene pi\u00f9 di 30 caratteri.
42824=Un operando di LIKE non \u00e8 una stringa oppure il primo operando non \u00e8 una colonna.
42831=''{0}'' non pu\u00f2 essere una colonna di una chiave univoca o primaria poich\u00e9 non pu\u00f2 contenere valori nulli.
42834=Impossibile specificare SET NULL poich\u00e9 FOREIGN KEY ''{0}'' non pu\u00f2 contenere valori nulli.  
42884=Non \u00e8 stata trovata nessuna routine autorizzata denominata ''{0}'' di tipo ''{1}'' contenente argomenti compatibili.
42886=''{0}'' parametro ''{1}'' richiede un indicatore di parametro ''?''.
42894=Il valore DEFAULT o il valore di attributo IDENTITY non \u00e8 valido per la colonna ''{0}''.
428C1=In una tabella \u00e8 consentita solo una colonna di identit\u00e0.
42903=Utilizzo errato di una funzione aggregata.
42908=L'istruzione CREATE VIEW non include un elenco di colonna.
42915=La chiave esterna ''{0}'' non \u00e8 valida a causa di ''{1}''. 
42972=Una clausola ON associata ad un operatore JOIN non \u00e8 valida.
42X01=Errore di sintassi: {0}.
42X02={0}.
42X03=Il nome colonna ''{0}'' si trova in pi\u00f9 di una tabella presente nell''elenco FROM.
42X04=La colonna ''{0}'' non si trova in una tabella nell''elenco FROM, oppure compare in una specifica di collegamento ed \u00e8 esterna all''ambito di tale specifica, oppure compare in una clausola HAVING e non nell''elenco GROUP BY.  Se si tratta di un''istruzione CREATE o ALTER TABLE, ''{0}'' non \u00e8 una colonna della tabella di destinazione.
42X05=La tabella ''{0}'' non esiste.
42X06=Sono state specificate troppe colonne di risultati per la tabella ''{0}''.
42X07=Il carattere nullo \u00e8 consentito solo in una clausola VALUES all'interno di un'istruzione INSERT.
42X08=Il costruttore della classe ''{0}'' non pu\u00f2 essere utilizzato come una tabella virtuale esterna se la classe non implementa ''{1}''.
42X09=Il nome tabella o alias ''{0}'' \u00e8 stato utilizzato pi\u00f9 di una volta nell''elenco FROM.
42X10=''{0}'' non \u00e8 un nome tabella esposto nell''ambito in cui viene visualizzato.
42622=Il nome ''{0}'' \u00e8 troppo lungo. La lunghezza massima \u00e8 ''{1}''.
42X12=Il nome colonna ''{0}'' compare pi\u00f9 di una volta nell''istruzione di creazione tabella.
54011=Sono state specificate molte colonne ({0}) per la tabella o vista {1}. Il limite \u00e8 {2}.
42Z9F=Molti indici ({0}) nella tabella {1}. Il limite \u00e8 {2}.
42X13=Il nome colonna ''{0}'' compare pi\u00f9 di una volta nell''elenco di colonne di un''istruzione di inserimento.
42X14=''{0}'' non \u00e8 una colonna nella tabella o VTI ''{1}''.
42X15=Il nome colonna ''{0}'' compare in un''istruzione senza un elenco FROM.
42X16=Il nome colonna ''{0}'' compare pi\u00f9 volte nella clausola SET di un''istruzione di aggiornamento.
42X17=Il valore ''{0}'' non \u00e8 valido come specifica joinOrder nell''elenco Propriet\u00e0 di una clausola FROM. Solo i valori  FIXED e UNFIXED sono validi.
42803=Un''espressione che contiene la colonna ''{0}'' viene visualizzata nell''elenco SELECT e non \u00e8 parte di una clausola GROUP BY.
42818=I paragoni tra ''{0}'' e ''{1}'' non sono supportati.
42X19=La clausola WHERE o HAVING, o la definizione CHECK CONSTRAINT \u00e8 un''espressione ''{0}''.  Deve essere un'espressione BOOLEAN.
42X23=Il cursore {0} non \u00e8 aggiornabile.
#42X24=The unary ''-'' operator is not allowed on the ''{0}'' type.
42X25=La funzione ''{0}'' non \u00e8 consentita sul tipo ''{1}''.
42X26=La classe ''{0}'' della colonna ''{1}'' non esiste o non \u00e8 possibile accedervi. Ci\u00f2 pu\u00f2 verificarsi se la classe non \u00e8 pubblica.
42X28=Elimina tabella ''{0}'' non \u00e8 la destinazione del cursore ''{1}''.
42X29=Aggiorna tabella ''{0}'' non \u00e8 la destinazione del cursore ''{1}''.
42X30=Cursore ''{0}'' non trovato. Verificare che l'autocommit sia in modalit\u00e0 OFF.
42X31=La colonna ''{0}'' non si trova nell''elenco FOR UPDATE del cursore ''{1}''.
42X32=Il numero di colonne presenti nell''elenco di colonne derivate deve corrispondere al numero di colonne presenti nella tabella ''{0}''.
42X33=L''elenco di colonne derivate contiene un nome colonne duplicato ''{0}''.
42X34=Esiste un parametro ? nell'elenco di selezione.  Ci\u00f2 non \u00e8 consentito.
42X35=Non \u00e8 consentito che entrambi gli operandi di ''{0}'' siano parametri ?.
42X36=L''operatore ''{0}'' non pu\u00f2 assumere un parametro ? come operando.
42X37=Operatore unario ''{0}'' non consentito sul tipo ''{1}''.
42X38='SELECT *' \u00e8 consentito solo nelle query secondarie EXISTS e NOT EXISTS.
42X39=La query secondaria non pu\u00f2 restituire una colonna singola.
42X40=NOT possiede un operando diverso dal valore booleano. L'operando di NOT deve essere valutato su TRUE, FALSE o UNKNOWN.
42X41=La propriet\u00e0 ''{0}'' non \u00e8 valida nella clausola Properties di un elenco FROM (la propriet\u00e0 era stata impostata su ''{1}'').
42821=Le colonne di tipo ''{0}'' non possono contenere valori di tipo ''{1}''. 
42X43=ResultSetMetaData restituito per classe/oggetto ''{0}'' era nullo. Per utilizzare questa classe come una tabella virtuale esterna, \u00e8 necessario che ResultSetMetaData non sia un valore nullo.
42X44=Lunghezza ''{0}'' non valida come specifica di colonna.
# 42X45=
# 42X46=
# 42X47=
42X48=Il valore ''{1}'' non rappresenta una precisione valida per {0}.
42X49=Il valore ''{0}'' non \u00e8 un valore letterale intero valido.
42X50=Non \u00e8 stato trovato nessun metodo corrispondente alla chiamata del metodo {0}.{1}({2}), sono state tentate tutte le combinazioni di tipi oggetti e di primitive e qualsiasi conversione di tipo possibile per tutti i parametri che la chiamata al metodo pu\u00f2 assumere.  \u00c8 possibile che il metodo esista ma che non sia public e/o static, oppure che i tipi di parametri non siano convertibili in chiamate a metodi.
42X51=La classe ''{0}'' non esiste o non \u00e8 accessibile. Ci\u00f2 pu\u00f2 verificarsi se la classe non \u00e8 pubblica.
42X52=La chiamata al metodo (''{0}'') tramite un destinatario di tipo primitiva Java ''{1}" non \u00e8 consentita.
42X53=Il predicato LIKE pu\u00f2 avere solo operandi 'CHAR' o 'VARCHAR'. Il tipo ''{0}'' non \u00e8 consentito.
42X54=Il metodo Java ''{0}'' ha un ? come destinatario.  Ci\u00f2 non \u00e8 consentito.
42X55=Il nome tabella ''{1}'' deve essere ''{0}''.
42X56=Il numero di colonne presenti nell''elenco colonne vista non corrisponde al numero di colonne presenti nell''espressione query sottostante, nella definizione della vista per ''{0}''.
42X57=getColumnCount() per la tabella virtuale esterna ''{0}'' ha restituito un valore ''{1}'' non valido.  I valori validi sono >= 1.
42X58=Il numero di colonne presenti sul lato destro e sinistro di UNION deve essere uguale.
42X59=Il numero di colonne presenti in ogni costruttore VALUES deve essere uguale.
42X60=Valore ''{0}'' non valido per la propriet\u00e0 insertMode specificata per la tabella ''{1}''.
42X61=I tipi ''{0}'' e ''{1}'' non sono compatibili con UNION.
42X62=''{0}'' non consentito nello schema ''{1}''.
42X63=La clausola USING non ha restituito alcun risultato, impossibile impostare alcun parametro.
42X64=Valore ''{0}'' non valido specificato per la propriet\u00e0 useStatistics nell''elenco Propriet\u00e0. TRUE o FALSE sono gli unici valori validi.
42X65=L''indice ''{0}'' non esiste.
42X66=Il nome colonna ''{0}'' compare pi\u00f9 di una volta nell''istruzione di creazione indice.
42X68=Non \u00e8 stato trovato nessun campo ''{0}'' che appartiene alla classe ''{1}''.  \u00c8 possibile che il campo esista ma che la classe non esista o non sia pubblica.
42X69=Non \u00e8 consentito fare riferimento ad un campo (''{0}'') tramite un''espressione di riferimento del tipo primitivo  Java ''{1}''.
42X72=Non \u00e8 stato trovato nessun campo statico ''{0}'' che appartiene alla classe ''{1}''.  \u00c8 possibile che il campo esista ma non sia pubblico e/o statico, oppure che la classe non esista o non sia pubblica.
42X73=Risoluzione del metodo per la firma {0}.{1}({2}) era ambigua. (Il metodo specifico esistente non \u00e8 unico.)
42X74=Sintassi dell'istruzione CALL non valida.
42X75=Non \u00e8 stato trovato nessun costruttore con firma {0}({1}).  \u00c8 possibile che i tipi di parametri non siano convertibili in chiamate a metodi.
42X76=Almeno una colonna, ''{0}'', nella chiave primaria aggiunta \u00e8 annullabile. Tutte le colonne presenti in una chiave primaria non devono essere annullabili.
42X77=La posizione della colonna ''{0}'' non \u00e8 compresa nell''intervallo per l''espressione query.
42X78=La colonna ''{0}'' non \u00e8 presente nel risultato dell''espressione della query.
42X79=Il nome colonna ''{0}'' compare pi\u00f9 di una volta nel risultato dell''espressione della query.
42877=Un nome colonna qualificato ''{0}'' non \u00e8 consentito nella clausola ORDER BY.
42X80=La clausola VALUES deve contenere almeno un elemento e tutti gli elementi non devono essere vuoti.
42X82=La clausola USING ha restituito pi\u00f9 di una riga, sono consentite solo ResultSet di righe singole.
42X83=Le restrizioni sulla colonna ''{0}'' richiedono che sia contemporaneamente annullabile e non  annullabile.
42X84=\u00c8 stato creato l''indice ''{0}'' per applicare la restrizione ''{1}''.  \u00c8 possibile eliminarlo solo annullando la restrizione.
42X85=Il vincolo ''{0}''deve essere contenuto nello stesso schema della tabella ''{1}''.
42X86=Tabella ALTER non riuscita. La restrizione ''{0}'' non esiste sulla tabella ''{1}''.
42X87=Almeno un''espressione di risultato (then o else) dell''espressione ''{0}''  deve essere diversa da ''?''.
42X88=Un'espressione Conditional ha un operando non booleano. L'operando di Conditional deve essere valutato come TRUE, FALSE o UNKNOWN.
42X89=I tipi ''{0}'' e ''{1}'' non sono tipi compatibili. (Nessun tipo \u00e8 assegnabile all'altro tipo).
42X90=Pi\u00f9 di una restrizione della chiava primaria specificata per la tabella ''{0}''.
42X91=Il nome restrizione ''{0}'' compare pi\u00f9 di una volta nell''istruzione di creazione della tabella.
42X92=Il nome colonna ''{0}'' compare pi\u00f9 di una volta nell''elenco colonne della restrizione.
42X93=La tabella ''{0}'' contiene una definizione restrizione con la colonna ''{1}'', che non \u00e8 presente nella tabella.
42Z93=Le restrizioni ''{0}'' e ''{1}'' possiedono lo stesso insieme di colonne e ci\u00f2 non \u00e8 consentito.
42Z96=VTI in lettura-scrittura non sono supportati in ambienti JDK 1.1/JDBC 1.2: ''{0}''
42Z9B=L''interfaccia della tabella virtuale esterna non supporta le colonne blob o clob. ''{0}'' colonna ''{1}''.
42Z9D=Le istruzioni ''{0}'' non sono consentite nei trigger ''{1}''.
42Z9E=La restrizione ''{0}'' non \u00e8 una restrizione {1}.
42X94={0} ''{1}'' non esiste.
42X96=Il percorso classe database contiene un file jar sconosciuto ''{0}''.
42X98=I parametri non sono consentiti in una definizione VIEW.
42Y00=La classe ''{0}'' non implementa org.apache.derby.iapi.db.AggregateDefinition e quindi non pu\u00f2 essere utilizzata come un''espressione di aggregazione.
42Y01=La restrizione ''{0}'' non \u00e8 valida.
42Y03=''{0}'' non \u00e8 riconosciuto come funzione o procedura.

# EXTERNAL NAME is SQL keyword - do not translate
42Y04=Impossibile creare una procedura o funzione con EXTERNAL NAME ''{0}'' poich\u00e9 non \u00e8 un elenco separato. Il formato previsto \u00e8 <percorso java completo>.<nome metodo> .

42Y05=Non esiste alcuna Chiave esterna denominata ''{0}''.
42Y07=Lo schema ''{0}'' non esiste
42Y08=Le restrizioni della chiave esterna non sono consentite sulle tabelle di sistema.
42Y09=I metodi Void sono i soli consentiti all'interno di un'istruzione CALL.
42Y10=Un costruttore tabelle, che non \u00e8 presente in un'istruzione INSERT, possiede tutti i parametri? in una delle relative colonne.  Almeno una riga per ogni colonna deve possedere un non-parametro.
42Y11=Con la clausola ''{0}'' \u00e8 necessaria una specifica di collegamento.
42Y12=La clausola ON di una specifica JOIN \u00e8 un''espressione ''{0}''.  Deve essere un'espressione BOOLEAN.
42Y13=Il nome colonna ''{0}'' compare pi\u00f9 di una volta nell''istruzione di creazione vista.
42Z97=La ridenominazione della colonna ''{0}'' causer\u00e0 l''interruzione della restrizione di controllo ''{1}''.
42Z99=I valori letterali di stringa o esadecimali, non possono superare i 64K.
42Y16=Non \u00e8 stato trovato nessun metodo statico pubblico ''{0}'' nella classe ''{1}''.  \u00c8 possibile che il metodo esista ma non sia public, oppure non sia static.
42846=Impossibile convertire i tipi ''{0}'' in ''{1}''.
42Y19=''{0}'' compare pi\u00f9 volte nell''elenco GROUP BY. Le colonne nell''elenco GROUP BY non devono essere ambigue.
42Y22=L''aggregazione {0} non pu\u00f2 funzionare sul tipo {1}.
42Y23=Informazioni sul tipo JDBC restituite per la colonna {0} non corrette.
42Y24=La vista ''{0}'' non \u00e8 aggiornabile. (Le viste non sono aggiornabili.)
42Y25=''{0}'' \u00e8 una tabella di sistema.  Gli utenti non possono modificare i contenuti di tale tabella.
#42Y26=Parameters are not allowed in the WHEN clause of a trigger.
42Y27=I parametri non sono consentiti nell'azione del trigger.
42Y29=L'elenco SELECT di una query non raggruppata contiene almeno 1 espressione non valida.  Quando un elenco SELECT contiene almeno 1 aggregazione, tutte le voci devono essere espressioni di aggregazioni valide.
42Y30=L'elenco SELECT di una query raggruppata contiene almeno 1 espressione non valida.  Per un elenco SELECT con GROUP BY, l'elenco SELECT pu\u00f2 contenere solo colonne di raggruppamento ed espressioni di aggregazioni valide.
42Y32=La classe aggregatore ''{0}'' per l''aggregazione ''{1}'' sul tipo {2} non implementa com.ibm.db2j.aggregates.Aggregator. 
42Y33=L''aggregazione {0} contiene una o pi\u00f9 aggregazioni.
42Y34=Il nome colonna ''{0}'' corrisponde a pi\u00f9 di una colonna di risultati presenti nella tabella ''{1}''.
42Y35=Il riferimento colonna ''{0}'' non \u00e8 valido. Quando un elenco SELECT contiene almeno 1 aggregazione, tutte le voci devono essere espressioni di aggregazioni valide.
42Y36=Il riferimento colonna ''{0}'' non \u00e8 valido.  Per un elenco SELECT con GROUP BY, l'elenco SELECT pu\u00f2 contenere solo colonne di raggruppamento ed espressioni di aggregazioni valide.
42Y37=''{0}'' \u00e8 un tipo di primitiva Java e non pu\u00f2 essere utilizzata con questo operatore.
42Y38=insertMode = la sostituzione non \u00e8 consentita su un inserimento dove la tabella di destinazione, ''{0}'', viene presa come riferimento in SELECT.
# NOTE: The parameter to this message is a keyword used as a noun phrase.
# Some possible values are "subquery", "CurrentDate", and "?".
42Y39=''{0}'' non compare in una definizione CHECK CONSTRAINT poich\u00e9 potrebbe restituire dei risultati non deterministici.
42Y40=''{0}'' compare pi\u00f9 volte nell''elenco colonne UPDATE OF per il trigger ''{1}''.
42Y41=Impossibile richiamare direttamente ''{0}'' tramite EXECUTE STATEMENT poich\u00e9 fa parte di un trigger.
42Y42=La scala ''{1}'' non \u00e8 valida per {0}.
42Y43=La scala ''{0}'' non \u00e8 valida con precisione di ''{1}''.
42Y44=Chiave, ''{0}'', non valida specificata nell''elenco Propriet\u00e0 nell''elenco FROM. Le chiavi con distinzione tra maiuscole e minuscole supportate attualmente sono ''{1}''.
42Y45=Impossibile collegare VTI ''{0}'' poich\u00e9 \u00e8 un VTI trigger speciale e questa istruzione non fa parte di un''azione del trigger o della clausola WHEN.
42Y46=Elenco Propriet\u00e0 non valido nell'elenco FROM.  Non esiste alcun indice ''{0}'' sulla tabella ''{1}''.
42Y48=Elenco Propriet\u00e0 non valido nell'elenco FROM.  Non esiste alcuna restrizione denominata ''{0}'' sulla tabella ''{1}'' oppure la restrizione non possiede un indice di copia.
42Y49=Pi\u00f9 valori specificati per la chiave propriet\u00e0 ''{0}''. 
42Y50=L''elenco Propriet\u00e0 per la tabella ''{0}'' pu\u00f2 contenere i valori per l''indice o per la restrizione ma non per entrambi.
42Y55=Impossibile eseguire ''{0}'' su ''{1}'' poich\u00e9 inesistente.
42Y56=joinStrategy non valida, ''{0}'', specificata nell''elenco Propriet\u00e0 sulla tabella ''{1}''. I valori supportati per  joinStrategy sono 'hash', 'nestedloop'.
42Y58=NumberFormatException verificatasi durante la conversione del valore ''{0}'' per la sovrascrittura del programma di ottimizzazione ''{1}''.
42Y59=Valore non valido, ''{0}'', specificato per la sovrascrittura hashInitialCapacity. Il valore deve essere > 0.
42Y60=Valore non valido, ''{0}'', specificato per la sovrascrittura hashLoadFactor. Il valore deve essere > 0.0 e <= 1.0.
42Y61=Valore non valido, ''{0}'', specificato per la sovrascrittura hashMaxCapacity. Il valore deve essere > 0.
42Y62=''{0}'' non consentito su ''{1}'' poich\u00e9 \u00e8 una vista.
42Y63=Il collegamento hash richiede il predicato equijoin ottimizzabile su una colonna nell'indice o nella guida selezionata.  Un predicato equijoin ottimizzabile non esiste su qualsiasi colonna presente nella tabella o nell''indice ''{0}''. Utilizzare la sovrascrittura del programma di ottimizzazione ''indice'', per specificare un indice o un heap sulla tabella ''{1}''.
42Y64=Valore bulkFetch di ''{0}'' non valido: il valore minimo per bulkFetch \u00e8 1.
42Y65=bulkFetch non consentito sui collegamenti ''{0}''.
42Y66=bulkFetch non consentito sui cursori aggiornabili.
42Y67=Impossibile eliminare lo schema ''{0}''.
42Y69=Nessun piano di esecuzione valido trovato per questa istruzione. Ci\u00f2 potrebbe dipendere da uno dei due fattori: \u00e8 stata specificata una strategia di collegamento hash quando questo non \u00e8 consentito (nessun collegamento equijoin ottimizzabile) oppure si sta tentando di collegare dueExternalVirtualTables, ognuno dei quali rappresenta il riferimento dell'altro e, quindi, non \u00e8 possibile calcolare l'istruzione.
42Y70=L'ordine di collegamento specificato dall'utente non \u00e8 un ordine di collegamento legale. Ci\u00f2 potrebbe essere dovuto al fatto che una colonna di collegamento \u00e8 stata inviata, da una tabella interna ad una virtuale esterna, come parametro.
42Y71=Impossibile eliminare la procedura o la funzione di sistema ''{0}''.
42Y82=Impossibile eliminare l''istruzione preparata e memorizzata, generata dal sistema, ''{0}'' tramite DROP STATEMENT.  Fa parte di un trigger.
42Y83=Un valore nullo senza tipo non \u00e8 consentito come argomento sull''aggregazione {0}.  Associare il valore nullo ad un tipo adeguato.
# NOTE: The parameter to this message is a keyword used as a noun phrase.
# Some possible values are "subquery", "CurrentDate", and "?".
42Y84=''{0}'' potrebbe non comparire in una definizione DEFAULT.
42Y85=La parola chiave DEFAULT non \u00e8 consentita in una clausola VALUES che compare all'interno di un'istruzione INSERT.
42Y90=FOR UPDATE non consentito su questo tipo di istruzione.
42Y91=La clausola USING non \u00e8 consentita in una EXECUTE STATEMENT per un'azione del trigger.
42Y92=I trigger {0} possono fare riferimento solo alle variabili/tabelle della transazione {1}.
42Y93=Clausola REFERENCING non valida: \u00e8 consentito solo un nome per ogni tipo di variabile/tabella della transazione.
42Y94=AND o OR possiedono un operando diverso dal valore booleano. Gli operandi di AND e OR devono essere calcolati come TRUE, FALSE o UNKNOWN.
42Y95=L''operatore ''{0}'', con un tipo di operando di sinistra di ''{1}'' e di destra di ''{2}'', non \u00e8 supportato.
42Y96.U=UNKNOWN
42Y97=Carattere escape non valido sulla riga ''{0}'', colonna ''{1}''.
42Y98.U=Riscontrato "{0}" sulla riga {1}, colonna {2}
42Y99.U=Errore lessicale alla riga {0}, colonna {1}. Riscontrato: {2}
42Z00.U=Chiamata metodo Java o riferimento campo
# This message is put into message 42X75 when a parameter doesn't have a
# datatype. For example, from the parameterWidening test:
#
# values (java.lang.Integer::toString(?, null));
# ERROR 42X50: No method was found with the signature
# java.lang.Integer.toString(UNTYPED, UNTYPED).  It may be that the method
# exists, but it is not public and/or static, or that the parameter types
# are not method invocation convertible.
42Z01.U=UNTYPED
42Z02=Non sono supportate pi\u00f9 aggregazioni DISTINCT alla volta.
42Z07=Le aggregazioni non sono consentite nella clausola ON.
42Z08=Sostituzione contenuto esistente con nuova serie di righe non consentita su ''{0}'' poich\u00e9 possiede un trigger ({1}) abilitato.
42Z09.U=la COLONNA PREDEFINITA per
#
# The following message is used in error messages where we want to say that
# certain operations on streams are illegal. The word "stream" is not a
# keyword or method name, so it should be translated.
42Z11.U=flusso

# alter table modify column error messages.
#####
42Z15=Tipo non valido specificato per la colonna ''{0}''. Non \u00e8 possibile modificare il tipo di una colonna.
42Z16=\u00c8 possibile modificare la lunghezza solo per i tipi VARCHAR. 
42Z17=Lunghezza non valida specificata per la colonna ''{0}''. La lunghezza deve essere maggiore della lunghezza della colonna corrente.
42Z18=La colonna ''{0}'' fa parte della restrizione della chiave esterna ''{1}''. Per modificare la lunghezza di questa colonna, \u00e8 necessario, innanzitutto, eliminare la restrizione, eseguire ALTER TABLE e, successivamente, ricreare la restrizione.
42Z19=La colonna ''{0}'' viene assunta come riferimento almeno per una restrizione della chiave esterna ''{1}''. Per modificare la lunghezza di questa colonna, \u00e8 necessario eliminare le restrizioni di riferimento, eseguire ALTER TABLE e, successivamente, ricreare le restrizioni.
42Z20=Impossibile rendere annullabile la colonna ''{0}''. Fa parte di una chiave primaria, che non pu\u00f2 avere colonne annullabili.

#####
# end of alter table modify constraints.
# identity error message (from 42Z21-42Z29)
#####
42837=ALTER TABLE ''{0}'' ha specificato degli attributi per la colonna ''{1}'' che non sono compatibili con la colonna esistente.
42Z21=Incremento non valido specificato come identit\u00e0 della colonna ''{0}''. L'incremento deve essere diverso da zero.
42Z22=Tipo non valido specificato per la colonna di identit\u00e0 ''{0}''. Gli unici tipi validi per le colonne di identit\u00e0 sono BIGINT, INT e SMALLINT.
42Z23=Tentativo di modificare una colonna di identit\u00e0 ''{0}''. 
42Z24=Overflow verificatosi in un valore di identit\u00e0 per la colonna ''{1}'' nella tabella ''{0}''.
42Z25=Contatore di identit\u00e0 ERRORI INTERNI: l'aggiornamento \u00e8 stato chiamato senza argomenti con valore corrente = NULL.
42Z26=Impossibile rendere annullabile una colonna, ''{0}'', con un valore predefinito di identit\u00e0.
42Z27=Impossibile modificare una colonna annullabile, ''{0}'', in modo che assuma un valore predefinito di identit\u00e0.

#####
# end of identity error messages.

42Z30.U=tempo impiegato in ResultSet =
42Z31.U=tempo impiegato in ResultSet e in quelle successive =
42Z32.U=Suddivisione tempo totale: 
42Z33.U=tempo di costruzione (millisecondi) =
42Z34.U=tempo di apertura (millisecondi) =
42Z35.U=tempo successivo (millisecondi) =
42Z36.U=tempo di chiusura (millisecondi) =
42Z37.U=Nessuno
42Z38.U=posizionamento delle informazioni non disponibile poich\u00e9 ResultSet non \u00e8 stato mai aperto.
42Z39.U=Eccezione imprevista {0} durante il richiamo del programma di posizionamento.
## NOTE: In the following message, {0} will be either >= or >
42Z40.U={0} sulle prime {1} colonne.
42Z41.U=Righe consecutive con valori nulli sulle seguenti colonne: 
42Z42.U=ID colonna
42Z43.U=Operatore
42Z44.U=Valori nulli ordinati
42Z45.U=Valore di ritorno sconosciuto
42Z46.U=Annulla risultato confronto
42Z47.U=Il richiamo del piano query come una Stringa non \u00e8 supportato per {0}
## NOTE: In the following message, {0} and {1} are integer indexes into a 2-d array
42Z48.U=ID colonna [{0}][{1}]

# matches DB2
42939=Non \u00e8 possibile creare un oggetto con il nome dello schema ''{0}''.




42Z50=ERRORE INTERNO: impossibile generare il codice per {0}.
42Z53=ERRORE INTERNO: tipo di attivazione sconosciuto per generare la scelta del nodo {0}.
42Z54.U=Questa eccezione arresta l'istruzione in seguito all'analisi - non \u00e8 necessaria un'ulteriore elaborazione.
42Z55.U=Esecuzione arrestata in seguito all'analisi tramite l'indicatore di debug StopAfterParsing.
42Z56.U=Esecuzione arrestata in seguito al collegamento tramite l'indicatore di debug StopAfterBinding.
42Z57.U=Esecuzione arrestata in seguito all'ottimizzazione tramite l'indicatore di debug StopAfterOptimizing.
42Z58.U=Esecuzione arrestata in seguito alla generazione tramite l'indicatore di debug StopAfterGenerating.

## More RUNTIMESTATISTICS messages
42Z80.U=serializzabile
42Z81.U=lettura sincronizzata
42Z82.U=esclusivo
42Z83.U=condivisione istantanea
42Z84.U=condivisione
42Z85.U=tabella
42Z86.U=riga
42Z87.U=condividi tabella
42Z88.U=condividi riga

# More generic language stuff
42Z90=La classe ''{0}'' non restituisce una ResultSet aggiornabile.
42Z91=query secondaria
42Z92=lettura ripetibile
42Z9A=lettura non sincronizzata

# Declare global temporary table language stuff. Does not match DB2, specific to Derby behavior
XCL478.S=La funzione richiesta non pu\u00f2 fare riferimento alle tabelle nello schema SESSION.
# Declare global temporary table language stuff. Matches DB2
428EK=Il qualificatore per un nome di tabella temporanea globale dichiarata deve essere SESSION.
42995=La funzione richiesta non si applica alle tabelle temporanee globali.
42962=Tipo di colonna lungo o parametro ''{0}'' non consentito nelle tabelle temporanee globali dichiarate o nelle definizioni di procedura. 

## org.apache.derby.impl.sql.execute.rts
43X00.U=Collegato a
43X01.U=Numero iniziale query secondaria
# NOTE: In this case, the name of the type of ResultSet is "Any". ResultSet
# is the name of an interface, so it should not be translated.
43X02.U=Any ResultSet
43X03.U=Numero di aperture
43X04.U=Righe visualizzate
43X05.U=Insieme dei risultati di origine
43X06.U=Numero finale query secondaria
43X07.U=conteggio righe calcolate dal programma di ottimizzazione
43X08.U=costo calcolato dal programma di ottimizzazione
43X09.U=secondi
43X10.U=Totale
43X11.U=Nodo
43X12.U={0} non supportato per {1}
# NOTE: In this case, the name of the type of ResultSet is "Any". ResultSet
# is the name of an interface, so it should not be translated.
43X13.U=Elimina ResultSet tramite
43X14.U=blocco tabella
43X15.U=blocco righe
43X16.U=rinviato
43X17.U=Righe eliminate
43X18.U=Indici aggiornati
43X19.U=Elimina
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X20.U=Distinct Scalar Aggregate ResultSet
# NOTE: In this message, "input" is being used as a verb
43X21.U=Righe immesse
43X22.U=Distinct Scalar Aggregate
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X23.U=Distinct Scan ResultSet per {0} che utilizza {1} {2}
43X24.U=restrizione
43X25.U=indice
43X26.U=Distinct Scan ResultSet per {0}
#NOTE: In this message, {0} will be something like "serializable" or "read
# committed", and {1} will be something like "share" or "exclusive".
43X27.U=al livello di isolamento {0} utilizzando il blocco {1}
43X28.U=informazioni scansione
43X29.U=La colonna Distinct \u00e8 il numero della colonna
43X30.U=Le colonne Distinct sono il numero di colonne
43X31.U=Dimensione tabella hash
43X32.U=Righe filtrate
43X33.U=tempo successivo in millisecondi/riga
43X34.U=posizione iniziale
43X35.U=posizione finale
43X36.U=qualificatori scansione
#NOTE: The message means the set of qualifiers that filter rows returned
# by the "next" operation, not the set of qualifiers that come next.
43X37.U=qualificatori dell'operazione successiva
#NOTE: In this message, {0} is a table name and {1} is an index name
43X38.U=nella tabella {0} tramite {1}
43X39.U=Distinct Scan
43X40.U=Ordina informazioni
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X41.U=Grouped Aggregate ResultSet
43X42.U=Aggregazione distinta
43X43.U=Per ordine
43X44.U=Grouped Aggregate
43X45.U=Hash Exists Join
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X46.U=Hash Exists Join ResultSet
43X47.U=Hash Join
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X48.U=Hash Join ResultSet
43X49.U=Hash Left Outer Join
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X50.U=Hash Left Outer Join ResultSet
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {1} is either "constraint" or "index", {0} is a table name, and {2} is a
# constraint or index name.
43X51.U=Hash Scan ResultSet per {0} che utilizza {1} {2}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X52.U=Hash Scan ResultSet per {0}
43X53.U=La chiave hash \u00e8 il numero della colonna
43X54.U=Le chiavi hash sono i numeri della colonna
43X55.U=Hash Scan
43X56.U=Query secondarie collegate
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X57.U=Hash Table ResultSet
43X58.U=Hash Table
43X59.U=tutto
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43X60.U=Index Row to Base Row ResultSet per {0}
43X61.U=Colonne a cui si accede dallo heap
#NOTE: {0} is a table name
43X62.U=per {0}
43X63.U=Index Row to Base Row
43X64.U=modalit\u00e0 di inserimento: inserimento di massa
43X65.U=modalit\u00e0 di inserimento: normale (impossibile eseguire l'inserimento di una nuova serie di righe a causa della mancanza di una tabella vuota)
43X66.U=modalit\u00e0 di inserimento: normale
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X67.U=Insert ResultSet che utilizza
43X68.U=Righe inserite
43X69.U=Inserisci
43X70.U=Collega
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43X71.U=Last Key Index Scan ResultSet per {0} che utilizza l''indice {1}
43X72.U=al livello di isolamento {0} utilizzando il blocco {1} scelto dal programma di ottimizzazione
43X73.U=Table Scan
43X74.U=Index Scan
#NOTE: {0} is a table name or class name
43X75.U=su {0}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X76.U=ResultSet materializzata
43X77.U=tempo di creazione conglomerato temporaneo (millisecondi)
43X78.U=tempo di lettura in sequenza conglomerato temporaneo (millisecondi)
43X79.U=Righe visualizzate da sinistra
43X80.U=Righe visualizzate da destra
43X81.U=Righe restituite
43X82.U=Insieme di risultati di sinistra
43X83.U=Insieme di risultati di destra
43X84.U=Nested Loop Exists Join
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X85.U=Nested Loop Exists Join ResultSet
43X86.U=Nested Loop Join
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X87.U=Nested Loop Join ResultSet
43X88.U=Righe di destra vuote restituite
43X89.U=Nested Loop Left Outer Join
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X90.U=Nested Loop Left Outer Join ResultSet
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X91.U=Normalize ResultSet
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X92.U=ResultSet con valore singolo
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X93.U=Project-Restrict ResultSet
43X94.U=restrizione
43X95.U=proiezione
43X96.U=tempo di restrizione (millisecondi)
43X97.U=tempo di proiezione (millisecondi)
43X98.U=Project Restrict
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X99.U=Row ResultSet
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y00.U=Scalar Aggregate ResultSet
43Y01.U=Ottimizzazione chiave indice
43Y02.U=Scalar Aggregate
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y03.U=Scroll Insensitive ResultSet
43Y04.U=Numero di letture dalla tabella hash
43Y05.U=Numero di scritture su tabella hash
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y06.U=Sort ResultSet
43Y07.U=Elimina duplicati
43Y08.U=Ordina
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name, {1} is either "constraint" or "index", {2} is a
# constraint or index name.
43Y09.U=Index Scan ResultSet per {0} che utilizza {1} {2}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43Y10.U=Table Scan ResultSet per {0}
43Y11.U=Blocco attuale utilizzato: blocco livello tabella.
43Y12.U=Dimensione lettura in sequenza
43Y13.U=qualificatori
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y14.U=Union ResultSet
43Y15.U=Union
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is either "table" or "row"
43Y16.U=Update ResultSet che utilizza il blocco {0}
43Y17.U=Righe aggiornate
43Y18.U=Aggiorna
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a Java class name.
43Y19.U=VTI ResultSet per {0}
43Y20.U=VTI
43Y21.U=Query secondarie materializzate
43Y22.U=Nome istruzione
43Y23.U=Test istruzione
# NOTE: This means the amount of time it takes to parse
43Y24.U=Tempo di analisi
# NOTE: This means the amount of time it takes to bind
43Y25.U=Tempo di collegamento
# NOTE: This means the amount of time it takes to optimize
43Y26.U=Tempo di ottimizzazione
# NOTE: This means the amount of time it takes to generate
43Y27.U=Tempo di creazione
# NOTE: This means the amount of time it takes to compile
43Y28.U=Tempo di compilazione
# NOTE: This means the amount of time it takes to execute
43Y29.U=Tempo di esecuzione
43Y30.U=Data/ora iniziale di compilazione
43Y31.U=Data/ora finale di compilazione
43Y32.U=Data/ora iniziale di esecuzione
43Y33.U=Data/ora finale di compilazione
43Y44.U=Testo normale di esecuzione istruzione
43Y45.U=Runtime 100%, {0} secondi
43Y46.U=Inserisci VTI ResultSet
43Y47.U=Elimina VTI ResultSet
43Y49.U=Inserisci VTI
43Y50.U=Elimina VTI
43Y51.U=Elimina Cascade ResultSet
43Y52.U=Elimina Cascade ResultSet tramite
43Y53.U=Azioni di riferimento su tabelle dipendenti
43Y54.U=Inizio azione di riferimento sul numero di tabella dipendente
43Y55.U=Fine azione di riferimento sul numero di tabella dipendente

54004=L'istruzione SELECT contiene molte voci in GROUP BY, ORDER BY o nell'elenco di selezione.
54008=L'istruzione CREATE INDEX specifica un numero eccessivo di colonne (16 \u00e8 il numero massimo consentito).
54023=Il limite per il numero dei parametri di una procedura \u00e8 stato superato. Il limite \u00e8 {0} ed il numero dei parametri per la procedura {1} \u00e8 {2}.
54038=La profondit\u00e0 massima dei trigger inattivi \u00e8 stata superata.

## all other org.apache.derby.catalog.types
44X00.U=Nome tipo SQL
44X05.U=errore successivo

X0X02.S=Impossibile bloccare la tabella ''{0}'' in modalit\u00e0 ''{1}''.
X0X03.S=Stato transazione non valido - il cursore attivo richiede lo stesso livello di isolamento
X0X05.S=La tabella ''{0}'' non esiste.
X0X0E.S=La posizione della colonna ''{0}'' elencata nella matrice di selezione delle colonne generata automaticamente non \u00e8 stata individuata nella tabella di inserimento.
X0X0F.S=Il nome della colonna ''{0}'' elencata nella matrice di selezione delle colonne generata automaticamente non \u00e8 stata individuata nella tabella di inserimento.
X0X07.S=Impossibile eliminare il file jar ''{0}'' poich\u00e9 si trova su db2j.database.classpath ''{0}''.
X0X10.S=La clausola USING ha restituito pi\u00f9 di una riga, sono consentite solo ResultSet di righe singole.
X0X11.S=La clausola USING non ha restituito alcun risultato, impossibile impostare alcun parametro.
X0X13.S=File jar ''{0}'' non presente nello schema ''{1}''.
X0X57.S=\u00c8 stato effettuato un tentativo di inserire un valore Java di tipo ''{0}'', in un valore SQL ma non esiste un tipo SQL corrispondente.  Il valore Java probabilmente \u00e8 il risultato della chiamata a un metodo o dell'accesso a un campo.
X0X60.S=Cursore con nome ''{0}'' gi\u00e0 esistente.
X0X61.S=I valori della colonna ''{4}'' nell''indice ''{0}'' e nella tabella ''{1}.{2}'', non corrispondono per la posizione della riga {3}.  Il valore presente nell''indice \u00e8 ''{5}'', mentre il valore presente nella tabella di base \u00e8 ''{6}''.  La chiave completa dell''indice, che comprende la posizione della riga, \u00e8 ''{7}''.  L'azione di correzione suggerita \u00e8 quella di ricreare l'indice.
X0X62.S=Incoerenza trovata tra la tabella ''{0}'' e l''indice ''{1}''.  Errore durante il tentativo di richiamare la posizione della riga ''{2}'' dalla tabella.  La chiave completa dell''indice, che comprende la posizione della riga, \u00e8  ''{3}''. L'azione di correzione suggerita \u00e8 quella di ricreare l'indice.
X0X63.S=\u00c8 stata riscontrata IOException ''{0}''.
X0X67.S=Le colonne di tipo ''{0}'' non possono essere utilizzate in CREATE INDEX, ORDER BY, GROUP BY, UNION o DISTINCT, poich\u00e9 i confronti per tale tipo non sono supportati.
X0X81.S={0} ''{1}'' non esiste.
X0X85.S=L''indice ''{0}'' non \u00e8 stato creato poich\u00e9 ''{1}'' non \u00e8 un tipo di indice valido.
X0X86.S=0 \u00e8 un valore di parametro non valido per ResultSet.absolute(int row).
X0X87.S=Impossibile chiamare ResultSet.relative(int row) quando il cursore non \u00e8 posizionato su una riga.
X0X95.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00e9 esiste una dipendenza di ResultSet aperta su tale oggetto.
X0X99.S=L''indice ''{0}'' non esiste.
X0Y16.S=''{0}'' non \u00e8 una vista.  Se si tratta di una tabella, utilizzare DROP TABLE.
X0Y23.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00e9 VIEW ''{2}'' \u00e8 una dipendenza di tale oggetto.
X0Y24.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00e9 STATEMENT ''{2}'' \u00e8 una dipendenza di tale oggetto.
X0Y25.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00e9 {2} ''{3}'' \u00e8 una dipendenza di tale oggetto.
X0Y26.S=\u00c8 necessario che l''indice ''{0}'' si trovi nello stesso schema della tabella ''{1}''.
X0Y28.S=Impossibile creare l''indice ''{0}'' sulla tabella di sistema ''{1}''.  Gli utenti non possono creare gli indici sulle tabelle di sistema.
# column c already exists in table t.
X0Y32.S={0} ''{1}'' gi\u00e0 esistente in {2} ''{3}''.
X0Y38.S=Impossibile creare l''indice ''{0}'' poich\u00e9 la tabella ''{1}'' non esiste.
X0Y41.S=Restrizione ''{0}'' non valida: la tabella di riferimento {1} non possiede chiavi primarie.  Aggiungere una chiave primaria a {1}, oppure specificare esplicitamente le colonne di una restrizione univoca, a cui fa riferimento questa chiave esterna.
X0Y42.S=Restrizione ''{0}'' non valida: i tipi di colonne della chiave esterna non corrispondono ai tipi delle colonne di riferimento.
X0Y43.S=Restrizione ''{0}'' non valida: il numero di colonne presenti in {0} ({1}) non corrisponde al numero di colonne presenti nella chiave di riferimento ({2}).
X0Y44.S=Restrizione ''{0}'' non valida: nessuna restrizione di chiave univoca o primaria sulla tabella ''{1}'' corrisponde al numero e ai tipi di colonne presenti nella chiave esterna.
X0Y45.S=Impossibile aggiungere o attivare la restrizione della chiave esterna ''{0}'' sulla tabella {1} poich\u00e9 1 o pi\u00f9 chiavi esterne non dispongono di chiavi di riferimento corrispondenti.
X0Y46.S=Restrizione ''{0}'' non valida: la tabella di riferimento {1} non esiste.
X0Y54.S=Impossibile eliminare lo schema ''{0}'' poich\u00e9 non \u00e8 vuoto.
X0Y55.S=Il numero di righe presenti nella tabella di base non corrisponde al numero di righe presenti in almeno 1 degli indici sulla tabella. L''indice ''{0}'' nella tabella ''{1}.{2}'' ha {3} righe mentre la tabella di base ne ha {4}.  L'azione di correzione suggerita \u00e8 quella di ricreare l'indice.
X0Y56.S=''{0}'' non consentito nella tabella di sistema ''{1}''.
X0Y57.S=Impossibile aggiungere una colonna non annullabile alla tabella ''{0}'' poich\u00e9 tale tabella contiene almeno 1 riga.  Le colonne non annullabili possono essere aggiunte solo alle tabelle vuote.
X0Y58.S=Tentativo di aggiungere una restrizione di chiave primaria ''{0}'' non riuscito poich\u00e9 la tabella possiede gi\u00e0 una restrizione di quel tipo.  Una tabella pu\u00f2 disporre solo di una singola restrizione di chiave primaria.
X0Y59.S=Tentativo di aggiungere o attivare una o pi\u00f9 restrizioni sulla tabella ''{1}'' non riuscito, poich\u00e9 la tabella contiene {2} righe che violano le seguenti restrizioni di controllo: {0}.
X0Y63.S=Comando sulla tabella ''{0}'' non riuscito. Dati nulli trovati nelle colonne indice/restrizione univoca o chiave primaria. Tutte le colonne presenti in una chiave indice primaria o univoca non devono essere nulle.
X0Y66.S=Impossibile eseguire il commit in una connessione nidificata quando esiste un'operazione in sospeso nella connessione parent.
X0Y67.S=Impossibile eseguire il rollback in una connessione nidificata quando esiste un'operazione in sospeso nella connessione parent.
X0Y68.S={0} ''{1}'' gi\u00e0 esistente.
X0Y69.S={1} non consentito poich\u00e9 il trigger {0} \u00e8 attivo su {2}.
X0Y70.S=INSERT, UPDATE e DELETE non sono consentiti sulla tabella {1} poich\u00e9 il trigger {0} \u00e8 attivo.
X0Y71.S=La manipolazione della transazione, ad esempio SET ISOLATION non \u00e8 consentita poich\u00e9 il trigger {0} \u00e8 attivo.
X0Y72.S=Sostituzione contenuto esistente con nuova serie di righe non consentita su ''{0}'' poich\u00e9 possiede un trigger ({1}) abilitato.
X0Y77.S=Impossibile emettere l'istruzione di impostazione isolamento transazione, su una transazione globale in corso, poich\u00e9 eseguirebbe implicitamente l'operazione di commit di tale transazione. 
X0Y78.S=Impossibile chiamare Statement.executeQuery() tramite un'istruzione che restituisce un conteggio righe.
X0Y79.S=Impossibile chiamare Statement.executeUpdate() tramite un'istruzione che restituisce ResultSet.
X0Y80.S=Tabella ALTER ''{0}'' non riuscita. Dati nulli trovati nella colonna ''{1}''.
X0Y83.S=AVVERTENZA: durante la cancellazione di una riga da una tabella, la riga dell''indice della riga della tabella di base {0} non \u00e8 stata trovata nell''indice con ID conglomerato {1}.  Questo problema \u00e8 stato corretto automaticamente come parte dell'operazione di cancellazione.
XCL01.S=L''insieme di risultati non restituisce righe; operazione {0} non consentita.
XCL05.S=Attivazione chiusa, operazione {0} non consentita.
XCL07.S=Cursore ''{0}'' chiuso. Verificare che l'autocommit sia in modalit\u00e0 OFF.
XCL08.S=Il cursore ''{0}'' non si trova su una riga.
XCL09.S=\u00c8 stata inoltrata un''Attivazione al metodo ''{0}'' che non corrisponde a PreparedStatement.
XCL10.S=\u00c8 stata compilata una PreparedStatement e i parametri sono stati modificati.  Se si sta utilizzando JDBC, \u00e8 necessario preparare nuovamente l'istruzione.
XCL12.S=\u00c8 stato effettuato un tentativo di inserire una valore dati di tipo ''{0}'' in un valore dati di tipo ''{1}''.
XCL13.S=La posizione del parametro ''{0}'' non \u00e8 compresa nell''intervallo.  Il numero dei parametri per questa istruzione preparata \u00e8 ''{1}''.
XCL15.S=Si \u00e8 verificata una ClassCastException durante la chiamata del metodo compareTo() su un oggetto ''{0}''.  Il parametro sul metodo compareTo() \u00e8 di classe ''{1}''.
XCL16.S=ResultSet non aperta, operazione ''{0}'' non consentita. Verificare che l'autocommit sia in modalit\u00e0 OFF.
XCL17.S=Istruzione non consentita in questo database.
XCL19.S=Riga mancante nella tabella ''{0}'' per la chiave ''{1}''.
XCL20.S=Impossibile aggiornare i cataloghi a livello della versione ''{0}'' al livello della versione ''{1}''.
XCL21.S=Si sta tentando di eseguire un'istruzione di definizione dati (CREATE, DROP, o ALTER) durante la  preparazione di un'istruzione differente. Ci\u00f2 non \u00e8 consentito. Si pu\u00f2 verificare se si esegue un'istruzione di definizione dati da un inizializzatore statico di una classe Java, utilizzata da un'istruzione SQL.
XCL22.S=Il parametro {0} non pu\u00f2 essere registrato come parametro OUT perch\u00e9 \u00e8 un parametro IN.
XCL23.S=Numero tipo SQL ''{0}'' non supportato da registerOutParameter().
XCL24.S=Il parametro {0} compare come un parametro di output ma non \u00e8 stato definito in questo modo da registerOutParameter().  Se non \u00e8 un parametro di output, deve essere impostato sul tipo {1}.
XCL25.S=Il parametro {0} non pu\u00f2 essere registrato come di tipo {1} poich\u00e9 \u00e8 mappato sul tipo {2} e questi non sono compatibili.
XCL26.S=Il parametro {0} non \u00e8 un parametro di output.
XCL27.S=Impossibile impostare i parametri output di ritorno.
XCL30.S=\u00c8 stata riscontrata una IOException durante la lettura di ''{0}'' da InputStream.
XCL31.S=Istruzione chiusa.

# Delete Rule Restrictions Violation Messages
XCL33.S=Impossibile definire la tabella come dipendente della tabella {0} a causa delle limitazioni imposte dalle regole di eliminazione. (La relazione \u00e8 a riferimento automatico e una relazione a riferimento automatico esiste gi\u00e0 con la regola di eliminazione SET NULL). 
XCL34.S=Impossibile definire la tabella come dipendente della tabella {0} a causa delle limitazioni imposte dalle regole di eliminazione. (La relazione forma un ciclo di due o pi\u00f9 tabelle che eliminano la tabella o la collegano con s\u00e9 stessa (tutte le altre regole di eliminazione nel ciclo dovrebbero essere CASCADE).  
XCL35.S=Impossibile definire la tabella come dipendente della tabella {0} a causa delle limitazioni imposte dalle regole di eliminazione. (La relazione elimina la tabella o la collega alla tabella indicata tramite relazioni multiple e la regola di eliminazione della relazione esistente \u00e8 SET NULL).  

XCL36.S=la regola di eliminazione della chiave esterna deve essere {0}. La restrizione referenziale \u00e8 a riferimento automatico e una restrizione a riferimento automatico gi\u00e0 esistente ha la regola di eliminazione indicata (NO ACTION, RESTRICT o CASCADE).) 
XCL37.S=la regola di eliminazione della chiave esterna deve essere {0}. (La restrizione referenziale \u00e8 a riferimento automatico e la tabella \u00e8 dipendente in una relazione con una regola di eliminazione CASCADE).
XCL38.S=la regola di eliminazione della chiave esterna deve essere {0}. La relazione potrebbe eliminare la tabella o collegarla alla stessa tabella tramite relazioni multiple e tali relazioni devono avere la stessa regola di eliminazione (NO ACTION, RESTRICT o CASCADE).) 

XCL39.S=la regola di eliminazione della chiave esterna non pu\u00f2 essere CASCADE. (Una restrizione di riferimento automatico esiste con una regola di eliminazione SET NULL, NO ACTION o RESTRICT.) 
XCL40.S=la regola di eliminazione della chiave esterna non pu\u00f2 essere CASCADE. (La relazione potrebbe formare un ciclo che elimina la tabella o la collega a s\u00e9 stessa. Una delle regole di eliminazione esistenti non \u00e8 CASCADE; questa relazione pu\u00f2 essere definibile se la regola di eliminazione non \u00e8 CASCADE). 
XCL41.S=la regola di eliminazione della chiave esterna non pu\u00f2 essere CASCADE. (La relazione potrebbe eliminare un'altra tabella o collegarla alla stessa tabella tramite percorsi multipli con diverse regole di eliminazione o con la regola di eliminazione uguale a SET NULL). 
XCL42.S="CASCADE"
XCL43.S="SET NULL"
XCL44.S="RESTRICT"
XCL45.S="CASCADE"
XCL46.S="SET DEFAULT"

XCL47.S=Per utilizzare ''{0}'', aggiornare il database passando dalla versione {1} alla versione {2} o successiva.

XCL48.S= TRUNCATE TABLE non \u00e8 consentito in ''{0}'' perch\u00e9 le restrizioni di chiave univoca/primaria in questa tabella vengono indicate abilitando le restrizioni di chiave esterne da altre tabelle. 
XCL49.S= TRUNCATE TABLE non \u00e8 consentito in ''{0}'' perch\u00e9 il trigger DELETE \u00e8 stato abilitato ({1}).
XCL50.S=L'aggiornamento del database da una versione precedente non \u00e8 supportato.  La versione del database di accesso \u00e8 ''{0}'', la versione di questo software \u00e8 ''{1}''.


# Transaction states, matches DB2
25000=Stato di transazione errato.

# Authorization
25501=Impossibile impostare la propriet\u00e0 di sola lettura della connessione in una transazione attiva.
25502=Modifica dati SQL non consentita per una connessione, un utente o un database di sola lettura.
25503=DDL non consentito per una connessione, un utente o un database di sola lettura.
25505=Un utente con autorizzazione di sola lettura, o un utente in un database di sola lettura, non pu\u00f2 disattivare la modalit\u00e0 di sola lettura su una connessione.
28501=Propriet\u00e0 di autorizzazione database ''{0}={1}'' non valida.
28502.C=Il nome utente ''{0}'' non \u00e8 valido. 
28503=L''utente (utenti) ''{0}'' deve essere incluso sia nell''elenco di autorizzazioni  di sola lettura sia in quello di accesso completo.
28504=Utente (utenti) ''{1}'' ripetuto nell''elenco di accesso ''{0}'';
04501.C=Connessione al database rifiutata.


# Dependency Manager
XD003.S=Impossibile ripristinare la dipendenza dal disco. DependableFinder = ''{0}''. Ulteriori informazioni: ''{1}''.
XD004.S=Impossibile memorizzare le dipendenze.


#../java/com/ibm/db2j/impl/Connectivity/JDBC/Local/messages.properties
24000=Stato cursore non valido - nessuna riga corrente.

07000=Almeno un parametro sull'istruzione corrente non \u00e8 inizializzato.

# 07004 : {0} is an number {1) is fixed text OUT or INOUT
07004=Il parametro {0} \u00e8 un parametro della procedura {1} e deve essere registrato con CallableStatement.registerOutParameter prima dell''esecuzione.

07009=Nessun parametro di input.

S0022=Colonna ''{0}'' non trovata.
XJ009.S=Utilizzo di CallableStatement richiesto per la chiamata della procedura memorizzata o utilizzo dei parametri di output: {0}
XJ010.S=Impossibile generare savepoint quando autoCommit \u00e8 attivo.
XJ011.S=Impossibile inviare un valore nullo per il nome savepoint.
XJ012.S=''{0}'' gi\u00e0 chiuso.
XJ013.S=Nessun ID per i savepoint denominati.
XJ014.S=Nessun nome per i savepoint che non sono denominati.
XJ016.S=Metodo ''{0}'' non consentito sull''istruzione preparata.
XJ017.S=Nessun comando savepoint consentito all'interno del codice trigger.
XJ018.S=Il nome colonna non pu\u00f2 essere nullo.
XJ020.S=Tipo di oggetto non convertibile in TYPE ''{0}'', valore java.sql.Types non valido o puntatore nullo all''oggetto.
XJ022.S=Impossibile impostare il flusso: ''{0}''.
XJ023.S=Il flusso di input contiene un minor numero di dati rispetto alla lunghezza richiesta.
XJ025.S=Il flusso di input non pu\u00f2 contenere una lunghezza negativa.
XJ030.S=Impossibile impostare AUTOCOMMIT ON in una connessione nidificata.
XJ042.S=''{0}'' non \u00e8 un valore valido per la propriet\u00e0 ''{1}''.
XJ044.S=''{0}'' non \u00e8 una scala valida.
XJ045.S=Livello di isolamento non valido o non supportato, ''{0}'', inviato a Connection.setTransactionIsolationLevel(). I valori supportati sono java.sql.Connection.TRANSACTION_SERIALIZABLE, java.sql.Connection.TRANSACTION_REPEATABLE_READ, java.sql.Connection.TRANSACTION_READ_COMMITTED e java.sql.Connection.TRANSACTION_READ_UNCOMMITTED.
XJ04B.S=Il batch non pu\u00f2 contenere un comando che tenti di restituire un insieme di risultati.
XJ04C.S=Il batch CallableStatement non pu\u00f2 contenere i parametri di output.
XJ056.S=Impossibile impostare AUTOCOMMIT ON in una connessione XA.
XJ057.S=Impossibile eseguire l'operazione di commit di una transazione globale utilizzando la Connessione, l'elaborazione del commit deve essere eseguita attraverso l'interfaccia XAResource.
XJ058.S=Impossibile eseguire l'operazione di rollback di una transazione globale utilizzando la Connessione, l'elaborazione del commit deve essere eseguita attraverso l'interfaccia XAResource.
XJ059.S=Impossibile chiudere una connessione mentre una transazione globale \u00e8 ancora attiva.
XJ05C.S=Impossibile impostare holdability ResultSet.HOLD_CURSORS_OVER_COMMIT per una transazione globale.
XJ061.S=Il metodo ''{0}'' \u00e8 consentito solo sui cursori di scorrimento.
XJ062.S=Valore parametro ''{0}'' non valido per ResultSet.setFetchSize(int rows).
XJ063.S=Valore parametro ''{0}'' non valido per Statement.setMaxRows(int maxRows).  Il valore del parametro deve essere >= 0.
XJ064.S=Valore parametro ''{0}'' non valido per setFetchDirection(int direction).
XJ065.S=Valore parametro ''{0}'' non valido per Statement.setFetchSize(int rows).
XJ066.S=Valore parametro ''{0}'' non valido per Statement.setMaxFieldSize(int max).
XJ067.S=Il puntatore di testo SQL \u00e8 nullo.
XJ068.S=executeBatch e clearBatch sono consentiti solo durante un batch.
XJ069.S=Nessun metodo SetXXX consentito in caso di Execute Statement Using.
XJ080.S=Execute Statement Using ha inviato {0} parametri invece di {1}.
XJ070.S=Argomento posizione negativo o nullo ''{0}'' inviato in un metodo Blob o Clob.
XJ071.S=Argomento lunghezza nullo o negativo ''{0}'' inviato in un metodo Blob o Clob.
XJ072.S=Modello nullo o searchStr inviato in un metodo di posizione Blob o Clob.
XJ073.S=I dati presenti nel metodo Blob o Clob non sono pi\u00f9 disponibili. Le ragioni possibili possono essere che la transazione \u00e8 stata sottoposta a commit o che la connessione \u00e8 chiusa.
XJ076.S=L''argomento posizione ''{0}'' supera la dimensione di Blob/Clob.
XJ077.S=\u00c8 stata riscontrata un'eccezione durante il tentativo di leggere il primo byte/carattere del modello Blob/Clob, utilizzando getBytes/getSubString.
XJ082.U=I valori BLOB/CLOB non sono consentiti come parametri di metodo o destinatari.

0A000.S=Funzione non implementata: {0}.

XJ004.C=Database ''{0}'' non trovato.
08004=Connessione rifiutata : {0}
A020=Autenticazione non valida.
08003=Nessuna connessione corrente.
XJ028.C=URL ''{0}'' non formato correttamente.
XJ040.C=Impossibile avviare il database ''{0}''; per i dettagli consultare l''eccezione successiva.
XJ041.C=Impossibile creare il database ''{0}''; per i dettagli consultare l''eccezione successiva.
XJ049.C=Conflitto durante la creazione degli attributi specificati.
XJ081.C=Sono stati specificati degli attributi di creazione/ripristino/recupero in conflitto.
XJ05B.C=L''attributo JDBC ''{0}'' possiede un valore non valido ''{1}'', i valori validi sono ''{2}''.

XXXXX.C.6=Chiusura sessione database normale.

08006.D=Arresto database ''{0}''.

XJ015.M=Arresto del sistema Derby.

01J01=Database ''{0}'' non creato, connessione eseguita al database esistente.
01J02=I cursori di scorrimento sensibili non sono implementati.
01J03=Le ResultSet aggiornabili non sono implementate.
01J04=La classe ''{0}'' della colonna ''{1}'' non implementa java.io.Serializable o java.sql.SQLData. Le istanze devono implementare una di queste interfacce per essere memorizzate.
01J05=Aggiornamento database riuscito. Il database aggiornato \u00e8 pronto per l'uso. Nuova convalida delle istruzioni preparate memorizzate non riuscita. Per i dettagli relativi a questo errore, consultare l'eccezione successiva.

XJ001.U=Eccezione Java: ''{1}: {0}''.
XJ050.U=\u00c8 necessario aggiornare il database dalla versione {0}, impostare l''attributo ''upgrade=true'' sull''URL della connessione JDBC per consentire l''aggiornamento alla versione {1}.


# org.apache.derby.database.UserUtility
#
XCZ00.S=Autorizzazione ''{0}'' sconosciuta.
XCZ01.S=Utente ''{0}'' sconosciuto.
XCZ02.S=Parametro ''{0}''=''{1}'' non valido.

# SQL J Jar support
46001=Eccezione durante l''accesso al file jar tramite l''URL ''{0}''.

###############################################################################
#
# Text for non-exception strings
#
###############################################################################

# Log
L001=------------  INIZIO MESSAGGIO DI ERRORE -------------\n
L002=------------  FINE MESSAGGIO DI ERRORE -------------\n
L003=\n------------  INIZIO ARRESTO STACK ERRORI -------------\n
L004=\n------------  FINE ARRESTO STACK ERRORI -------------\n
L005=\n------------  INIZIO STACK ERRORI-------------\n
L006=\n------------  FINE STACK ERRORI-------------\n
L007=AVVERTENZA: file di log non trovato, creazione nuovo log. Possibile incoerenza nel database
L008=Cancellazione vecchio Logfile {0} non compatibile
L009=Cancellazione vecchio Logfile {0}
L010=\u00c8 stato rilevato un record di log incompleto nel file {0}, durante l''eliminazione del file di log dalla posizione {1} alla fine del file {2}.
L011=Il Daemon di controllo ha riscontrato l'eccezione standard
L012=Il record di log non \u00e8 il primo ma la transazione non si trova nella tabella transazioni : {0}
L013=Il record di log \u00e8 il primo ma la transazione si trova gi\u00e0 nella tabella transazioni : {0}
L014=Classe instant di avvio errata
L015=Il nuovo file di log esiste e non pu\u00f2 essere cancellato {0}
L016=impossibile creare un nuovo file di log {0}
L017=impossibile creare un nuovo file di log {0} a causa di {1}
L018=Il sistema potrebbe trovarsi in uno stato incoerente, file {0} mancante

# Class Manager
C000=Classe {0} scritta sul file {1}. Fornire il supporto tramite il file e le seguenti informazioni relative all''eccezione: {2}
C001=La classe {0} dispone di un tipo di certificato sconosciuto in jar {1}, previsto certificato X509.
C002=Eccezione di sicurezza riscontrata durante l''accesso alla classe {0} in jar {1} : {2}
C003=Eccezione durante il caricamento del database jar {0} - {1}
C004=Programma di caricamento classi obsoleto per la classe {0}
C005=Programma di caricamento classe database avviato - derby.database.classpath=''{0}''
C006={0} \u00e8 stato caricato dal database jar {1}
C007=Eccezione durante il caricamento della classe {0} da jar {1} - {2}

# RawStore Data

D001=:\n Avvio Derby versione {0}: istanza {1}\nsu directory database {2} \n
D002=:\nArresto istanza {0}
D004=Backup avviato per il database situato in {0}
D005=vecchia copia di backup spostata da {0} a {1}
D006=directory database spostata da {0} a {1}
D007=database service.properties modificato per utilizzare il dispositivo di log predefinito
D008=errore durante la modifica del database service.properties, backup interrotto: {0}
D009=directory di log copiata da {0} a {1}
D010=Backup interrotto a causa di un errore
D011=vecchia copia di backup eliminata su {0}
D012=Backup completato, classe instant di log su {0} \n

# Connectivity 
J004=identit\u00e0 database
J005=arresta Derby
J007=crea database
J008=nessun dettaglio
J010=codifica database su disco
J013=aggiorna database
J016=provider servizio crittografico
J017=algoritmo crittografico
J018=lunghezza chiave crittografica
J019=chiave crittografica esterna
J020=chiave crittografica segreta
J021=impostazioni internazionali per il database
J022=nome utente
J023=password utente
J025=percorso directory di log
J028=percorso di backup per il ripristino rollforward
J100=Impossibile trovare la classe del server di rete, {0}. Il percorso di classi deve contenere csnet.jar.
J101=Impossibile caricare la classe del server di rete, {0}. {1} Verificare l'integrit\u00e0 del file csnet.jar.
J102=Si \u00e8 verificata un'eccezione durante l'avvio del server di rete. {0}
J103=Si \u00e8 verificata un'eccezione durante la chiusura del server di rete. {0}

# Authentication
A001=IRREVERSIBILE: non esiste alcun Servizio di autenticazione per il sistema
A002=IRREVERSIBILE: non esiste alcun Servizio di autenticazione per il database
A011=AVVERTENZA: nessun nome Server/Host LDAP menzionato nella propriet\u00e0 {0}; utilizzo di localhost:389

I015=org.apache.derby.jdbc.EmbeddedDriver non \u00e8 registrato con il gestore driver JDBC
I024=Database non disponibile
I025=Driver JDBC non disponibile

# Import/Export
XIE01.S=Connessione nulla.
XIE03.S=Dati trovati sulla riga {0} della colonna {1} dopo il delimitatore di arresto
XIE04.S=File dati non trovato: {0}
XIE05.S=Il file dati non pu\u00f2 essere nullo.
XIE06.S=Nome entit\u00e0 nullo.
XIE07.S=I separatori di campo e record non possono essere stringhe secondarie tra loro.
XIE08.S=Non esiste alcuna colonna per nome: {0}
XIE09.S=Il numero totale delle colonne presenti nella riga \u00e8: {0}
XIE0B.S=La colonna ''{0}'' nella tabella \u00e8 di tipo {1}, non \u00e8 supportata da import/export.
XIE0D.S=Impossibile trovare il separatore di record sulla riga {0}
XIE0E.S=Carattere di fine file riscontrato in una posizione non prevista nella riga {0}
XIE0I.S=Riscontrata IOException durante la scrittura dei dati sul file
XIE0J.S=Un delimitatore non \u00e8 valido o viene utilizzato pi\u00f9 volte.
XIE0K.S=Il punto \u00e8 stato specificato come delimitatore della stringa di carattere.
XIE0M.S=La tabella ''{0}'' non esiste.

# Monitor
M001=\n# ****************************************************************************************\n# ***                NON modificare questo file.                 ***\n# *** LA MODIFICA DEL CONTENUTO DI QUESTO FILE POTREBBE CAUSARE LA CORRUZIONE DEI DATI. ***\n# ****************************************************************************************




#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
#
#  DO NOT TRANSLATE MESSAGES OR TEXT BELOW THIS LINE
#
#
# ----------------------------------------------------------------------------------------------------------


