/* Generated By:JavaCC: Do not edit this line. SQLParser.java */
/*

   Derby - File org.apache.derby.impl.sql.compile.sqlgrammar.jj

   Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

package org.apache.derby.impl.sql.compile;

import org.apache.derby.iapi.sql.Statement;
import org.apache.derby.iapi.sql.StatementType;

/* aggregates */
import org.apache.derby.impl.sql.compile.CountAggregateDefinition;
import org.apache.derby.impl.sql.compile.MaxMinAggregateDefinition;
import org.apache.derby.impl.sql.compile.SumAvgAggregateDefinition;

import org.apache.derby.impl.sql.compile.AggregateNode;
import org.apache.derby.impl.sql.compile.BinaryOperatorNode;
import org.apache.derby.impl.sql.compile.CallStatementNode;
import  org.apache.derby.impl.sql.compile.CharConstantNode;
import  org.apache.derby.impl.sql.compile.CastNode;
import org.apache.derby.impl.sql.compile.ColumnDefinitionNode;
import org.apache.derby.impl.sql.compile.ColumnReference;
import org.apache.derby.impl.sql.compile.CursorNode;
import org.apache.derby.impl.sql.compile.FromBaseTable;
import org.apache.derby.impl.sql.compile.FromList;
import org.apache.derby.impl.sql.compile.FromSubquery;
import org.apache.derby.impl.sql.compile.FromTable;
import org.apache.derby.impl.sql.compile.GroupByList;
import org.apache.derby.impl.sql.compile.HasNodeVisitor;
import org.apache.derby.impl.sql.compile.JavaToSQLValueNode;
import org.apache.derby.impl.sql.compile.JoinNode;
import org.apache.derby.impl.sql.compile.MethodCallNode;
import org.apache.derby.impl.sql.compile.QueryTreeNode;
import org.apache.derby.impl.sql.compile.ReplaceAggregatesWithCRVisitor;
import org.apache.derby.impl.sql.compile.ResultColumnList;
import org.apache.derby.impl.sql.compile.ResultColumn;
import org.apache.derby.impl.sql.compile.OrderByList;
import org.apache.derby.impl.sql.compile.OrderByColumn;
import org.apache.derby.impl.sql.compile.ResultSetNode;
import org.apache.derby.impl.sql.compile.SelectNode;
import org.apache.derby.impl.sql.compile.SubqueryNode;
import org.apache.derby.impl.sql.compile.TableName;
import org.apache.derby.impl.sql.compile.TernaryOperatorNode;
import org.apache.derby.impl.sql.compile.ParameterNode;
import org.apache.derby.impl.sql.compile.ConstraintDefinitionNode;
import org.apache.derby.impl.sql.compile.DMLModStatementNode;
import org.apache.derby.impl.sql.compile.StatementNode;
import org.apache.derby.impl.sql.compile.TableElementList;
import org.apache.derby.impl.sql.compile.TableElementNode;
import org.apache.derby.impl.sql.compile.TableOperatorNode;
import org.apache.derby.impl.sql.compile.TransactionStatementNode;
import org.apache.derby.impl.sql.compile.TriggerReferencingStruct;
import org.apache.derby.impl.sql.compile.UnionNode;
import org.apache.derby.impl.sql.compile.IntersectOrExceptNode;
import org.apache.derby.impl.sql.compile.UnaryOperatorNode;
import org.apache.derby.impl.sql.compile.UntypedNullConstantNode;
import org.apache.derby.impl.sql.compile.UpdateNode;
import org.apache.derby.impl.sql.compile.UserTypeConstantNode;
import org.apache.derby.impl.sql.compile.ValueNode;
import org.apache.derby.impl.sql.compile.ValueNodeList;
import org.apache.derby.impl.sql.compile.GroupByColumn;
import org.apache.derby.impl.sql.compile.CurrentDatetimeOperatorNode;
import org.apache.derby.impl.sql.compile.CreateStatementNode;
import org.apache.derby.impl.sql.compile.AlterTableNode;

import org.apache.derby.impl.sql.compile.StringSlicer;
import org.apache.derby.impl.sql.compile.ParseException;
import org.apache.derby.impl.sql.compile.Token;
import org.apache.derby.impl.sql.compile.TokenMgrError;
import org.apache.derby.impl.sql.compile.SQLParserConstants;
import org.apache.derby.impl.sql.compile.CharStream;
import org.apache.derby.iapi.sql.dictionary.DataDictionary;
import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
import org.apache.derby.iapi.sql.dictionary.ViewDescriptor;

import org.apache.derby.iapi.sql.execute.ConstantAction;
import org.apache.derby.iapi.sql.execute.ExecutionContext;

import org.apache.derby.iapi.types.DataTypeDescriptor;
import org.apache.derby.iapi.types.TypeId;
import org.apache.derby.iapi.sql.compile.TypeCompiler;
import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;

import org.apache.derby.iapi.types.DateTimeDataValue;
import org.apache.derby.iapi.types.DataTypeDescriptor;
import org.apache.derby.iapi.types.DataTypeUtilities;
import org.apache.derby.iapi.types.StringDataValue;
import org.apache.derby.iapi.types.DataValueDescriptor;

import org.apache.derby.iapi.error.StandardException;

import org.apache.derby.iapi.reference.SQLState;
import org.apache.derby.iapi.reference.JDBC30Translation;
import org.apache.derby.iapi.reference.Limits;

import org.apache.derby.iapi.sql.compile.CompilerContext;
import org.apache.derby.iapi.sql.compile.C_NodeTypes;

import org.apache.derby.iapi.services.context.ContextManager;

import org.apache.derby.iapi.sql.compile.NodeFactory;

import org.apache.derby.iapi.services.sanity.SanityManager;

import org.apache.derby.catalog.AliasInfo;
import org.apache.derby.catalog.TypeDescriptor;
import org.apache.derby.catalog.types.RoutineAliasInfo;

import org.apache.derby.iapi.services.io.FormatableProperties;
import org.apache.derby.iapi.services.io.StoredFormatIds;
import org.apache.derby.iapi.util.ReuseFactory;
import org.apache.derby.iapi.services.io.FormatableBitSet;
import org.apache.derby.iapi.util.StringUtil;

import java.sql.Types;
import java.util.Properties;
import java.util.Vector;
import java.lang.Character;

public class SQLParser implements SQLParserConstants {
        private static final String[] SAVEPOINT_CLAUSE_NAMES = {"UNIQUE", "ON ROLLBACK RETAIN LOCKS", "ON ROLLBACK RETAIN CURSORS"};
        private static final String[] PROCEDURE_CLAUSE_NAMES =
                {null, "SPECIFIC", "RESULT SET", "LANGUAGE", "EXTERNAL NAME", "PARAMETER STYLE", "SQL", "ON NULL INPUT"};
        private static final String[] TEMPORARY_TABLE_CLAUSE_NAMES = {"NOT LOGGED", "ON COMMIT", "ON ROLLBACK"};
        /* The default length of a char or bit if the length is omitted */
        private static final int        DEFAULT_STRING_COLUMN_LENGTH = 1;

        // Defines for ON or USING clauses
        private static final int        ON_OR_USING_CLAUSE_SIZE = 2;
        private static final int        ON_CLAUSE = 0;
        private static final int        USING_CLAUSE = 1;

        // Defines for optional table clauses
        private static final int        OPTIONAL_TABLE_CLAUSES_SIZE = 3;
        private static final int        OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES = 0;
        private static final int        OPTIONAL_TABLE_CLAUSES_DERIVED_RCL = 1;
        private static final int        OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME = 2;

        // Define for UTF8 max
        private static final int        MAX_UTF8_LENGTH = 65535;

    // Constants for set operator types
    private static final int NO_SET_OP = 0;
    private static final int UNION_OP = 1;
    private static final int UNION_ALL_OP = 2;
    private static final int EXCEPT_OP = 3;
    private static final int EXCEPT_ALL_OP = 4;
    private static final int INTERSECT_OP = 5;
    private static final int INTERSECT_ALL_OP = 6;

        private StringSlicer                            stringSlicer;
        private Object[]                                        paramDefaults;
        private String                                          statementSQLText;
        private NodeFactory                                     nodeFactory;
        private ContextManager                          cm;
        private CompilerContext                         compilerContext;

        /* The number of the next ? parameter */
        private int                     parameterNumber;

        /* The list of ? parameters */
        private Vector                  parameterList;

        /* Remember if the last identifier or keyword was a
	 * delimited identifier.  This is used for remembering
	 * if the xxx in SERIALIZE(xxx) was a delimited identifier
	 * because we need to know whether or not we can convert
	 * xxx to upper case if we try to resolve it as a class
	 * alias at bind time.
	 */
        private Boolean lastTokenDelimitedIdentifier = Boolean.FALSE;
        private Boolean nextToLastTokenDelimitedIdentifier = Boolean.FALSE;


        /*
	** Remember the last token we got that was an identifier
	*/
        private Token   lastIdentifierToken;
        private Token   nextToLastIdentifierToken;

        static final String SINGLEQUOTES = "\'\'";
        static final String DOUBLEQUOTES = "\"\"";

        static final String DEFAULT_INDEX_TYPE = "BTREE";

        //the following 2 booleans are used to make sure only null or not null is
        //defined for a column while creating a table or altering a table. Defining
        //both at the same time will be an error case.
        boolean explicitNotNull = false;
        boolean explicitNull = false;

        //this vector keeps a list of explicitly nullable columns, so that if they
        //get used in the table level primary key constraint, it will result in an
        //exception.	
        Vector explicitlyNullableColumnsList = new Vector();


        final void setCompilerContext(CompilerContext cc) {
                this.compilerContext = cc;
                this.cm = cc.getContextManager();
        }

        /**
	  *	Get the NodeFactory for this database.
	  *
	  *	@return	The NodeFactory for this database.
	  * @exception StandardException		Thrown on error
	  */
        private final NodeFactory       getNodeFactory()        throws StandardException
        {
                if ( nodeFactory == null )
                {
                        nodeFactory = getCompilerContext().getNodeFactory();
                }

                return  nodeFactory;
        }

        private final CompilerContext getCompilerContext()
        {
                return compilerContext;
        }

        private DataTypeDescriptor getDataTypeServices(int type, int precision, int scale,
                        int length)
        {
                return new DataTypeDescriptor(
                                        TypeId.getBuiltInTypeId(type),
                                        precision,
                                        scale,
                                        true, /* assume nullable for now, change it if not nullable */
                                        length
                                );
        }

        private DataTypeDescriptor getJavaClassDataTypeDescriptor(String javaClassName)
        {
                return new DataTypeDescriptor(
                                        TypeId.getUserDefinedTypeId(
                                                                javaClassName,
                                                                lastTokenDelimitedIdentifier.booleanValue()),
                                        true);
        }
        private LanguageConnectionContext getLanguageConnectionContext()
        {
                return (LanguageConnectionContext) getContextManager().getContext(
                                                                                LanguageConnectionContext.CONTEXT_ID);
        }

        /**
		Utility method for checking that the underlying database has been
		upgraded to the required level to use this functionality. Used to
		disallow SQL statements that would leave on-disk formats that would
		not be understood by a engine that matches the current upgrade level
		of the database. Throws an exception if the database is not a the required level.
		<P>
		Typically used for CREATE statements at the parser level. Called usually just
		before the node is created, or can be called in just a partial syntax fragment
		
		@param majorVersion Data Dictionary major version (DataDictionary.DD_ constant)
		@param feature SQL Feature name, for error text.
	*/
        private void checkVersion(int version, String feature) throws StandardException
        {
                getLanguageConnectionContext().getDataDictionary().checkVersion(
                                version, feature);
        }

        /**
		Check that the current mode supports internal extensions.

		@param feature Description of feature for exception.

		@exception StandardException current mode does not support statement
	*/
        private void checkInternalFeature(String feature) throws StandardException
        {
                CompilerContext cc = getCompilerContext();
                if ((cc.getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0)
                        throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, feature);
        }

        /**
	 * check if the type length is ok for the given type.
	 */
        private void checkTypeLimits(int type, int length)
                throws StandardException
        {
        boolean valid = true;


        switch (type) {
                case Types.BINARY:
                case Types.CHAR:
                        if (length  > Limits.DB2_CHAR_MAXWIDTH)
                                valid = false;
                        break;

                case Types.VARBINARY:
                case Types.VARCHAR:
                        if (length  > Limits.DB2_VARCHAR_MAXWIDTH)
                                valid = false;

                        break;
                default:
                        break;
        }
        if (!valid)  // If these limits are too big 
                {
                        DataTypeDescriptor charDTD =
                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);

                        throw StandardException.newException(SQLState.LANG_DB2_LENGTH_PRECISION_SCALE_VIOLATION, charDTD.getSQLstring());
                }
        }



        // Get the current ContextManager
        private final ContextManager getContextManager()
        {
                return cm;
        }

        private StringSlicer    getStringSlicer()
        {
                if ( stringSlicer == null )
                {
                        stringSlicer = new StringSlicer( statementSQLText);
                }
                return  stringSlicer;
        }

        /*
	** Compress 2 adjacent (single or double) quotes into a single (s or d) quote when
	** found in the middle of a String.
	** NOTE:  """" or '''' will be compressed into "" or ''.
	** 		  This function assumes that the leading and trailing quote from a
	** 		  string or delimited identifier have already been removed.
	*/
        private static String compressQuotes(String source, String quotes)
        {
                String  result = source;
                int             index;

                /* Find the first occurrence of adjacent quotes. */
                index = result.indexOf(quotes);

                /* Replace each occurrence with a single quote and begin the
		 * search for the next occurrence from where we left off.
		 */
                while (index != -1)
                {
                        result = result.substring(0, index + 1) + result.substring(index + 2);

                        index = result.indexOf(quotes, index + 1);
                }

                return result;
        }

        private static void verifyImageLength(String image) throws StandardException
                {
                // beetle 2758.  For right now throw an error for literals > 64K
                if (image.length() > MAX_UTF8_LENGTH)
                        {
                throw StandardException.newException(SQLState.LANG_INVALID_LITERAL_LENGTH);
                        }
                }

        /*
	** Converts a delimited id to a canonical form.
	** Post process delimited identifiers to eliminate leading and
	** trailing " and convert all occurrences of "" to ".
	*/
        private static String normalizeDelimitedID(String str)
        {
                str = compressQuotes(str, DOUBLEQUOTES);
                return str;
        }
        private static boolean isDATETIME(int val)
        {
                if (val == DATE || val == TIME || val == TIMESTAMP)
                        return true;
                else
                        return false;
        }

        /*
	 * Generate a multiplicative operator node, if necessary.
	 *
	 * If there are two operands, generate the multiplicative operator
	 * that corresponds to the multiplicativeOperator parameter.  If there
	 * is no left operand, just return the right operand.
	 *
	 * @param leftOperand	The left operand, null if no operator
	 * @param rightOperand	The right operand
	 * @param multiplicativeOperator	An identifier from BinaryOperatorNode
	 *									telling what operator to generate.
	 *
	 * @return	The multiplicative operator, or the right operand if there is
	 *			no operator.
	 *
	 * @exception StandardException		Thrown on error
	 */

        ValueNode multOp(ValueNode leftOperand,
                                                        ValueNode rightOperand,
                                                        int multiplicativeOperator)
                                        throws StandardException
        {
                if (leftOperand == null)
                {
                        return rightOperand;
                }

                switch (multiplicativeOperator)
                {
                  case BinaryOperatorNode.TIMES:
                        return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.BINARY_TIMES_OPERATOR_NODE,
                                                                        leftOperand,
                                                                        rightOperand,
                                                                        getContextManager());

                  case BinaryOperatorNode.DIVIDE:
                        return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.BINARY_DIVIDE_OPERATOR_NODE,
                                                                        leftOperand,
                                                                        rightOperand,
                                                                        getContextManager());
                  case BinaryOperatorNode.CONCATENATE:
                        return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.CONCATENATION_OPERATOR_NODE,
                                                                        leftOperand,
                                                                        rightOperand,
                                                                        getContextManager());

                  default:
                        if (SanityManager.DEBUG)
                        SanityManager.THROWASSERT("Unexpected multiplicative operator " +
                                                                                multiplicativeOperator);
                        return null;
                }
        }

        /**
	 * Set up and like the parameters to the descriptors.
	 * Set all the ParameterNodes to point to the array of
	 * parameter descriptors.
	 * 
	 * @return Nothing
	 *	@exception	StandardException
	 */
         private void setUpAndLinkParameters()
                        throws StandardException
         {
                CompilerContext cc = getCompilerContext();
                cc.setParameterList(parameterList);
                /* Link the untyped parameters to the array of parameter descriptors */

                DataTypeDescriptor[] descriptors = cc.getParameterTypes();

                ParameterNode                           newNode;
                ParameterNode                           oldNode;
                int                                                     paramCount;

                /*
		** Iterate through the list of untyped parameter nodes, set each one
		** to point to the array of parameter descriptors.
		*/
                paramCount = -1;
                int plSize = parameterList.size();
                for (int index = 0; index < plSize; index++)
                {
                        paramCount++;

                        newNode = (ParameterNode) parameterList.elementAt(index);
                        newNode.setDescriptors(descriptors );
                }
        }

        /**
	 *  Initializes the list of unnamed parameters, i.e., "?" parameters
	 *
	 *	Usually, this routine just gets an empty list for the unnamed parameters.
	 *
	 *
	 */
        void    initUnnamedParameterList()
        {
                parameterList = new Vector();
        }

        /**
	 * Makes a new unnamed ParameterNode and chains it onto parameterList.
	 *
	 *	@return	new unnamed parameter.
	 *
	 *	@exception	StandardException
	 */
        ParameterNode   makeParameterNode(  )
                                        throws StandardException
        {
                ParameterNode   parm;
                DataValueDescriptor sdv = null;

                if ((paramDefaults != null) && (parameterNumber < paramDefaults.length))
                {
                        sdv = (DataValueDescriptor) paramDefaults[parameterNumber];
                }

                parm = (ParameterNode) nodeFactory.getNode(
                                                                C_NodeTypes.PARAMETER_NODE,
                                                                ReuseFactory.getInteger(parameterNumber),
                                                                sdv,
                                                                getContextManager());

                parameterNumber++;
                parameterList.addElement(parm);

                return parm;
        }

        /**
	 * Looks up an unnamed parameter given its parameter number.
	 *
	 *	@param	paramNumber		Number of parameter in unnamed
	 *							parameter list.
	 *
	 *	@return	corresponding unnamed parameter.
	 *
	 */
        ParameterNode   lookupUnnamedParameter( int paramNumber )
        {
                ParameterNode           unnamedParameter;

                unnamedParameter = (ParameterNode) parameterList.elementAt( paramNumber );
                return unnamedParameter;
        }

        /**
	 * Translate a String containing a number into the appropriate type
	 * of Numeric node.
	 *
	 * @exception StandardException		Thrown on error
	 */
        ValueNode getNumericNode(String num) throws StandardException
        {
                ContextManager cm = getContextManager();

                // first, see if it might be an integer
                try
                {
                        return (ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.INT_CONSTANT_NODE,
                                                                                new Integer(num),
                                                                                cm);
                }
                catch (NumberFormatException nfe)
                {
                        // we catch because we want to continue on below
                }

                // next, see if it might be a long
                try
                {
                        return (ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.LONGINT_CONSTANT_NODE,
                                                                                new Long(num),
                                                                                cm);
                }
                catch (NumberFormatException nfe)
                {
                        // we catch because we want to continue on below
                }

                return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.DECIMAL_CONSTANT_NODE,
                                                                        num,
                                                                        cm);
        }
        /**
	 * Determine whether the current token represents one of
	 * the built-in aliases.
	 *
	 * @return	TRUE iff the current token names a built-in alias
	 */
        private boolean isBuiltInAlias()
        {
                boolean retval = false;

                switch (token.kind)
                {
                  case UCASE:
                  case LCASE:
                  case SQRT:
                  case LOCATE:
                  case ABS:
                  case ABSVAL:
                  case SUBSTR:
                  case MOD:
                        retval = true;
                        break;

                  default:
                        retval = false;
                        break;
                }


                return retval;
        }


        /**
	 * Determine whether the next sequence of tokens represents one of
	 * the common (built-in) datatypes.
	 *
	 * @return	TRUE iff the next set of tokens names a common datatype
	 */
        boolean commonDatatypeName(boolean checkFollowingToken)
        {
                boolean retval = false;

                switch (getToken(1).kind)
                {
                  case CHARACTER:
                  case CHAR:
                  case VARCHAR:
                  case NVARCHAR:
                  case NCHAR:
                  case BIT:
                  case NUMERIC:
                  case DECIMAL:
                  case DEC:
                  case INTEGER:
                  case INT:
                  case SMALLINT:
                  case LONGINT:
                  case FLOAT:
                  case REAL:
                  case DATE:
                  case TIME:
                  case TIMESTAMP:
                  case BOOLEAN:
                  case DOUBLE:
                  case BLOB:
                  case CLOB:
                  case NCLOB:
                  case BINARY: // LARGE OBJECT
                  case XML:
                        retval = true;
                        break;

                  case LONG:
                        if (checkFollowingToken == true)
                        {
                                switch (getToken(2).kind)
                                {
                                  case VARCHAR:
                                  case NVARCHAR:
                                  case BINARY:
                                  case VARBINARY:
                                  case BIT:
                                        retval = true;
                                        break;
                                }
                                break;
                        }
                        else
                        {
                                retval = true;
                                break;
                        }

                  case NATIONAL:
                        if (checkFollowingToken == true)
                        {
                                switch (getToken(2).kind)
                                {
                                  case CHAR:
                                  case CHARACTER:
                                        retval = true;
                                        break;
                                }
                                break;
                        }
                        else
                        {
                                retval = true;
                                break;
                        }
                }

                return retval;
        }

        /**
	 * Get a DELETE node given the pieces.
	 *
	 *
	 *	@exception	StandardException
	 */
         private QueryTreeNode getDeleteNode(FromTable fromTable,
                                                                                 TableName tableName,
                                                                                 ValueNode whereClause)
                throws StandardException
        {
                FromList   fromList = (FromList) nodeFactory.getNode(
                                                                C_NodeTypes.FROM_LIST,
                                                                getContextManager());
                QueryTreeNode retval;
                SelectNode resultSet;

                fromList.addFromTable(fromTable);

                resultSet = (SelectNode) nodeFactory.getNode(
                                                                                C_NodeTypes.SELECT_NODE,
                                                                                null,
                                                                                null,   /* AGGREGATE list */
                                                                                fromList, /* FROM list */
                                                                                whereClause, /* WHERE clause */
                                                                                null, /* GROUP BY list */
                                                                                getContextManager());

                retval =
                        (QueryTreeNode) nodeFactory.getNode(
                                                        C_NodeTypes.DELETE_NODE,
                                                        tableName,
                                                        resultSet,
                                                        getContextManager());

                setUpAndLinkParameters();

                return retval;
        }

        /**
	 * Get an UPDATE node given the pieces.
	 *
	 *
	 *	@exception	StandardException
	 */
         private QueryTreeNode getUpdateNode(FromTable fromTable,
                                                                                 TableName tableName,
                                                                                 ResultColumnList setClause,
                                                                                 ValueNode whereClause)
                throws StandardException
        {
                FromList   fromList = (FromList) nodeFactory.getNode(
                                                                C_NodeTypes.FROM_LIST,
                                                                getContextManager());
                QueryTreeNode retval;
                SelectNode resultSet;

                fromList.addFromTable(fromTable);

                resultSet = (SelectNode) nodeFactory.getNode(
                                                                                C_NodeTypes.SELECT_NODE,
                                                                                setClause,
                                                                                null,   /* AGGREGATE list */
                                                                                fromList, /* FROM list */
                                                                                whereClause, /* WHERE clause */
                                                                                null, /* GROUP BY list */
                                                                                getContextManager());

                retval =
                        (QueryTreeNode) nodeFactory.getNode(
                                                        C_NodeTypes.UPDATE_NODE,
                                                        tableName,
                                                        resultSet,
                                                        getContextManager());

                setUpAndLinkParameters();

                return retval;
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a remainingPredicate() rule.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			remainingPredicate()
	 */
        private boolean remainingPredicateFollows()
        {
                boolean retval = false;

                switch (getToken(1).kind)
                {
                  case EQUALS_OPERATOR:
                  case NOT_EQUALS_OPERATOR:
                  case NOT_EQUALS_OPERATOR2: // !=
                  case LESS_THAN_OPERATOR:
                  case GREATER_THAN_OPERATOR:
                  case LESS_THAN_OR_EQUALS_OPERATOR:
                  case GREATER_THAN_OR_EQUALS_OPERATOR:
                  case IN:
                  case LIKE:
                  case BETWEEN:
                        retval = true;
                        break;

                  case NOT:
                        switch (getToken(2).kind)
                        {
                          case IN:
                          case LIKE:
                          case BETWEEN:
                                retval = true;
                        }
                        break;
                }

                return retval;
        }


        /**
	 * Determine whether the next token is a DROP
	 *
	 * @return	TRUE iff the next token is DROP
	 */
        private boolean dropFollows()
        {
                if (getToken(1).kind == DROP)
                { return true; }
                else { return false; }
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a escapedValueFunction().
	 *
	 * We check only for the punctuation here, because identifiers are
	 * very hard to check for in semantic lookahead.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			escapedValueFunction()
	 */
        private boolean escapedValueFunctionFollows()
        {
                if (getToken(1).kind != LEFT_BRACE)
                {
                        return false;
                }

                return getToken(2).kind == FN;
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a columnInvocation() rule.  columnInvocations start with
	 * [ [ id . ] id . ] id . id (
	 *
	 * We check only for the punctuation here, because identifiers are
	 * very hard to check for in semantic lookahead.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			columnInvocation()
	 */
        private boolean columnMethodInvocationFollows()
        {
                int tokKind;

                // First token must not be a built-in function name that can be
                // followed immediately by a PERIOD. There are only a few of
                // these - most built-in functions have a LEFT_PAREN following
                // the function name.

                // if we run out of token, it's probably a syntax error,  
                // in fact
                tokKind = getToken(1).kind;
                if ( tokKind == EOF ) { return false; }

                // disambiguate from named parameter reference
                if ( getToken(1).image.charAt(0) == '?' ) { return false; }

                if (tokKind == CURRENT_DATE ||
                        tokKind == CURRENT_TIME ||
                        tokKind == CURRENT_TIMESTAMP ||
                        tokKind == CURRENT && (isDATETIME(getToken(2).kind)) )
                {
                        return false;
                }

                // Second token must be a PERIOD
                if (getToken(2).kind != PERIOD)
                {
                        return false;
                }

                // We have established that we start with " id . "
                tokKind = getToken(4).kind;
                if (tokKind == LEFT_PAREN)
                {
                        // id.id(
                        return true;
                }

                // Not id.id(, so 4th token must be PERIOD
                if (tokKind != PERIOD)
                {
                        return false;
                }

                tokKind = getToken(6).kind;
                if (tokKind == LEFT_PAREN)
                {
                        // id.id.id(
                        return true;
                }

                // Not id.id.id(, so 6th token must be PERIOD
                if (tokKind != PERIOD)
                {
                        return false;
                }

                tokKind = getToken(8).kind;
                if (tokKind == LEFT_PAREN)
                {
                        // id.id.id.id(
                        return true;
                }

                return false;
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of an aggregateNode()() rule.  aggregateNodes() start with one
	 * of the built-in aggregate names, or with an identifier followed
	 * by "( DISTINCT". A non-distinct user-defined aggregate invocation
	 * is treated as a staticMethodInvocationAlias() by the parser,
	 * and the binding phase figures out what it really is by looking
	 * at the data dictionary.
	 *
	 * We check only for the punctuation here, because identifiers are
	 * very hard to check for in semantic lookahead.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			aggregateNode()
	 */
        private boolean aggregateFollows()
        {
                boolean retval = false;

                switch (getToken(1).kind)
                {
                  case COUNT:
                  case MAX:
                  case AVG:
                  case MIN:
                  case SUM:
                        // This is a built-in aggregate
                        retval = true;
                        break;

                  default:
                        // Not a built-in aggregate - assume the first token is an
                        // identifier, and see whether it is followed by " ( DISTINCT "
                        if (getToken(2).kind == LEFT_PAREN && getToken(3).kind == DISTINCT)
                                retval = true;
                        break;
                }

                return retval;
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a miscBuiltins().
	 *
	 * We check only for the punctuation here, because identifiers are
	 * very hard to check for in semantic lookahead.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			aggregateNode()
	 */
        private boolean miscBuiltinFollows()
        {
                boolean retval = false;
                int tokKind = getToken(1).kind;

                if (getToken(0).kind == CALL)
                        retval = true;

                switch (tokKind)
                {
                  case GET_CURRENT_CONNECTION:
                  case CURRENT_DATE:
                  case CURRENT_TIME:
                  case CURRENT_TIMESTAMP:
                        retval = true;
                        break;

                  case CURRENT:
                        if (isDATETIME(getToken(2).kind))
                                retval = true;
                        break;

                  case CAST:
                  case LEFT_PAREN:
                        retval = false;
                        break;

                  default:
                    if (getToken(2).kind == LEFT_PAREN)
                                retval = true;
                        break;
                }

                return retval;
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a subquery. A subquery can begin with an arbitrary number of
	 * left parentheses, followed by either SELECT or VALUES.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			subquery.
	 */
        private boolean subqueryFollows()
        {
                int tokKind;
                boolean retval = false;

                for (int i = 1; true; i++)
                {
                        tokKind = getToken(i).kind;
                        if (tokKind == LEFT_PAREN)
                        {
                                // A subquery can start with an arbitrary number of left
                                // parentheses.
                                continue;
                        }
                        else if (tokKind == SELECT || tokKind == VALUES)
                        {
                                // If the first token we find after all the left parentheses
                                // is SELECT or VALUES, it's a subquery.
                                retval = true;
                                break;
                        }
                        else
                        {
                                // If the first token we find after all the left parentheses
                                // is neither SELECT nor VALUES, it's not a subquery.
                                break;
                        }
                }

                return retval;
        }


        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a rowValueConstructorList. A rowValueConstructorList is a comma-
	 * separated list of expressions enclosed in parentheses. This presents
	 * special problems, because an expression be nested within an
	 * arbitrary number of parentheses. To determine whether a left
	 * parenthesis introduces a rowValueConstructorList or an expression,
	 * we need to find the closing parenthesis, and determine whether
	 * the next token is a comma.
	 *
	 * For example, the following is a rowValueConstructorList:
	 *
	 *		(((1)), 2)
	 *
	 * and the following is just an expression:
	 *
	 *		(((1)))
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			subquery.
	 */
        private boolean rowValueConstructorListFollows()
        {
                int nesting;
                boolean retval = false;

                // A rowValueConstructorList starts with a left parenthesis
                if (getToken(1).kind == LEFT_PAREN)
                {
                        // Keep track of the nesting of parens while looking ahead
                        nesting = 1;
                        for (int i = 2; true; i++)
                        {
                                int tokKind = getToken(i).kind;

                                // Special case for NULL/DEFAULT because they are not allowed in
                                // a parenthesized expression, so (null)/(default) must be seen
                                // as a rowValueConstructorList with one element.
                                if (i == 2 && (tokKind == NULL || tokKind == _DEFAULT))
                                {
                                        retval = true;
                                        break;
                                }

                                // There must be a COMMA at nesting level 1 (i.e. outside of
                                // the first expression) for it to be a rowValueConstructorList
                                if (nesting == 1 && tokKind == COMMA)
                                {
                                        retval = true;
                                        break;
                                }

                                // If we run out of tokens before finding the last closing
                                // parenthesis, it's not a rowValueConstructorList (it's
                                // probably a syntax error, in fact)
                                if (tokKind == EOF)
                                {
                                        break;
                                }

                                // Increase the nesting for each (, and decrease it for each )
                                if (tokKind == LEFT_PAREN)
                                {
                                        nesting++;
                                }
                                else if (tokKind == RIGHT_PAREN)
                                {
                                        nesting--;
                                }

                                // Don't look any farther than the last closing parenthesis
                                if (nesting == 0)
                                {
                                        break;
                                }
                        }
                }

                return retval;
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a propertyList(). A properties list is the word "properties"
	 * followed by a dot-separated list, followed by an =,
	 * followed by a value. This means that the first token must be the word
	 * "properties", and the third must be a period (from the dot-separated
	 * list) or an =.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			propertyList().
	 */
        private boolean propertyListFollows()
        {
                int tokKind;

                return
                        getToken(1).kind == PROPERTIES &&
                                ((tokKind = getToken(3).kind) == PERIOD ||
                                        tokKind == EQUALS_OPERATOR
                                );
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a newInvocation(). A newInvocation() begins with the word "new"
	 * followed by a dot-separated list of identifiers, followed
	 * by a left parenthesis.
	 *
	 * @param startToken	Token to look for new at
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			newInvocation().
	 */
        private boolean newInvocationFollows(int startToken)
        {
                boolean retval = false;

                // newInvocation() starts with the word "new"
                if (getToken(startToken).kind == NEW)
                {
                        // Look at every other token. Ignore the identifiers, because
                        // they are hard to test for.
                        for (int i = 2 + startToken; true; i += 2)
                        {
                                int tokKind = getToken(i).kind;

                                // If we find a left parenthesis without any intervening
                                // cruft, we have found a newInvocation()
                                if (tokKind == LEFT_PAREN)
                                {
                                        retval = true;
                                        break;
                                }
                                else if (tokKind != PERIOD)
                                {
                                        // Anything other than a PERIOD is "cruft"
                                        break;
                                }
                        }
                }

                return retval;
        }
        /**
	 * Determine whether the next sequence of tokens is a class name
	 *
	 * @param startToken	Token to look for class name at
	 *
	 * @return	TRUE iff the next set of tokens is the java class name
	 */
        boolean javaClassFollows()
        {
                boolean retval = false;

                // Look at every other token. Ignore the identifiers, because
                // they are hard to test for.
                for (int i = 2; true; i += 2)
                {
                        int tokKind = getToken(i).kind;

                        // If we find a '::' without any intervening
                        // cruft, we have found a javaClass
                        if (tokKind == DOUBLE_COLON)
                        {
                                retval = true;
                                break;
                        }
                        else if (tokKind != PERIOD)
                        {
                                // Anything other than a PERIOD is "cruft"
                                break;
                        }
                }

                return retval;
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a FROM newInvocation(). A FROM newInvocation() begins with the words "from new"
	 * followed by a dot-separated list of identifiers, followed
	 * by a left parenthesis.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			FROM newInvocation().
	 */
        private boolean fromNewInvocationFollows()
        {
                boolean retval = false;

                // FROM newInvocation() starts with the words "from new"
                return (getToken(1).kind == FROM && newInvocationFollows(2));
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a joinedTableExpression(). A joinedTableExpression() begins
	 * with one of:
	 *
	 *	JOIN
	 *	INNER JOIN
	 *	LEFT OUTER JOIN
	 *	RIGHT OUTER JOIN
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			joinedTableExpression().
	 */
        private boolean joinedTableExpressionFollows()
        {
                boolean retval = false;

                int tokKind1 = getToken(1).kind;
                int tokKind2 = getToken(2).kind;

                if (tokKind1 == JOIN)
                {
                        retval = true;
                }
                else if (tokKind1 == INNER && tokKind2 == JOIN)
                {
                        retval = true;
                }
                else if ((tokKind1 == LEFT || tokKind1 == RIGHT) && tokKind2 == OUTER)
                {
                        if (getToken(3).kind == JOIN)
                        {
                                retval = true;
                        }
                }
                else if ((tokKind1 == LEFT || tokKind1 == RIGHT) && tokKind2 == JOIN)
                {
                        retval = true;
                }

                return retval;
        }

        /**
	 * Translate a token for the name of a built-in aggregate to a String
	 * containing an aggregate name.
	 */
        private static String aggName(Token token)
        {
                String  retval = null;

                switch (token.kind)
                {
                  case MAX:
                        retval = "MAX";
                        break;

                  case AVG:
                    retval = "AVG";
                        break;

                  case MIN:
                    retval = "MIN";
                        break;

                  case SUM:
                    retval = "SUM";
                        break;

                  case COUNT:
                    retval = "COUNT";
                        break;

                  default:
                        if (SanityManager.DEBUG)
                        {
                                SanityManager.THROWASSERT("Unexpected token type in aggName: " +
                                                                                        token.kind);
                        }
                        break;
                }

                return retval;
        }

        /**
	 * Translate a token for the name of a built-in aggregate to an
	 * aggregate definition class.
	 */
        private static Class aggClass(Token token)
        {
                Class   retval = null;

                switch (token.kind)
                {
                  case MAX:
                  case MIN:
                        retval = MaxMinAggregateDefinition.class;
                        break;

                  case AVG:
                  case SUM:
                        retval = SumAvgAggregateDefinition.class;
                        break;

                  case COUNT:
                    retval = CountAggregateDefinition.class;
                        break;

                  default:
                        if (SanityManager.DEBUG)
                        {
                                SanityManager.THROWASSERT("Unexpected token type in aggClass: "
                                                                                        + token.kind);
                        }
                        break;
                }

                return retval;
        }

        /**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of another element in a PROPERTY list. These elements are of the
	 * form:
	 *
	 *		COMMA dot.separated.list = ...
	 *
	 * Look for the COMMA, the dots in the dot-separated list, and the =
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			another element in a PROPERTY list.
	 */
        private boolean anotherPropertyFollows()
        {
                boolean retval = false;

                // Element must start with COMMA
                if (getToken(1).kind == COMMA)
                {
                        // Rest of element is dot-separated list with = at end
                        int i = 3;
                        int tokKind;
                        do
                        {
                                tokKind = getToken(i).kind;

                                // If we've found nothing but PERIODs until the EQUALS_OPERATOR
                                // it is the beginning of another property list element.
                                if (tokKind == EQUALS_OPERATOR)
                                {
                                        retval = true;
                                        break;
                                }

                                i += 2;
                        } while (tokKind == PERIOD);
                }

                return retval;
        }

        /**
	 * Get one of the several types of create alias nodes.
	 *
	 * @param aliasName	The name of the alias
	 * @param fullStaticMethodName	The full path/method name
	 * @param aliasSpecificInfo	 Information specific to the type of alias being created.
	 * @param aliasType	The type of alias to create
	 * @param delimitedIdentifier	Whether or not to treat the class name
	 *								as a delimited identifier if trying to
	 *								resolve it as a class alias.
	 *
	 * @return	A CreateAliasNode matching the given parameters
	 *
	 * @exception StandardException		Thrown on error
	 */
        QueryTreeNode
        getCreateAliasNode(
                Object aliasName,
                String fullStaticMethodName,
                Object aliasSpecificInfo,
                char aliasType,
                Boolean delimitedIdentifier)
                throws StandardException
        {

                StatementNode aliasNode = (StatementNode) getNodeFactory().getCreateAliasNode
                        (
                                aliasName,
                                fullStaticMethodName,
                                aliasSpecificInfo,
                                aliasType,
                                delimitedIdentifier,
                                getContextManager()
                        );

                return aliasNode;
        }

        /**
		Create a node for the drop alias/procedure call.
	*/
        QueryTreeNode
        dropAliasNode(Object aliasName, char type) throws StandardException
        {

                StatementNode stmt = (StatementNode) nodeFactory.getNode(
                                                                C_NodeTypes.DROP_ALIAS_NODE,
                                                                aliasName,
                                                                new Character(type),
                                                                getContextManager());

                return stmt;
        }

    /**
     * Get a substring node from
     *      - the string
     *      - the start position
     *      - the length
     *      - a boolean values for specifying the kind of substring function
     * @exception StandardException  Thrown on error
     */
    ValueNode getSubstringNode( ValueNode stringValue, ValueNode startPosition,
                         ValueNode length, Boolean boolVal ) throws StandardException
    {
        return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.SUBSTRING_OPERATOR_NODE,
                                                stringValue,
                                                startPosition,
                                                length,
                                                ReuseFactory.getInteger(TernaryOperatorNode.SUBSTRING),
                                                null,
                                                    getContextManager());
    }

    final public TableName
    qualifiedName(int id_length_limit) throws ParseException, StandardException
    {
        return qualifiedName( C_NodeTypes.TABLE_NAME, id_length_limit);
    }

    private void initStatement( String statementSQLText, Object[] paramDefaults)
        throws StandardException
    {
        /* Do per-statement initialization here */
        parameterNumber = 0;
        stringSlicer = null;
        this.statementSQLText = statementSQLText;
        this.paramDefaults = paramDefaults;
        nodeFactory = getNodeFactory();
        initUnnamedParameterList();
    } // End of initStatement

    private void checkIdentifierLengthLimit( String identifier, int identifier_length_limit)
        throws StandardException
    {
        if (identifier.length() > identifier_length_limit)
                throw StandardException.newException(SQLState.LANG_IDENTIFIER_TOO_LONG, identifier, String.valueOf(identifier_length_limit));
    }

    private ValueNode getJdbcIntervalNode( int intervalType) throws StandardException
    {
        return (ValueNode) nodeFactory.getNode( C_NodeTypes.INT_CONSTANT_NODE,
                                                ReuseFactory.getInteger( intervalType),
                                                getContextManager());
    }

/*
 * <A NAME="Statement">Statement</A>
 */
  final public QueryTreeNode Statement(String statementSQLText, Object[] paramDefaults) throws ParseException, StandardException {
        QueryTreeNode   statementNode;

        initStatement(statementSQLText, paramDefaults);
    statementNode = StatementPart(null);
    jj_consume_token(0);
                {if (true) return statementNode;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode proceduralStatement(Token[] tokenHolder) throws ParseException, StandardException {
        QueryTreeNode statementNode;
        tokenHolder[0] = getToken(1);
    switch (jj_nt.kind) {
    case INSERT:
      statementNode = insertStatement();
      break;
    case UPDATE:
      statementNode = preparableUpdateStatement();
      break;
    case DELETE:
      statementNode = preparableDeleteStatement();
      break;
    case SELECT:
    case VALUES:
    case LEFT_PAREN:
      statementNode = preparableSelectStatement(true);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return statementNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="StatementPart">StatementPart</A>
 * 
 * @param tokenHolder returns the token that starts
 * the statement.  If null, ignored.
 */
  final public QueryTreeNode StatementPart(Token[] tokenHolder) throws ParseException, StandardException {
        QueryTreeNode   statementNode;
        //before starting new statements, initialize this variables. Otherwise, the left
        //over values from previously failed sql will affect the next sql. 
        explicitNotNull = false;
        explicitNull = false;
        explicitlyNullableColumnsList = new Vector();

        /*
	** Grab the token preceding this production
	*/
        if (tokenHolder != null)
        {
                tokenHolder[0] = getToken(1);
        }
    switch (jj_nt.kind) {
    case LOCK:
    case RENAME:
      switch (jj_nt.kind) {
      case RENAME:
        statementNode = spsRenameStatement();
        break;
      case LOCK:
        // statementNode = SQLTransactionStatement() |
                statementNode = lockStatement();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        {if (true) return statementNode;}
      break;
    default:
      jj_la1[4] = jj_gen;
      if (jj_2_2(1)) {
        switch (jj_nt.kind) {
        case CREATE:
          statementNode = createStatements();
          break;
        case DROP:
          statementNode = dropStatements();
          break;
        case ALTER:
          statementNode = spsAlterStatement();
          break;
        case DECLARE:
          statementNode = globalTemporaryTableDeclaration();
          break;
        case DELETE:
        case INSERT:
        case ROLLBACK:
        case SELECT:
        case UPDATE:
        case VALUES:
        case RELEASE:
        case SAVEPOINT:
        case CALL:
        case LEFT_BRACE:
        case LEFT_PAREN:
        case QUESTION_MARK:
          statementNode = preparableSQLDataStatement();
          break;
        default:
          jj_la1[2] = jj_gen;
          if (jj_2_1(1)) {
            statementNode = spsSetStatement();
          } else {
            switch (jj_nt.kind) {
            case TRUNCATE:
              statementNode = truncateTableStatement();
              break;
            case EXECUTE:
              statementNode = execStatement();
              break;
            default:
              jj_la1[3] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        {if (true) return statementNode;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="createStatements">spsCreateStatement</A>
 */
  final public QueryTreeNode createStatements() throws ParseException, StandardException {
        QueryTreeNode statementNode;
        Token beginToken;
        int tokKind;
    beginToken = jj_consume_token(CREATE);
    switch (jj_nt.kind) {
    case SCHEMA:
    case VIEW:
    case SYNONYM:
    case TRIGGER:
      switch (jj_nt.kind) {
      case SCHEMA:
        statementNode = schemaDefinition();
        break;
      case VIEW:
        statementNode = viewDefinition(beginToken);
        break;
      case TRIGGER:
        statementNode = triggerDefinition();
        break;
      case SYNONYM:
        statementNode = synonymDefinition();
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }

      break;
    case TABLE:
      statementNode = tableDefinition();

      break;
    case PROCEDURE:
      statementNode = procedureDefinition();
      break;
    case FUNCTION:
      statementNode = functionDefinition();
      break;
    case UNIQUE:
    case INDEX:
      statementNode = indexDefinition();

      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return statementNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dropStatements">spsDropStatement</A>
 */
  final public QueryTreeNode dropStatements() throws ParseException, StandardException {
        QueryTreeNode statementNode;
    jj_consume_token(DROP);
    switch (jj_nt.kind) {
    case SCHEMA:
      statementNode = dropSchemaStatement();
      break;
    case TABLE:
      statementNode = dropTableStatement();
      break;
    case INDEX:
      statementNode = dropIndexStatement();
      break;
    case FUNCTION:
    case PROCEDURE:
    case SYNONYM:
      statementNode = dropAliasStatement();
      break;
    case VIEW:
      statementNode = dropViewStatement();
      break;
    case TRIGGER:
      statementNode = dropTriggerStatement();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return statementNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="spsAlterStatement">spsAlterStatement</A>
 */
  final public QueryTreeNode spsAlterStatement() throws ParseException, StandardException {
        QueryTreeNode statementNode;
    jj_consume_token(ALTER);
    statementNode = alterTableStatement();
                {if (true) return statementNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="spsSetStatement">spsSetStatement</A>
 */
  final public QueryTreeNode spsSetStatement() throws ParseException, StandardException {
        QueryTreeNode statementNode;
    if (getToken(1).kind == SET && getToken(2).kind != CURRENT) {
      jj_consume_token(SET);
      if (jj_2_3(1)) {
        statementNode = setIsolationStatement();
      } else if (jj_2_4(1)) {
        statementNode = setSchemaStatement();
      } else {
        switch (jj_nt.kind) {
        case MESSAGE_LOCALE:
          statementNode = setMessageLocaleStatement();
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
                {if (true) return statementNode;}
    } else if (getToken(1).kind == SET && getToken(2).kind == CURRENT) {
      jj_consume_token(SET);
      if (jj_2_5(1)) {
        statementNode = setSchemaStatement();
      } else if (jj_2_6(1)) {
        statementNode = setIsolationStatement();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
                {if (true) return statementNode;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="preparableSQLDataStatement">preparableSQLDataStatement</A>
 *
 * preparableSQLDataStatement differs from
 * directSQLDataStatement in that it
 * supports positioned update and delete
 * and a preparable select (with FOR UPDATE)
 * instead of a direct select (without FOR UPDATE)
 */
  final public QueryTreeNode preparableSQLDataStatement() throws ParseException, StandardException {
        QueryTreeNode   dmlStatement;
    switch (jj_nt.kind) {
    case DELETE:
      /*
      	** RESOLVE: Ignoring temporary table declarations for now.
      	*/
              dmlStatement = preparableDeleteStatement();
                {if (true) return dmlStatement;}
      break;
    case SELECT:
    case VALUES:
    case LEFT_PAREN:
      dmlStatement = preparableSelectStatement(true);
                {if (true) return dmlStatement;}
      break;
    case INSERT:
      dmlStatement = insertStatement();
                {if (true) return dmlStatement;}
      break;
    case UPDATE:
      dmlStatement = preparableUpdateStatement();
                {if (true) return dmlStatement;}
      break;
    case CALL:
    case LEFT_BRACE:
    case QUESTION_MARK:
      dmlStatement = callStatement();
                {if (true) return dmlStatement;}
      break;
    case ROLLBACK:
    case RELEASE:
    case SAVEPOINT:
      dmlStatement = savepointStatement();
                {if (true) return dmlStatement;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="preparableDeleteStatement">preparableDeleteStatement</A>
 *
 *	This may be a search or positioned delete statement.
 */
  final public QueryTreeNode preparableDeleteStatement() throws ParseException, StandardException {
        QueryTreeNode qtn;
    jj_consume_token(DELETE);
    qtn = deleteBody();
                {if (true) return qtn;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode deleteBody() throws ParseException, StandardException {
        JavaToSQLValueNode      javaToSQLNode = null;
        TableName  tableName = null;
        ValueNode  whereClause = null;
        FromTable  fromTable = null;
        QueryTreeNode retval;
        Properties targetProperties = null;
        Token      whereToken = null;
    if (fromNewInvocationFollows()) {
      jj_consume_token(FROM);
      javaToSQLNode = newInvocation();
      switch (jj_nt.kind) {
      case WHERE:
        whereToken = jj_consume_token(WHERE);
        whereClause = whereClause(whereToken);
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
                fromTable =  (FromTable) nodeFactory.getNode(
                                                                        C_NodeTypes.FROM_VTI,
                                                                        javaToSQLNode.getJavaValueNode(),
                                                                        (String) null,
                                                                        null,
                                                                        (Properties) null,
                                                                        getContextManager());

                {if (true) return getDeleteNode(fromTable, tableName, whereClause);}
    } else {
      switch (jj_nt.kind) {
      case FROM:
        jj_consume_token(FROM);
        tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        switch (jj_nt.kind) {
        case PROPERTIES:
          targetProperties = propertyList();
          break;
        default:
          jj_la1[11] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case WHERE:
          whereToken = jj_consume_token(WHERE);
          if ((getToken(1).kind == CURRENT) &&
                                                   (getToken(2).kind == OF)) {
            fromTable = currentOfClause();
          } else if (jj_2_7(1)) {
            whereClause = whereClause(whereToken);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
                /* Fabricate a ResultSetNode (SelectNode) under the DeleteNode.
		 * For a searched delete,
		 * The FromList is simply the table that we are deleting from.
		 * (NOTE - we mark the table as the one that we are deleting from.)
		 * For a positioned delete,
		 * the FromList is a CurrentOfNode holding the cursor name.
		 * The select list will be null for now.  We will generate it at
	 	 * bind time, in keeping with the design decision that the parser's
	  	 * output should look like the language.
		 */
                if (fromTable == null)
                        fromTable = (FromTable) nodeFactory.getNode(
                                                                                C_NodeTypes.FROM_BASE_TABLE,
                                                                                tableName,
                                                                                null,
                                                                                ReuseFactory.getInteger(
                                                                                                FromBaseTable.DELETE),
                                                                                null,
                                                                                getContextManager());

                /* Update the FromTable with any properties, if non-null */
                if (targetProperties != null)
                {
                        if (SanityManager.DEBUG)
                        {
                                if (((FromBaseTable) fromTable).getProperties() != null)
                                {
                                        SanityManager.THROWASSERT(
                                                "Overwriting existing properties");
                                }
                        }
                        ((FromBaseTable) fromTable).setTableProperties(targetProperties);
                }

                {if (true) return getDeleteNode(fromTable, tableName, whereClause);}
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="currentOfClause">currentOfClause</A>
 */
  final public FromTable currentOfClause() throws ParseException, StandardException {
        String cursorName = null;
    jj_consume_token(CURRENT);
    jj_consume_token(OF);
    cursorName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                {if (true) return (FromTable) nodeFactory.getNode(
                                                                C_NodeTypes.CURRENT_OF_NODE,
                                                                cursorName,
                                                                null,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="preparableSelectStatement">preparableSelectStatement</A>
 *
 *
 *	The preparable select statement is a superset of
 *	the directSelectStatementMultipleRows in that it
 *	allows both the preparable single row select statement
 *	(a query expression that returns one row, although it
 *	is also handled like a cursor) and the preparable
 *	multiple row select statement, which allows not only
 *	an order by clause but also a for update clause.
 */
  final public CursorNode preparableSelectStatement(boolean checkParams) throws ParseException, StandardException {
        ResultSetNode     queryExpression;
        Vector  updateColumns = new Vector();
        int               forUpdateState = CursorNode.UNSPECIFIED;
        int                               isolationLevel = ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
        CursorNode                retval;
        OrderByList orderCols = null;
    queryExpression = queryExpression(null, NO_SET_OP);
    switch (jj_nt.kind) {
    case ORDER:
      orderCols = orderByClause();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case FOR:
      jj_consume_token(FOR);
      forUpdateState = forUpdateClause(updateColumns);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case WITH:
      isolationLevel = atIsolationLevel();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
                // Note: if order by is specified, the for update clause
                // must be READ ONLY or empty, and the cursor
                // is implicitly READ_ONLY.

                retval = (CursorNode) nodeFactory.getNode(
                                C_NodeTypes.CURSOR_NODE,
                                "SELECT",
                                queryExpression,
                                null,
                                orderCols,
                                ReuseFactory.getInteger(forUpdateState),
                                (forUpdateState == CursorNode.READ_ONLY ? null : updateColumns ),
                                getContextManager());

                if (checkParams)
                {
                        setUpAndLinkParameters();
                }

                /* Set the isolation levels for the scans if specified */
                if (isolationLevel != ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL)
                {
                        getCompilerContext().setScanIsolationLevel(isolationLevel);
                }

                {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="insertStatement">insertStatement</A>
 */
  final public QueryTreeNode insertStatement() throws ParseException, StandardException {
        QueryTreeNode   insertNode;
        QueryTreeNode   targetTable;
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    targetTable = targetTable();
    insertNode = insertColumnsAndSource(targetTable);
                setUpAndLinkParameters();

                {if (true) return insertNode;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode targetTable() throws ParseException, StandardException {
        JavaToSQLValueNode      javaToSQLNode = null;
        String                          correlationName = null;
        TableName                       tableName;
    if (newInvocationFollows(1)) {
      javaToSQLNode = newInvocation();
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.FROM_VTI,
                                                                javaToSQLNode.getJavaValueNode(),
                                                                correlationName,
                                                                null,
                                                                (Properties) null,
                                                                getContextManager());}
    } else {
      switch (jj_nt.kind) {
      case BINARY:
      case COALESCE:
      case D:
      case MODULE:
      case T:
      case TS:
      case VALUE:
      case VARBINARY:
      case ABS:
      case ABSVAL:
      case ACTION:
      case ALWAYS:
      case BLOB:
      case C:
      case CALLED:
      case CLOB:
      case COBOL:
      case COMMITTED:
      case CONCAT:
      case CONTAINS:
      case DATA:
      case DATE:
      case DAY:
      case DYNAMIC:
      case FORTRAN:
      case GENERATED:
      case IDENTITY_VAL_LOCAL:
      case INCREMENT:
      case INITIAL:
      case INTERVAL:
      case LANGUAGE:
      case LARGE:
      case LENGTH:
      case LEVEL:
      case LOCKS:
      case LOCKSIZE:
      case LOGGED:
      case MOD:
      case MODIFIES:
      case MODIFY:
      case MONTH:
      case _MORE:
      case MUMPS:
      case NAME:
      case NCLOB:
      case NULLABLE:
      case NUMBER:
      case OBJECT:
      case PASCAL:
      case PLI:
      case PRECISION:
      case RELEASE:
      case REPEATABLE:
      case RETURNS:
      case ROW:
      case SAVEPOINT:
      case SCALE:
      case SERIALIZABLE:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_HOUR:
      case SQL_TSI_DAY:
      case SQL_TSI_WEEK:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case START:
      case STATEMENT:
      case SYNONYM:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TRUNCATE:
      case TYPE:
      case UNCOMMITTED:
      case USAGE:
      case WHEN:
      case CURDATE:
      case CURTIME:
      case DATABASE:
      case LONG:
      case AFTER:
      case BEFORE:
      case CLASS:
      case COMPRESS:
      case CONTENT:
      case CS:
      case DB2SQL:
      case DIRTY:
      case DOCUMENT:
      case EACH:
      case EXCLUSIVE:
      case FN:
      case INDEX:
      case JAVA:
      case LCASE:
      case LOCATE:
      case LOCK:
      case MESSAGE_LOCALE:
      case METHOD:
      case MODE:
      case NEW:
      case NEW_TABLE:
      case OJ:
      case OFF:
      case OLD:
      case OLD_TABLE:
      case PARAMETER:
      case PASSING:
      case PROPERTIES:
      case READS:
      case REF:
      case REFERENCING:
      case RENAME:
      case RESET:
      case RESULT:
      case RETAIN:
      case RR:
      case RS:
      case SEQUENTIAL:
      case SETS:
      case SHARE:
      case SQLID:
      case SPECIFIC:
      case SQRT:
      case STABILITY:
      case STRIP:
      case STYLE:
      case TRIGGER:
      case UCASE:
      case UR:
      case WHITESPACE:
      case IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (QueryTreeNode) tableName;}
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="preparableUpdateStatement">preparableUpdateStatement</A>
 */
  final public QueryTreeNode preparableUpdateStatement() throws ParseException, StandardException {
        QueryTreeNode qtn;
    jj_consume_token(UPDATE);
    qtn = updateBody();
                {if (true) return qtn;}
    throw new Error("Missing return statement in function");
  }

  final public boolean tableOrIndex() throws ParseException {
    switch (jj_nt.kind) {
    case TABLE:
      jj_consume_token(TABLE);
                {if (true) return true;}
      break;
    case INDEX:
      jj_consume_token(INDEX);
                {if (true) return false;}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode updateBody() throws ParseException, StandardException {
        ResultColumnList        columnList;
        JavaToSQLValueNode      javaToSQLNode = null;
        TableName  tableName = null;
        ValueNode  whereClause = null;
        FromTable  fromTable = null;
        Properties targetProperties = null;
        Token      whereToken = null;
    if (newInvocationFollows(1)) {
      javaToSQLNode = newInvocation();
      jj_consume_token(SET);
      columnList = setClauseList();
      switch (jj_nt.kind) {
      case WHERE:
        whereToken = jj_consume_token(WHERE);
        whereClause = whereClause(whereToken);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
                fromTable =  (FromTable) nodeFactory.getNode(
                                                                        C_NodeTypes.FROM_VTI,
                                                                        javaToSQLNode.getJavaValueNode(),
                                                                        (String) null,
                                                                        null,
                                                                        (Properties) null,
                                                                        getContextManager());

                {if (true) return getUpdateNode(fromTable, tableName, columnList, whereClause);}
    } else {
      switch (jj_nt.kind) {
      case BINARY:
      case COALESCE:
      case D:
      case MODULE:
      case T:
      case TS:
      case VALUE:
      case VARBINARY:
      case ABS:
      case ABSVAL:
      case ACTION:
      case ALWAYS:
      case BLOB:
      case C:
      case CALLED:
      case CLOB:
      case COBOL:
      case COMMITTED:
      case CONCAT:
      case CONTAINS:
      case DATA:
      case DATE:
      case DAY:
      case DYNAMIC:
      case FORTRAN:
      case GENERATED:
      case IDENTITY_VAL_LOCAL:
      case INCREMENT:
      case INITIAL:
      case INTERVAL:
      case LANGUAGE:
      case LARGE:
      case LENGTH:
      case LEVEL:
      case LOCKS:
      case LOCKSIZE:
      case LOGGED:
      case MOD:
      case MODIFIES:
      case MODIFY:
      case MONTH:
      case _MORE:
      case MUMPS:
      case NAME:
      case NCLOB:
      case NULLABLE:
      case NUMBER:
      case OBJECT:
      case PASCAL:
      case PLI:
      case PRECISION:
      case RELEASE:
      case REPEATABLE:
      case RETURNS:
      case ROW:
      case SAVEPOINT:
      case SCALE:
      case SERIALIZABLE:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_HOUR:
      case SQL_TSI_DAY:
      case SQL_TSI_WEEK:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case START:
      case STATEMENT:
      case SYNONYM:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TRUNCATE:
      case TYPE:
      case UNCOMMITTED:
      case USAGE:
      case WHEN:
      case CURDATE:
      case CURTIME:
      case DATABASE:
      case LONG:
      case AFTER:
      case BEFORE:
      case CLASS:
      case COMPRESS:
      case CONTENT:
      case CS:
      case DB2SQL:
      case DIRTY:
      case DOCUMENT:
      case EACH:
      case EXCLUSIVE:
      case FN:
      case INDEX:
      case JAVA:
      case LCASE:
      case LOCATE:
      case LOCK:
      case MESSAGE_LOCALE:
      case METHOD:
      case MODE:
      case NEW:
      case NEW_TABLE:
      case OJ:
      case OFF:
      case OLD:
      case OLD_TABLE:
      case PARAMETER:
      case PASSING:
      case PROPERTIES:
      case READS:
      case REF:
      case REFERENCING:
      case RENAME:
      case RESET:
      case RESULT:
      case RETAIN:
      case RR:
      case RS:
      case SEQUENTIAL:
      case SETS:
      case SHARE:
      case SQLID:
      case SPECIFIC:
      case SQRT:
      case STABILITY:
      case STRIP:
      case STYLE:
      case TRIGGER:
      case UCASE:
      case UR:
      case WHITESPACE:
      case IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        switch (jj_nt.kind) {
        case PROPERTIES:
          targetProperties = propertyList();
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
        }
        jj_consume_token(SET);
        columnList = setClauseList();
        switch (jj_nt.kind) {
        case WHERE:
          whereToken = jj_consume_token(WHERE);
          if (jj_2_8(1)) {
            whereClause = whereClause(whereToken);
          } else {
            switch (jj_nt.kind) {
            case CURRENT:
              fromTable = currentOfClause();
              break;
            default:
              jj_la1[21] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
                /* Fabricate a ResultSetNode (SelectNode) under the UpdateNode.
		 * For a searched update,
		 * The FromList is simply the table that we are updating.
		 * For a positioned update,
		 * the FromList is a CurrentOfNode holding the cursor name.
		 * (NOTE - we mark the table as the one that we are updating.)
		 * The select list is the columns in the SET clause.  At bind time,
	 	 * we will prepend the CurrentRowLocation() in keeping with the design 
		 * decision that the parser's output should look like the language.
		 */
                if (fromTable == null)
                        fromTable = (FromTable) nodeFactory.getNode(
                                                                                C_NodeTypes.FROM_BASE_TABLE,
                                                                                tableName,
                                                                                null,
                                                                                ReuseFactory.getInteger(
                                                                                                                FromBaseTable.UPDATE),
                                                                                null,
                                                                                getContextManager());

                /* Update the FromTable with any properties, if non-null */
                if (targetProperties != null)
                {
                        if (SanityManager.DEBUG)
                        {
                                if (((FromBaseTable) fromTable).getProperties() != null)
                                {
                                        SanityManager.THROWASSERT(
                                                "Overwriting existing properties");
                                }
                        }
                        ((FromBaseTable) fromTable).setTableProperties(targetProperties);
                }
                {if (true) return getUpdateNode(fromTable, tableName, columnList, whereClause);}
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="callStatement">callStatement</A>
 */
  final public QueryTreeNode callStatement() throws ParseException, StandardException {
        QueryTreeNode retval;
    switch (jj_nt.kind) {
    case CALL:
    case QUESTION_MARK:
      retval = bareCallStatement();
      break;
    case LEFT_BRACE:
      jj_consume_token(LEFT_BRACE);
      retval = bareCallStatement();
      jj_consume_token(RIGHT_BRACE);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="bareCallStatement">baseCallStatement</A>
 */
  final public QueryTreeNode bareCallStatement() throws ParseException, StandardException {
        ParameterNode           returnParam = null;
        String                          methodName = null;
        ValueNode                       value = null;
        ResultSetNode           resultSetNode = null;
    switch (jj_nt.kind) {
    case CALL:
      jj_consume_token(CALL);
      value = primaryExpression(true);
                if (! (value instanceof JavaToSQLValueNode) ||
                        ! (((JavaToSQLValueNode) value).getJavaValueNode() instanceof MethodCallNode))
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);}
                }

                QueryTreeNode callStatement =
                                                                        (QueryTreeNode) nodeFactory.getNode(
                                                                                                C_NodeTypes.CALL_STATEMENT_NODE,
                                                                                                methodName,
                                                                                                value,
                                                                                                getContextManager());

                setUpAndLinkParameters();

                {if (true) return callStatement;}
      break;
    case QUESTION_MARK:
      returnParam = dynamicParameterSpecification();
                getCompilerContext().setReturnParameterFlag(); //bug4450

      jj_consume_token(EQUALS_OPERATOR);
      jj_consume_token(CALL);
      resultSetNode = rowValueConstructor(null);
                // validate that we have something that is an appropriate call statement
                ResultColumnList rcl = resultSetNode.getResultColumns();

                // we can have only 1 return value/column
                if (rcl == null || rcl.size() > 1)
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);}
                }

                // we must have a method call node
                value = ((ResultColumn) rcl.elementAt(0)).getExpression();
                if (! (value instanceof JavaToSQLValueNode) ||
                        ! (((JavaToSQLValueNode) value).getJavaValueNode() instanceof MethodCallNode))
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);}
                }

                // wrap the row result set in a cursor node
                QueryTreeNode cursorNode =
                                        (QueryTreeNode) nodeFactory.getNode(
                                                C_NodeTypes.CURSOR_NODE,
                                                "SELECT",
                                                resultSetNode,
                                                null,
                                                null,
                                                ReuseFactory.getInteger(CursorNode.READ_ONLY),
                                                null,
                                                getContextManager());

                // set the 0th param to be a RETURN param
                returnParam.setReturnOutputParam(value);

                setUpAndLinkParameters();

                {if (true) return cursorNode;}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="primaryExpression">primaryExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode primaryExpression(boolean inSelectClause) throws ParseException, StandardException {
        ValueNode                       value = null;
    if (getToken(2).kind == PERIOD &&
                    getToken(4).kind == LEFT_PAREN) {
      value = routineInvocation();
                {if (true) return value;}
    } else if (jj_2_9(1)) {
      value = primaryExpressionXX(inSelectClause);
                {if (true) return value;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* 
 * <A NAME="savepointStatement">savepointStatement</A>

	savepointStatementClauses contains the UNIQUE, ON ROLLBACK RETAIN LOCKS, ON ROLLBACK RETAIN CURSORS clauses.

	0 - Boolean - UNIQUE clause
	1 - Boolean - ON ROLLBACK RETAIN LOCKS clause
	2 - Boolean - ON ROLLBACK RETAIN CURSORS clause
 */
  final public QueryTreeNode savepointStatement() throws ParseException, StandardException {
        String                  savepointName = null;
        int                     savepointStatementType;
        Object[] savepointStatementClauses = new Object[3];
    switch (jj_nt.kind) {
    case SAVEPOINT:
      jj_consume_token(SAVEPOINT);
      savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
      label_1:
      while (true) {
        savepointStatementClause(savepointStatementClauses);
        switch (jj_nt.kind) {
        case ON:
        case UNIQUE:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_1;
        }
      }
                //ON ROLLBACK RETAIN CURSORS is mandatory
                if (savepointStatementClauses[2] == null)
                                {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MISSING ON ROLLBACK RETAIN CURSORS");}
                savepointStatementType = 1;
      break;
    case ROLLBACK:
      jj_consume_token(ROLLBACK);
      switch (jj_nt.kind) {
      case WORK:
        jj_consume_token(WORK);
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      jj_consume_token(TO);
      jj_consume_token(SAVEPOINT);
      switch (jj_nt.kind) {
      case BINARY:
      case COALESCE:
      case D:
      case MODULE:
      case T:
      case TS:
      case VALUE:
      case VARBINARY:
      case ABS:
      case ABSVAL:
      case ACTION:
      case ALWAYS:
      case BLOB:
      case C:
      case CALLED:
      case CLOB:
      case COBOL:
      case COMMITTED:
      case CONCAT:
      case CONTAINS:
      case DATA:
      case DATE:
      case DAY:
      case DYNAMIC:
      case FORTRAN:
      case GENERATED:
      case IDENTITY_VAL_LOCAL:
      case INCREMENT:
      case INITIAL:
      case INTERVAL:
      case LANGUAGE:
      case LARGE:
      case LENGTH:
      case LEVEL:
      case LOCKS:
      case LOCKSIZE:
      case LOGGED:
      case MOD:
      case MODIFIES:
      case MODIFY:
      case MONTH:
      case _MORE:
      case MUMPS:
      case NAME:
      case NCLOB:
      case NULLABLE:
      case NUMBER:
      case OBJECT:
      case PASCAL:
      case PLI:
      case PRECISION:
      case RELEASE:
      case REPEATABLE:
      case RETURNS:
      case ROW:
      case SAVEPOINT:
      case SCALE:
      case SERIALIZABLE:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_HOUR:
      case SQL_TSI_DAY:
      case SQL_TSI_WEEK:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case START:
      case STATEMENT:
      case SYNONYM:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TRUNCATE:
      case TYPE:
      case UNCOMMITTED:
      case USAGE:
      case WHEN:
      case CURDATE:
      case CURTIME:
      case DATABASE:
      case LONG:
      case AFTER:
      case BEFORE:
      case CLASS:
      case COMPRESS:
      case CONTENT:
      case CS:
      case DB2SQL:
      case DIRTY:
      case DOCUMENT:
      case EACH:
      case EXCLUSIVE:
      case FN:
      case INDEX:
      case JAVA:
      case LCASE:
      case LOCATE:
      case LOCK:
      case MESSAGE_LOCALE:
      case METHOD:
      case MODE:
      case NEW:
      case NEW_TABLE:
      case OJ:
      case OFF:
      case OLD:
      case OLD_TABLE:
      case PARAMETER:
      case PASSING:
      case PROPERTIES:
      case READS:
      case REF:
      case REFERENCING:
      case RENAME:
      case RESET:
      case RESULT:
      case RETAIN:
      case RR:
      case RS:
      case SEQUENTIAL:
      case SETS:
      case SHARE:
      case SQLID:
      case SPECIFIC:
      case SQRT:
      case STABILITY:
      case STRIP:
      case STYLE:
      case TRIGGER:
      case UCASE:
      case UR:
      case WHITESPACE:
      case IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
                savepointStatementType = 2;
      break;
    case RELEASE:
      jj_consume_token(RELEASE);
      switch (jj_nt.kind) {
      case TO:
        jj_consume_token(TO);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      jj_consume_token(SAVEPOINT);
      savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                savepointStatementType = 3;
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.SAVEPOINT_NODE,
                                                                savepointName,
                                                                ReuseFactory.getInteger(savepointStatementType),
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public void savepointStatementClause(Object[] savepointStatementClauses) throws ParseException, StandardException {
        int clausePosition = -1;
    switch (jj_nt.kind) {
    case UNIQUE:
      jj_consume_token(UNIQUE);
                          clausePosition = 0;
      break;
    case ON:
      jj_consume_token(ON);
      jj_consume_token(ROLLBACK);
      jj_consume_token(RETAIN);
      clausePosition = LocksOrCursors();
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (clausePosition != -1) {
                        // check for repeated clause
                        if (savepointStatementClauses[clausePosition] != null) {

                                String which = SAVEPOINT_CLAUSE_NAMES[clausePosition];
                                {if (true) throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);}
                        }

                        savepointStatementClauses[clausePosition] = Boolean.TRUE;
                }
  }

/*
 * <A NAME="LocksOrCursors">LocksOrCursors</A>
 */
  final public int LocksOrCursors() throws ParseException {
    switch (jj_nt.kind) {
    case LOCKS:
      jj_consume_token(LOCKS);
                {if (true) return (1);}
      break;
    case CURSORS:
      jj_consume_token(CURSORS);
                {if (true) return (2);}
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* 
 * <A NAME="globalTemporaryTableDeclaration">globalTemporaryTableDeclaration</A>

	declareTableClauses contains the NOT LOGGED, on commit and on rollback clauses.

	0 - Boolean - NOT LOGGED clause
	1 - Boolean - on commit behavior
	2 - Boolean - on rollback behavior
 */
  final public QueryTreeNode globalTemporaryTableDeclaration() throws ParseException, StandardException {
        TableName                       tableName;
        TableElementList tableElementList;
        Object[] declareTableClauses = new Object[3];
    jj_consume_token(DECLARE);
    jj_consume_token(GLOBAL);
    jj_consume_token(TEMPORARY);
    jj_consume_token(TABLE);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    tableElementList = tableElementList();
    label_2:
    while (true) {
      declareTableClause(declareTableClauses);
      if (jj_2_10(1)) {
        ;
      } else {
        break label_2;
      }
    }
                // NOT LOGGED is mandatory
                if (declareTableClauses[0] == null)
                                {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MISSING NOT LOGGED");}
                // if ON COMMIT behavior not explicitly specified in DECLARE command, resort to default ON COMMIT DELETE ROWS
                if (declareTableClauses[1] == null)
                                declareTableClauses[1] = Boolean.TRUE;
                // if ON ROLLBACK behavior not explicitly specified in DECLARE command, resort to default ON ROLLBACK DELETE ROWS
                if (declareTableClauses[2] == null)
                                declareTableClauses[2] = Boolean.TRUE;
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.CREATE_TABLE_NODE,
                                                                tableName,
                                                                tableElementList,
                                                                (Properties)null,
                                                                (Boolean) declareTableClauses[1],
                                                                (Boolean) declareTableClauses[2],
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public void declareTableClause(Object[] declareTableClauses) throws ParseException, StandardException {
        int clausePosition = -1;
        Object clauseValue = null;
    switch (jj_nt.kind) {
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(LOGGED);
                                clauseValue = Boolean.TRUE; clausePosition = 0;
      break;
    default:
      jj_la1[33] = jj_gen;
      if (getToken(1).kind == ON && getToken(2).kind == COMMIT) {
        jj_consume_token(ON);
        jj_consume_token(COMMIT);
        clauseValue = onCommit();
        jj_consume_token(ROWS);
                                                                    clausePosition = 1;
      } else if (getToken(1).kind == ON && getToken(2).kind == ROLLBACK) {
        jj_consume_token(ON);
        jj_consume_token(ROLLBACK);
        jj_consume_token(DELETE);
        jj_consume_token(ROWS);
                                                  clauseValue = Boolean.TRUE; clausePosition = 2;
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                if (clausePosition != -1) {
                        // check for repeated clause
                        if (declareTableClauses[clausePosition] != null) {

                                String which = TEMPORARY_TABLE_CLAUSE_NAMES[clausePosition];
                                {if (true) throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);}
                        }

                        declareTableClauses[clausePosition] = clauseValue;
                }
  }

/*
 * <A NAME="onCommit">onCommit</A>
 */
  final public Boolean onCommit() throws ParseException {
    switch (jj_nt.kind) {
    case PRESERVE:
      jj_consume_token(PRESERVE);
                {if (true) return (Boolean.FALSE);}
      break;
    case DELETE:
      jj_consume_token(DELETE);
                {if (true) return (Boolean.TRUE);}
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="tableElementList">tableElementList</A>
 */
  final public TableElementList tableElementList() throws ParseException, StandardException {
        TableElementList        tableElementList =
                                        (TableElementList) nodeFactory.getNode(
                                                                        C_NodeTypes.TABLE_ELEMENT_LIST,
                                                                        getContextManager());
    jj_consume_token(LEFT_PAREN);
    tableElement(tableElementList);
    label_3:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      tableElement(tableElementList);
    }
    jj_consume_token(RIGHT_PAREN);
                {if (true) return tableElementList;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="tableElement">tableElement</A>
 */
  final public void tableElement(TableElementList tableElementList) throws ParseException, StandardException {
        TableElementNode        tableElement;
        //initialize following two booleans for every new table element so that the
        //values from previous tableElement doesn't impact the next tableElement
        explicitNotNull = false;
        explicitNull = false;
    switch (jj_nt.kind) {
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      tableElement = columnDefinition(tableElementList);
                tableElementList.addTableElement(tableElement);
      break;
    case CHECK:
    case CONSTRAINT:
    case FOREIGN:
    case PRIMARY:
    case UNIQUE:
      tableElement = tableConstraintDefinition();
                tableElementList.addTableElement(tableElement);
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * <A NAME="columnDefinition">columnDefinition</A>
 */
  final public TableElementNode columnDefinition(TableElementList tableElementList) throws ParseException, StandardException {
        DataTypeDescriptor      typeDescriptor = null;
        ValueNode                       defaultNode = null;
        String                          columnName;
        long[]                          autoIncrementInfo = new long[3];
    /*
    	** RESOLVE: We are ignoring domains and collation.
    	*/
    
            /* identifier() used to be columnName() */
            columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
    typeDescriptor = dataTypeDDL();
    switch (jj_nt.kind) {
    case CHECK:
    case CONSTRAINT:
    case _DEFAULT:
    case NOT:
    case PRIMARY:
    case REFERENCES:
    case UNIQUE:
    case WITH:
    case GENERATED:
      defaultNode = defaultAndConstraints(typeDescriptor, tableElementList, columnName, autoIncrementInfo);
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
                // Only pass autoincrement info for autoincrement columns
                if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] == 0)
                {
                        autoIncrementInfo = null;
                }

                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                                C_NodeTypes.COLUMN_DEFINITION_NODE,
                                                                columnName,
                                                                defaultNode,
                                                                typeDescriptor,
                                                                autoIncrementInfo,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="defaultAndConstraints">defaultAndConstraints</A>
 */
  final public ValueNode defaultAndConstraints(DataTypeDescriptor typeDescriptor,
                                          TableElementList tableElementList,
                                          String columnName,
                                          long[] autoIncrementInfo) throws ParseException, StandardException {
        ValueNode               defaultNode = null;
    switch (jj_nt.kind) {
    case CHECK:
    case CONSTRAINT:
    case NOT:
    case PRIMARY:
    case REFERENCES:
    case UNIQUE:
      columnConstraintDefinition(typeDescriptor, tableElementList, columnName);
      label_4:
      while (true) {
        switch (jj_nt.kind) {
        case CHECK:
        case CONSTRAINT:
        case NOT:
        case PRIMARY:
        case REFERENCES:
        case UNIQUE:
          ;
          break;
        default:
          jj_la1[38] = jj_gen;
          break label_4;
        }
        columnConstraintDefinition(typeDescriptor, tableElementList, columnName);
      }
      switch (jj_nt.kind) {
      case _DEFAULT:
      case WITH:
      case GENERATED:
        defaultNode = defaultClause(autoIncrementInfo, columnName);
        label_5:
        while (true) {
          switch (jj_nt.kind) {
          case CHECK:
          case CONSTRAINT:
          case NOT:
          case PRIMARY:
          case REFERENCES:
          case UNIQUE:
            ;
            break;
          default:
            jj_la1[39] = jj_gen;
            break label_5;
          }
          columnConstraintDefinition(typeDescriptor, tableElementList, columnName);
        }
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
                {if (true) return defaultNode;}
      break;
    case _DEFAULT:
    case WITH:
    case GENERATED:
      defaultNode = defaultClause(autoIncrementInfo, columnName);
      label_6:
      while (true) {
        switch (jj_nt.kind) {
        case CHECK:
        case CONSTRAINT:
        case NOT:
        case PRIMARY:
        case REFERENCES:
        case UNIQUE:
          ;
          break;
        default:
          jj_la1[41] = jj_gen;
          break label_6;
        }
        columnConstraintDefinition(typeDescriptor, tableElementList, columnName);
      }
                {if (true) return defaultNode;}
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dataTypeDDL">dataTypeDDL</A>
 */
  final public DataTypeDescriptor dataTypeDDL() throws ParseException, StandardException {
        DataTypeDescriptor      typeDescriptor;
    if (commonDatatypeName(false)) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    typeDescriptor = dataTypeCommon();
                {if (true) return typeDescriptor;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dataTypeCast">dataTypeCast</A>
 */
  final public DataTypeDescriptor dataTypeCast() throws ParseException, StandardException {
        DataTypeDescriptor      typeDescriptor;
    if (commonDatatypeName(true)) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    typeDescriptor = dataTypeCommon();
                {if (true) return typeDescriptor;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dataTypeCommon">dataTypeCommon</A>
 */
  final public DataTypeDescriptor dataTypeCommon() throws ParseException, StandardException {
        DataTypeDescriptor      typeDescriptor;
        boolean checkCS = false;
    if (jj_2_11(1)) {
      if (getToken(2).kind != LARGE) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      typeDescriptor = characterStringType();
    } else if (jj_2_12(1)) {
      if (getToken(3).kind != LARGE) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      typeDescriptor = nationalCharacterStringType();
    } else if (jj_2_13(1)) {
      typeDescriptor = numericType();
    } else {
      switch (jj_nt.kind) {
      case DATE:
      case TIME:
      case TIMESTAMP:
        typeDescriptor = datetimeType();
        break;
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
        checkInternalFeature(TypeId.BOOLEAN_NAME);
        typeDescriptor = new DataTypeDescriptor(TypeId.BOOLEAN_ID, true);
        break;
      case LONG:
        typeDescriptor = longType();
        break;
      case BINARY:
      case CHAR:
      case CHARACTER:
      case NATIONAL:
      case BLOB:
      case CLOB:
      case NCLOB:
        typeDescriptor = LOBType();
        break;
      case XML:
        typeDescriptor = XMLType();
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                {if (true) return typeDescriptor;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="characterStringType">characterStringType</A>
 */
  final public DataTypeDescriptor characterStringType() throws ParseException, StandardException {
        int                                     length = DEFAULT_STRING_COLUMN_LENGTH;
        Token                           varyingToken = null;
        int type;
    switch (jj_nt.kind) {
    case VARCHAR:
      jj_consume_token(VARCHAR);
      length = charLength();
                type = Types.VARCHAR;
      break;
    case CHAR:
    case CHARACTER:
      charOrCharacter();
      switch (jj_nt.kind) {
      case VARYING:
        // Length is optional for CHARACTER, not for plain CHARACTER VARYING
                        varyingToken = jj_consume_token(VARYING);
        length = charLength();
        break;
      default:
        jj_la1[45] = jj_gen;
        switch (jj_nt.kind) {
        case LEFT_PAREN:
          length = charLength();
          break;
        default:
          jj_la1[44] = jj_gen;
          ;
        }
      }
                // If the user says CHARACTER VARYING, it's really VARCHAR
                type = (varyingToken == null ? Types.CHAR : Types.VARCHAR);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case FOR:
      type = forBitData(type);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
                checkTypeLimits(type,length);
                DataTypeDescriptor charDTD = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);
                {if (true) return charDTD;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="charOrCharacter">charOrCharacter</A>
 */
  final public void charOrCharacter() throws ParseException {
    switch (jj_nt.kind) {
    case CHAR:
      jj_consume_token(CHAR);
      break;
    case CHARACTER:
      jj_consume_token(CHARACTER);
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * <A NAME="charType">charType</A>
 */
  final public int charLength() throws ParseException, StandardException {
        int length;
    jj_consume_token(LEFT_PAREN);
    length = length();
    jj_consume_token(RIGHT_PAREN);
                {if (true) return length;}
    throw new Error("Missing return statement in function");
  }

/*
** <A NAME="forBitData">forBitData</A>
*/
  final public int forBitData(int charType) throws ParseException {
    jj_consume_token(FOR);
    jj_consume_token(BIT);
    jj_consume_token(DATA);
                if (charType == Types.CHAR)
                        charType = Types.BINARY;
                else if (charType == Types.VARCHAR)
                        charType = Types.VARBINARY;
                else if (charType == Types.LONGVARCHAR)
                        charType = Types.LONGVARBINARY;

                {if (true) return charType;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="nationalCharacterStringType">nationalCharacterStringType</A>
 */
  final public DataTypeDescriptor nationalCharacterStringType() throws ParseException, StandardException {
        DataTypeDescriptor      dataTypeDescriptor;
        int                                     length = DEFAULT_STRING_COLUMN_LENGTH;
        String                          type = null;
        Token                           varyingToken = null;
    switch (jj_nt.kind) {
    case NATIONAL:
      jj_consume_token(NATIONAL);
      charOrCharacter();
      switch (jj_nt.kind) {
      case VARYING:
        // Length is optional for NATIONAL CHARACTER , not for NATIONAL CHARACTER VARYING
                        varyingToken = jj_consume_token(VARYING);
        length = charLength();
        break;
      default:
        jj_la1[50] = jj_gen;
        switch (jj_nt.kind) {
        case LEFT_PAREN:
          length = charLength();
          break;
        default:
          jj_la1[49] = jj_gen;
          ;
        }
      }
                // If the user says NATIONAL CHARACTER VARYING, it's really NATIONALVARCHAR
                type = (varyingToken == null ? TypeId.NATIONAL_CHAR_NAME :
                                TypeId.NATIONAL_VARCHAR_NAME);
      break;
    case NCHAR:
      jj_consume_token(NCHAR);
      switch (jj_nt.kind) {
      case VARYING:
        // Length is optional for NCHAR, not for NCHAR VARYING
                        varyingToken = jj_consume_token(VARYING);
        length = charLength();
        break;
      default:
        jj_la1[52] = jj_gen;
        switch (jj_nt.kind) {
        case LEFT_PAREN:
          length = charLength();
          break;
        default:
          jj_la1[51] = jj_gen;
          ;
        }
      }
                // If the user says NCHAR VARYING, it's really NATIONALVARCHAR
                type = (varyingToken == null ? TypeId.NATIONAL_CHAR_NAME :
                                TypeId.NATIONAL_VARCHAR_NAME);
      break;
    case NVARCHAR:
      jj_consume_token(NVARCHAR);
      length = charLength();
                type = TypeId.NATIONAL_VARCHAR_NAME;
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                // need to re-enable according to SQL standard
                {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);}
                // return DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);

    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="LOBType">lobType</A>
 */
  final public DataTypeDescriptor LOBType() throws ParseException, StandardException {
        int     length = 1048576; // default to 1Mb if no length specified
        String  type;
    switch (jj_nt.kind) {
    case BLOB:
      jj_consume_token(BLOB);
      switch (jj_nt.kind) {
      case LEFT_PAREN:
        length = lengthAndModifier();
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
                        type = TypeId.BLOB_NAME;
      break;
    case CLOB:
      jj_consume_token(CLOB);
      switch (jj_nt.kind) {
      case LEFT_PAREN:
        length = lengthAndModifier();
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
                        type = TypeId.CLOB_NAME;
      break;
    case NCLOB:
      jj_consume_token(NCLOB);
      length = lengthAndModifier();
                        type = TypeId.NCLOB_NAME;
                        // need to re-enable according to SQL standard
                        {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);}
      break;
    case BINARY:
      jj_consume_token(BINARY);
      jj_consume_token(LARGE);
      jj_consume_token(OBJECT);
      switch (jj_nt.kind) {
      case LEFT_PAREN:
        length = lengthAndModifier();
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
                        type = TypeId.BLOB_NAME;
      break;
    case CHAR:
    case CHARACTER:
      charOrCharacter();
      jj_consume_token(LARGE);
      jj_consume_token(OBJECT);
      switch (jj_nt.kind) {
      case LEFT_PAREN:
        length = lengthAndModifier();
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
                        type = TypeId.CLOB_NAME;
      break;
    case NATIONAL:
      jj_consume_token(NATIONAL);
      jj_consume_token(CHARACTER);
      jj_consume_token(LARGE);
      jj_consume_token(OBJECT);
      length = lengthAndModifier();
                        type = TypeId.NCLOB_NAME;
                        // need to re-enable according to SQL standard
                        {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);}
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);

                {if (true) return dtd;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="numericType">numericType</A>
 */
  final public DataTypeDescriptor numericType() throws ParseException, StandardException {
        DataTypeDescriptor      typeDescriptor;
    switch (jj_nt.kind) {
    case DEC:
    case DECIMAL:
    case INT:
    case INTEGER:
    case NUMERIC:
    case SMALLINT:
    case LONGINT:
      typeDescriptor = exactNumericType();
                {if (true) return typeDescriptor;}
      break;
    default:
      jj_la1[59] = jj_gen;
      if (jj_2_14(1)) {
        typeDescriptor = approximateNumericType();
                {if (true) return typeDescriptor;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="exactNumericType">exactNumericType</A>
 */
  final public DataTypeDescriptor exactNumericType() throws ParseException, StandardException {
        int precision = TypeCompiler.DEFAULT_DECIMAL_PRECISION;
        int scale = TypeCompiler.DEFAULT_DECIMAL_SCALE;
        int type = Types.DECIMAL;
        String typeStr = "DECIMAL";
        int maxWidth;
        DataTypeDescriptor dtd =  null;
    switch (jj_nt.kind) {
    case DEC:
    case DECIMAL:
    case NUMERIC:
      switch (jj_nt.kind) {
      case NUMERIC:
        jj_consume_token(NUMERIC);
                type = Types.NUMERIC;
                typeStr = "NUMERIC";
        break;
      case DECIMAL:
        jj_consume_token(DECIMAL);
        break;
      case DEC:
        jj_consume_token(DEC);
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        precision = precision();
        switch (jj_nt.kind) {
        case COMMA:
          jj_consume_token(COMMA);
          scale = scale();
          break;
        default:
          jj_la1[61] = jj_gen;
          ;
        }
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
                if ((precision <= 0) ||
                        (precision > TypeCompiler.MAX_DECIMAL_PRECISION_SCALE))
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_INVALID_PRECISION,
                                typeStr, String.valueOf(precision));}
                }
                else if ((scale < 0) ||
                                 (scale > TypeCompiler.MAX_DECIMAL_PRECISION_SCALE))
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_INVALID_DECIMAL_SCALE,
                                typeStr, String.valueOf(scale));}
                }
                else if (scale > precision)
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_INVALID_DECIMAL_PRECISION_SCALE,
                                String.valueOf(scale),
                                String.valueOf(precision));}
                }
                /*
		** If we have a decimal point, need to count it
		** towards maxwidth.  Max width needs to account
		** for the possible leading '0' and '-' and the
		** decimal point.  e.g., DEC(1,1) has a maxwidth
		** of 4 (to handle "-0.1").
		*/
                maxWidth = DataTypeUtilities.computeMaxWidth( precision, scale);
                {if (true) return getDataTypeServices(type, precision, scale, maxWidth);}
      break;
    case INT:
    case INTEGER:
    case SMALLINT:
    case LONGINT:
      dtd = exactIntegerType();
                        {if (true) return dtd;}
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="exactNumericType">exactNumericType</A>
 */
  final public DataTypeDescriptor exactIntegerType() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case INT:
    case INTEGER:
      switch (jj_nt.kind) {
      case INTEGER:
        jj_consume_token(INTEGER);
        break;
      case INT:
        jj_consume_token(INT);
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER);}
      break;
    case SMALLINT:
      jj_consume_token(SMALLINT);
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.SMALLINT);}
      break;
    case LONGINT:
      jj_consume_token(LONGINT);
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT);}
      break;
    default:
      jj_la1[65] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="approximateNumericType">approximateNumericType</A>
 */
  final public DataTypeDescriptor approximateNumericType() throws ParseException, StandardException {
        int type = 0, scale = 0, width = 0;
        int prec = -1;
        DataTypeDescriptor dts = null;
    switch (jj_nt.kind) {
    case FLOAT:
      jj_consume_token(FLOAT);
      switch (jj_nt.kind) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        prec = precision();
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
                /*
			When not specified, default is DOUBLE_PRECISION
		 */
                if (prec == -1)
                        prec = TypeId.DOUBLE_PRECISION;

                if (prec > 0 && prec <= TypeId.REAL_PRECISION)
                {
                        type = Types.REAL;
                        prec = TypeId.REAL_PRECISION;
                        scale = TypeId.REAL_SCALE;
                        width = TypeId.REAL_MAXWIDTH;
                }
                else if (prec > TypeId.REAL_PRECISION &&
                                 prec <= TypeId.DOUBLE_PRECISION)
                {
                        type = Types.DOUBLE;
                        prec = TypeId.DOUBLE_PRECISION;
                        scale = TypeId.DOUBLE_SCALE;
                        width = TypeId.DOUBLE_MAXWIDTH;
                }
                else
                        {if (true) throw StandardException.newException(SQLState.LANG_INVALID_PRECISION, "FLOAT", String.valueOf(prec));}

                /*
			REMIND: this is a slight hack, in that exacting reading of
			the InformationSchema requires that the type the user typed
			in be visible to them in the InformationSchema views. But
			most implementations use synonyms or mappings at some point,
			and this is one of those places, for us.
		 */
                {if (true) return getDataTypeServices(type, prec, scale, width);}
      break;
    case REAL:
      jj_consume_token(REAL);
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.REAL);}
      break;
    default:
      jj_la1[67] = jj_gen;
      if (jj_2_15(1)) {
        dts = doubleType();
                {if (true) return dts;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="doubleType">doubleType</A>
 */
  final public DataTypeDescriptor doubleType() throws ParseException, StandardException {
    if (getToken(2).kind == PRECISION) {
      jj_consume_token(DOUBLE);
      jj_consume_token(PRECISION);
    } else {
      switch (jj_nt.kind) {
      case DOUBLE:
        jj_consume_token(DOUBLE);
        break;
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE);}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="longType">longType</A>
 */
  final public DataTypeDescriptor longType() throws ParseException, StandardException {
        DataTypeDescriptor      dataTypeDescriptor;
    jj_consume_token(LONG);
    dataTypeDescriptor = longSubType();
                {if (true) return dataTypeDescriptor;}
    throw new Error("Missing return statement in function");
  }

  final public DataTypeDescriptor longSubType() throws ParseException, StandardException {
        int lvcType = Types.LONGVARCHAR;
    switch (jj_nt.kind) {
    case VARCHAR:
      jj_consume_token(VARCHAR);
      switch (jj_nt.kind) {
      case FOR:
        lvcType = forBitData(lvcType);
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(lvcType);}
      break;
    case NVARCHAR:
      jj_consume_token(NVARCHAR);
                // need to re-enable according to SQL standard
                {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, TypeId.NATIONAL_LONGVARCHAR_NAME);}
                // return DataTypeDescriptor.getBuiltInDataTypeDescriptor(TypeId.NATIONAL_LONGVARCHAR_NAME);

      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="XMLType">XMLType</A>
 */
  final public DataTypeDescriptor XMLType() throws ParseException, StandardException {
        DataTypeDescriptor value;
    jj_consume_token(XML);
                checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "XML");
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(
                        StoredFormatIds.XML_TYPE_ID);}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="xmlDocOrContent">xmlDocOrContent</A>
 *
 * Parse the XML keywords DOCUMENT and CONTENT.  We don't
 * support CONTENT yet, so we throw an appropriate error
 * if we see it.
 *
 */
  final public void xmlDocOrContent() throws ParseException, StandardException {
    if ((getToken(1).kind != DOCUMENT) &&
                    (getToken(1).kind != CONTENT)) {
                {if (true) throw StandardException.newException(
                        SQLState.LANG_XML_KEYWORD_MISSING, "DOCUMENT");}
    } else if (getToken(1).kind == CONTENT) {
      jj_consume_token(CONTENT);
                {if (true) throw StandardException.newException(
                        SQLState.LANG_UNSUPPORTED_XML_FEATURE, "CONTENT");}
    } else if (getToken(1).kind == DOCUMENT) {
      jj_consume_token(DOCUMENT);
                {if (true) return;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * <A NAME="javaType">javaType</A>
 */
  final public DataTypeDescriptor javaType() throws ParseException, StandardException {
        String  javaClassName;
    javaClassName = javaClassName();
                {if (true) return getJavaClassDataTypeDescriptor(javaClassName);}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME = "javaDSL">javaDSL</A>
 *
 * A Java dot-separated list.
 */
  final public String javaDSL() throws ParseException {
        String dotSeparatedList;
    dotSeparatedList = caseSensitiveIdentifierPlusReservedWords();
    label_7:
    while (true) {
      switch (jj_nt.kind) {
      case PERIOD:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_7;
      }
      dotSeparatedList = javaDSLNameExtender(dotSeparatedList);
    }
                {if (true) return dotSeparatedList;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="javaClassName">javaClassName</A>
 */
  final public String javaClassName() throws ParseException {
        String javaClassName;
    javaClassName = javaDSL();
                {if (true) return javaClassName;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="javaDSLNameExtender">javaDSLNameExtender</A>
 */
  final public String javaDSLNameExtender(String dotSeparatedList) throws ParseException {
        String  extender;
    jj_consume_token(PERIOD);
    extender = caseSensitiveIdentifierPlusReservedWords();
                {if (true) return dotSeparatedList + "." + extender;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="length">lengthAndModifier</A>
 */
  final public int lengthAndModifier() throws ParseException, StandardException {
        Token   tok;
        Token   tokmod = null;
    jj_consume_token(LEFT_PAREN);
    switch (jj_nt.kind) {
    case LENGTH_MODIFIER:
      tok = jj_consume_token(LENGTH_MODIFIER);
      break;
    case EXACT_NUMERIC:
      tok = jj_consume_token(EXACT_NUMERIC);
      switch (jj_nt.kind) {
      case IDENTIFIER:
        tokmod = jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[72] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[73] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RIGHT_PAREN);
                String s = tok.image + (tokmod==null ? "" : tokmod.image); // colapse cases;
                try
                {
                        char modifier = s.charAt(s.length()-1);
                        String number = s.substring(0, s.length()-1); // in case of ending w. letter
                        long mul;
                        switch (modifier) {
                        case 'G':
                        case 'g':
                                mul =1073741824L;       //1 Giga
                                break;
                        case 'M':
                        case 'm':
                                mul=1048576L;           // 1 Mega
                                break;
                        case 'K':
                        case 'k':
                                mul=1024L;              // 1 Kilo
                                break;
                        default:
                                mul=1;
                                number = s; // no letter in end, need whole string
                                break;
                        }
                        long    specifiedLength = Long.parseLong(number) * mul;

                        // match DB2 limits of 1 to 2147483647
                        if ((specifiedLength > 0L) &&
                (specifiedLength <= Limits.DB2_LOB_MAXWIDTH))
            {
                                {if (true) return (int)specifiedLength;}
            }

                        // DB2 allows 2G or 2048M or 2097152k that calculate out to 
            // 2147483648, but sets the length to be one less.
                        if (mul != 1 && specifiedLength == 2147483648L)
                                {if (true) return Limits.DB2_LOB_MAXWIDTH;}

                }
                catch (NumberFormatException nfe)
                {
                }

                {if (true) throw StandardException.newException(
            SQLState.LANG_INVALID_COLUMN_LENGTH, s);}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="length">length</A>
 */
  final public int length() throws ParseException, StandardException {
        Token   tok;
        int     retval;
    tok = jj_consume_token(EXACT_NUMERIC);
                try
                {
                        retval = Integer.parseInt(tok.image);

                        if (retval > 0)
                                {if (true) return retval;}
                }
                catch (NumberFormatException nfe)
                {
                }
                {if (true) throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH, tok.image);}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="exactNumber">exactNumber</A>
*/
  final public long exactNumber() throws ParseException, StandardException {
        Token longToken;
        String sign = "";
    switch (jj_nt.kind) {
    case PLUS_SIGN:
    case MINUS_SIGN:
      sign = sign();
      break;
    default:
      jj_la1[74] = jj_gen;
      ;
    }
    longToken = jj_consume_token(EXACT_NUMERIC);
                try
                {
                        long longvalue = Long.parseLong(longToken.image);
                        if (sign.equals("-"))
                        {
                                {if (true) return -longvalue;}
                        }
                        else
                        {
                                {if (true) return longvalue;}
                        }
                }
                catch (NumberFormatException nfe)
                {
                        {if (true) throw
                        StandardException.newException(
                                   SQLState.LANG_INVALID_INTEGER_LITERAL, longToken.image);}
                }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="precision">precision</A>
 */
  final public int precision() throws ParseException, StandardException {
        int uintValue;
    uintValue = uint_value();
                {if (true) return uintValue;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="uint_value">uint_value</A>
 */
  final public int uint_value() throws ParseException, StandardException {
        Token uintToken;
    /*
    		because the parser won't match to UINT, we use EXACT_NUMERIC.
    	 */
            uintToken = jj_consume_token(EXACT_NUMERIC);
                try {
                        {if (true) return Integer.parseInt(uintToken.image);}
                } catch (NumberFormatException nfe) {
                        {if (true) throw StandardException.newException(SQLState.LANG_INVALID_INTEGER_LITERAL, uintToken.image);}
                }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="scale">scale</A>
 */
  final public int scale() throws ParseException, StandardException {
        int uintValue;
    uintValue = uint_value();
                {if (true) return uintValue;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="datetimeType">datetimeType</A>
 */
  final public DataTypeDescriptor datetimeType() throws ParseException, StandardException {
        Token tzTok = null;
        int prec = -1;
    switch (jj_nt.kind) {
    case DATE:
      jj_consume_token(DATE);
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DATE);}
      break;
    case TIME:
      jj_consume_token(TIME);
                /*
			We do not try to set up a precision for time/timestamp
			values because this field gets mapped to the precision
			field in the JDBC driver that is for the number of
			decimal digits in the value.  Precision for time is
			actually the scale of the seconds value.

			If/when precision for times is supported, we may need
			to migrate the system catalog information to fill in
			the default values appropriately (the default for
			time is 0, fortunately; but for timestamp it is
			actually 9 due to java.sql.Timestamp's precision).
		 */
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIME);}
      break;
    case TIMESTAMP:
      jj_consume_token(TIMESTAMP);
                {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIMESTAMP);}
      break;
    default:
      jj_la1[75] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="timePrecision">timePrecision</A>
 */
  final public void qualifiedNameList(Vector list, int id_length_limit) throws ParseException, StandardException {
    qualifiedNameElement(list, id_length_limit);
    label_8:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[76] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      qualifiedNameElement(list, id_length_limit);
    }
  }

  final public void qualifiedNameElement(Vector list, int id_length_limit) throws ParseException, StandardException {
        TableName qualifiedName = null;
    qualifiedName = qualifiedName(id_length_limit);
                list.addElement(qualifiedName);
  }

/*
 * <A NAME="qualifiedName">qualifiedName</A>
 */
  final public TableName qualifiedName(int nodeType, int id_length_limit) throws ParseException, StandardException {
        //String	catalogName = null;
        String  schemaName = null;
        String  qualifiedId;
        String  firstName = null;
        String  secondName = null;
    firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
    if (getToken(1).kind == PERIOD &&
                                                                    getToken(2).kind != ASTERISK) {
      jj_consume_token(PERIOD);
      secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
    } else {
      ;
    }
                if (secondName == null)
                {
                        qualifiedId = firstName;
                }
                else
                {
                        schemaName = firstName;
                        qualifiedId = secondName;
                }

                //limit the qualifiedId to the id length limit passed to this method
                checkIdentifierLengthLimit(qualifiedId, id_length_limit);
                if (schemaName != null)
                        checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);

                {if (true) return (TableName) nodeFactory.getNode(
                                                                nodeType,
                                                                schemaName,
                                                                qualifiedId,
                                                                new Integer(lastIdentifierToken.beginOffset),
                                                                new Integer(lastIdentifierToken.endOffset),
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="queryExpression">queryExpression</A>
 *
 * We have to be carefull to get the associativity correct. According to the SQL spec
 *   <non-join query expression> ::=
 *     <non-join query term>
 *    | <query expression body> UNION [ ALL ] <query term>
 *    | <query expression body> EXCEPT [ ALL ] <query term>
 * Meaning that
 *   t1 UNION ALL t2 UNION t3
 * is equivalent to
 *   (t1 UNION ALL t2) UNION t3
 * However recursive descent parsers want recursion to be on the right, so this kind of associativity is unnatural
 * for our parser. The queryExpression method must know whether it is being called as the right hand side of a
 * set operator to produce a query tree with the correct associativity.
 */
  final public ResultSetNode queryExpression(ResultSetNode leftSide, int operatorType) throws ParseException, StandardException {
        ResultSetNode   term;
    term = nonJoinQueryTerm(leftSide, operatorType);
    switch (jj_nt.kind) {
    case EXCEPT:
    case UNION:
      term = unionOrExcept(term);
      break;
    default:
      jj_la1[77] = jj_gen;
      ;
    }
                {if (true) return term;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="unionOrExcept">unionOrExcept</A>
 */
  final public ResultSetNode unionOrExcept(ResultSetNode term) throws ParseException, StandardException {
        ResultSetNode   expression;
        Token                   tok = null;
    switch (jj_nt.kind) {
    case UNION:
      jj_consume_token(UNION);
      switch (jj_nt.kind) {
      case ALL:
      case DISTINCT:
        switch (jj_nt.kind) {
        case ALL:
          tok = jj_consume_token(ALL);
          break;
        case DISTINCT:
          jj_consume_token(DISTINCT);
          break;
        default:
          jj_la1[78] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      expression = queryExpression(term,
                                                                      (tok != null) ? UNION_ALL_OP : UNION_OP);
                {if (true) return expression;}
      break;
    case EXCEPT:
      jj_consume_token(EXCEPT);
      switch (jj_nt.kind) {
      case ALL:
      case DISTINCT:
        switch (jj_nt.kind) {
        case ALL:
          tok = jj_consume_token(ALL);
          break;
        case DISTINCT:
          jj_consume_token(DISTINCT);
          break;
        default:
          jj_la1[80] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      expression = queryExpression(term,
                                                                      (tok != null) ? EXCEPT_ALL_OP : EXCEPT_OP);
                {if (true) return expression;}
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="nonJoinQueryTerm">nonJoinQueryTerm</A>
 *
 * Be careful with the associativity of INTERSECT. According to the SQL spec
 *   t1 INTERSECT t2 INTERSECT ALL t3
 * is equivalent to
 *   (t1 INTERSECT t2) INTERSECT ALL t3
 * which is not the same as
 *   t1 INTERSECT (t2 INTERSECT ALL t3)
 * See the comment on queryExpression.
 */
  final public ResultSetNode nonJoinQueryTerm(ResultSetNode leftSide, int operatorType) throws ParseException, StandardException {
        ResultSetNode   term;
    term = nonJoinQueryPrimary();
    switch (jj_nt.kind) {
    case INTERSECT:
      term = intersect(term);
      break;
    default:
      jj_la1[83] = jj_gen;
      ;
    }
        switch( operatorType)
        {
        case NO_SET_OP:
            {if (true) return term;}

        case UNION_OP:
            {if (true) return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.UNION_NODE,
                leftSide,
                term,
                Boolean.FALSE,
                Boolean.FALSE,
                null,
                getContextManager());}

        case UNION_ALL_OP:
            {if (true) return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.UNION_NODE,
                leftSide,
                term,
                Boolean.TRUE,
                Boolean.FALSE,
                null,
                getContextManager());}

        case EXCEPT_OP:
            {if (true) return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                ReuseFactory.getInteger( IntersectOrExceptNode.EXCEPT_OP),
                leftSide,
                term,
                Boolean.FALSE,
                null,
                getContextManager());}

        case EXCEPT_ALL_OP:
            {if (true) return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                ReuseFactory.getInteger( IntersectOrExceptNode.EXCEPT_OP),
                leftSide,
                term,
                Boolean.TRUE,
                null,
                getContextManager());}

        case INTERSECT_OP:
            {if (true) return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                ReuseFactory.getInteger( IntersectOrExceptNode.INTERSECT_OP),
                leftSide,
                term,
                Boolean.FALSE,
                null,
                getContextManager());}

        case INTERSECT_ALL_OP:
            {if (true) return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                ReuseFactory.getInteger( IntersectOrExceptNode.INTERSECT_OP),
                leftSide,
                term,
                Boolean.TRUE,
                null,
                getContextManager());}


        default:
            if (SanityManager.DEBUG)
            {
                SanityManager.THROWASSERT( "Invalid set operator type: " + operatorType);
            }
            {if (true) return null;}
        }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="intersect">intersect</A>
 */
  final public ResultSetNode intersect(ResultSetNode term) throws ParseException, StandardException {
        ResultSetNode   expression;
        Token                   tok = null;
    jj_consume_token(INTERSECT);
    switch (jj_nt.kind) {
    case ALL:
    case DISTINCT:
      switch (jj_nt.kind) {
      case ALL:
        tok = jj_consume_token(ALL);
        break;
      case DISTINCT:
        jj_consume_token(DISTINCT);
        break;
      default:
        jj_la1[84] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[85] = jj_gen;
      ;
    }
    expression = nonJoinQueryTerm(term, (tok != null) ? INTERSECT_ALL_OP : INTERSECT_OP);
                {if (true) return expression;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="nonJoinQueryPrimary">nonJoinQueryPrimary</A>
 */
  final public ResultSetNode nonJoinQueryPrimary() throws ParseException, StandardException {
        ResultSetNode   primary;
    switch (jj_nt.kind) {
    case SELECT:
    case VALUES:
      primary = simpleTable();
                {if (true) return primary;}
      break;
    case LEFT_PAREN:
      jj_consume_token(LEFT_PAREN);
      primary = queryExpression(null, NO_SET_OP);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return primary;}
      break;
    default:
      jj_la1[86] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="simpleTable">simpleTable</A>
 */
  final public ResultSetNode simpleTable() throws ParseException, StandardException {
        ResultSetNode   resultSetNode;
    switch (jj_nt.kind) {
    case SELECT:
      resultSetNode = querySpecification();
                {if (true) return resultSetNode;}
      break;
    case VALUES:
      resultSetNode = tableValueConstructor();
                {if (true) return resultSetNode;}
      break;
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="querySpecification">querySpecification</A>
 */
  final public ResultSetNode querySpecification() throws ParseException, StandardException {
        ResultColumnList        selectList;
        SelectNode                      selectNode;
        boolean isDistinct = false;
    jj_consume_token(SELECT);
    if (jj_2_16(1)) {
      isDistinct = setQuantifier();
    } else {
      ;
    }
    selectList = selectList();
    selectNode = tableExpression(selectList);
                if (isDistinct) selectNode.makeDistinct();
                {if (true) return selectNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="setQuantifier">setQuantifier</A>
 */
  final public boolean setQuantifier() throws ParseException {
    if (getToken(1).kind == DISTINCT &&
                            !(
                                    getToken(2).kind == PERIOD ||
                                    getToken(2).kind == DOUBLE_COLON
                            )) {
      jj_consume_token(DISTINCT);
                {if (true) return true;}
    } else if (getToken(1).kind == ALL &&
                            !(
                                    getToken(2).kind == PERIOD ||
                                    getToken(2).kind == DOUBLE_COLON
                            )) {
      jj_consume_token(ALL);
                {if (true) return false;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="selectList">selectList</A>
 */
  final public ResultColumnList selectList() throws ParseException, StandardException {
        ResultColumn    allResultColumn;
        ResultColumnList        resultColumns = (ResultColumnList) nodeFactory.getNode(
                                                                        C_NodeTypes.RESULT_COLUMN_LIST,
                                                                        getContextManager());
    switch (jj_nt.kind) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
                allResultColumn = (ResultColumn) nodeFactory.getNode(
                                                                                C_NodeTypes.ALL_RESULT_COLUMN,
                                                                                null,
                                                                                getContextManager());
                /* Add the new AllResultColumn to the end of the list */
                resultColumns.addResultColumn(allResultColumn);
                {if (true) return resultColumns;}
      break;
    default:
      jj_la1[88] = jj_gen;
      if (jj_2_17(1)) {
        selectColumnList(resultColumns);
                {if (true) return resultColumns;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void selectColumnList(ResultColumnList resultColumns) throws ParseException, StandardException {
    selectSublist(resultColumns);
    label_9:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[89] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      selectSublist(resultColumns);
    }
  }

/*
 * <A NAME="selectSublist">selectSublist</A>
 */
  final public void selectSublist(ResultColumnList resultColumns) throws ParseException, StandardException {
        ResultColumn    resultColumn;
        ResultColumn    allResultColumn;
        TableName       tableName;
    if (getToken(2).kind == PERIOD &&
                            (
                                    getToken(3).kind == ASTERISK ||
                                    (getToken(4).kind == PERIOD && getToken(5).kind == ASTERISK)
                            )) {
      tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
      jj_consume_token(PERIOD);
      jj_consume_token(ASTERISK);
                allResultColumn = (ResultColumn) nodeFactory.getNode(
                                                                                C_NodeTypes.ALL_RESULT_COLUMN,
                                                                                tableName,
                                                                                getContextManager());
                /* Add the new AllResultColumn to the end of the list */
                resultColumns.addResultColumn(allResultColumn);
    } else if (jj_2_18(1)) {
      resultColumn = derivedColumn(resultColumns);
                /* Add the new ResultColumn to the end of the list */
                resultColumns.addResultColumn(resultColumn);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * <A NAME="derivedColumn">derivedColumn</A>
 */
  final public ResultColumn derivedColumn(ResultColumnList resultColumns) throws ParseException, StandardException {
        ValueNode       columnExpression;
        String          columnName = null;
    //true to additiveExpression ensures that for the derived columns, we will not allow boolean values inside (), 
            //eg (2 > 1) should be disallowed in the select clause
            columnExpression = additiveExpression(null, 0, true);
    switch (jj_nt.kind) {
    case AS:
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      columnName = asClause();
      break;
    default:
      jj_la1[90] = jj_gen;
      ;
    }
                /*
		** If there is no AS clause, and the expression is a simple
		** column, use the name of the column as the result column
		** name.
		*/
                if ((columnName == null) && (columnExpression instanceof ColumnReference))
                {
                        columnName = ((ColumnReference) columnExpression).columnName;
                }

                {if (true) return (ResultColumn) nodeFactory.getNode(
                                                C_NodeTypes.RESULT_COLUMN,
                                                columnName,
                                                columnExpression,
                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="asClause">asClause</A>
 */
  final public String asClause() throws ParseException, StandardException {
        String  columnName;
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      break;
    default:
      jj_la1[91] = jj_gen;
      ;
    }
    columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                {if (true) return columnName;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="valueExpression">valueExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode valueExpression(boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       leftOperand;
    leftOperand = orExpression(null, inSelectClause);
    label_10:
    while (true) {
      switch (jj_nt.kind) {
      case OR:
        ;
        break;
      default:
        jj_la1[92] = jj_gen;
        break label_10;
      }
      jj_consume_token(OR);
      leftOperand = orExpression(leftOperand, inSelectClause);
    }
                {if (true) return leftOperand;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="orExpression">orExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode orExpression(ValueNode farLeftOperand, boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       leftOperand;
    leftOperand = andExpression(null, inSelectClause);
    label_11:
    while (true) {
      switch (jj_nt.kind) {
      case AND:
        ;
        break;
      default:
        jj_la1[93] = jj_gen;
        break label_11;
      }
      jj_consume_token(AND);
      leftOperand = andExpression(leftOperand, inSelectClause);
    }
                if (farLeftOperand == null)
                {
                        {if (true) return leftOperand;}
                }
                else
                {
                        {if (true) return (ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.OR_NODE,
                                                                                farLeftOperand,
                                                                                leftOperand,
                                                                                getContextManager());}
                }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="andExpression">andExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode andExpression(ValueNode farLeftOperand, boolean inSelectClause) throws ParseException, StandardException {
        Token           tok = null;
        ValueNode       test;
    if (getToken(1).kind == NOT && !(getToken(2).kind == PERIOD ||
                            getToken(2).kind == DOUBLE_COLON)) {
      tok = jj_consume_token(NOT);
    } else {
      ;
    }
    test = isSearchCondition(inSelectClause);
                /* Put the NOT on top of test */
                if (tok != null)
                {
                        test = (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.NOT_NODE,
                                                                        test,
                                                                        getContextManager());
                }

                if (farLeftOperand != null)
                {
                        test = (ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.AND_NODE,
                                                                                farLeftOperand,
                                                                                test,
                                                                                getContextManager());
                }
                {if (true) return test;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="isSearchCondition">isSearchCondition</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode isSearchCondition(boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       result;
        ValueNode       booleanPrimary;
        Token           isToken = null;
        Token           notToken = null;
        Token           truthValue = null;
    booleanPrimary = booleanPrimary(inSelectClause);
    switch (jj_nt.kind) {
    case IS:
      isToken = jj_consume_token(IS);
      switch (jj_nt.kind) {
      case NOT:
        notToken = jj_consume_token(NOT);
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }
      jj_consume_token(NULL);
      break;
    default:
      jj_la1[95] = jj_gen;
      ;
    }
                if ( isToken != null )
                {
                                result = (ValueNode) nodeFactory.getNode(
                                                                                        C_NodeTypes.IS_NULL_NODE,
                                                                                        booleanPrimary,
                                                                                        getContextManager());

                                /* Put the NOT on top of the tree */
                                if (notToken != null)
                                {
                                        result = (ValueNode) nodeFactory.getNode(
                                                                                        C_NodeTypes.NOT_NODE,
                                                                                        result,
                                                                                        getContextManager());
                                }
                }
                else { result = booleanPrimary; }

                {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="booleanPrimary">booleanPrimary</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode booleanPrimary(boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       primary;
        ValueNode       searchCondition;
    primary = predicate(inSelectClause);
                {if (true) return  primary;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="predicate">predicate</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode predicate(boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       value;
    if (jj_2_19(1)) {
      value = additiveExpression(null, 0, inSelectClause);
    } else {
      switch (jj_nt.kind) {
      case EXISTS:
        value = existsExpression();
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_12:
    while (true) {
      if (remainingPredicateFollows()) {
        ;
      } else {
        break label_12;
      }
      value = remainingPredicate(value, inSelectClause);
    }
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="remainingPredicates">remainingPredicates</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode remainingPredicate(ValueNode value, boolean inSelectClause) throws ParseException, StandardException {
        Token tok = null;
    switch (jj_nt.kind) {
    case LESS_THAN_OPERATOR:
    case LESS_THAN_OR_EQUALS_OPERATOR:
    case EQUALS_OPERATOR:
    case NOT_EQUALS_OPERATOR:
    case NOT_EQUALS_OPERATOR2:
    case GREATER_THAN_OPERATOR:
    case GREATER_THAN_OR_EQUALS_OPERATOR:
      value = remainingNonNegatablePredicate(value, inSelectClause);
                {if (true) return value;}
      break;
    case BETWEEN:
    case IN:
    case LIKE:
    case NOT:
      switch (jj_nt.kind) {
      case NOT:
        tok = jj_consume_token(NOT);
        break;
      default:
        jj_la1[97] = jj_gen;
        ;
      }
      value = remainingNegatablePredicate(value, inSelectClause);
                /* Put the NOT on top of the tree */
                if (tok != null)
                {
                        value = (ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.NOT_NODE,
                                                                                value,
                                                                                getContextManager());
                }

                {if (true) return value;}
      break;
    default:
      jj_la1[98] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="remainingNonNegatablePredicate">remainingNonNegatablePredicate</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode remainingNonNegatablePredicate(ValueNode leftOperand, boolean inSelectClause) throws ParseException, StandardException {
        int                     operator;
        String          javaClassName;
        Token           tok = null;
        ValueNode       tree = null;
        ValueNode       likePattern;
        ValueNode       betweenLeft;
        ValueNode       betweenRight;
    operator = compOp();
    if ((getToken(1).kind == ALL || getToken(1).kind == ANY ||
                            getToken(1).kind == SOME) && getToken(2).kind == LEFT_PAREN) {
      operator = quantifier(operator);
      jj_consume_token(LEFT_PAREN);
      leftOperand = tableSubquery(operator, leftOperand);
      jj_consume_token(RIGHT_PAREN);
    } else if (jj_2_20(1)) {
      leftOperand = additiveExpression(leftOperand, operator, inSelectClause);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return leftOperand;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="remainingNegatablePredicate">remainingNegatablePredicate</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode remainingNegatablePredicate(ValueNode leftOperand, boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       tree = null;
        ValueNode       likePattern;
        ValueNode       betweenLeft;
        ValueNode       betweenRight;
        ValueNode       escapeValue = null;
    switch (jj_nt.kind) {
    case IN:
      jj_consume_token(IN);
      tree = inPredicateValue(leftOperand);
                {if (true) return tree;}
      break;
    case LIKE:
      jj_consume_token(LIKE);
      likePattern = additiveExpression(null, 0, inSelectClause);
      switch (jj_nt.kind) {
      case ESCAPE:
      case LEFT_BRACE:
        switch (jj_nt.kind) {
        case ESCAPE:
          jj_consume_token(ESCAPE);
          escapeValue = additiveExpression(null, 0, inSelectClause);
          break;
        case LEFT_BRACE:
          jj_consume_token(LEFT_BRACE);
          jj_consume_token(ESCAPE);
          escapeValue = additiveExpression(null, 0, inSelectClause);
          jj_consume_token(RIGHT_BRACE);
          break;
        default:
          jj_la1[99] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[100] = jj_gen;
        ;
      }
                tree = (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.LIKE_OPERATOR_NODE,
                                                                leftOperand,
                                                                likePattern,
                                                                escapeValue,
                                                                getContextManager());

                {if (true) return tree;}
      break;
    case BETWEEN:
      jj_consume_token(BETWEEN);
      betweenLeft = additiveExpression(null, 0, inSelectClause);
      jj_consume_token(AND);
      betweenRight = additiveExpression(null, 0, inSelectClause);
                ValueNodeList betweenList = (ValueNodeList) nodeFactory.getNode(
                                                                                                        C_NodeTypes.VALUE_NODE_LIST,
                                                                                                        getContextManager());
                betweenList.addElement(betweenLeft);
                betweenList.addElement(betweenRight);
                tree = (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.BETWEEN_OPERATOR_NODE,
                                                                leftOperand,
                                                                betweenList,
                                                                getContextManager());

                {if (true) return tree;}
      break;
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="compOp">compOp</A>
 */
  final public int compOp() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case EQUALS_OPERATOR:
      jj_consume_token(EQUALS_OPERATOR);
                {if (true) return BinaryOperatorNode.EQ;}
      break;
    case NOT_EQUALS_OPERATOR:
      jj_consume_token(NOT_EQUALS_OPERATOR);
                {if (true) return BinaryOperatorNode.NE;}
      break;
    case NOT_EQUALS_OPERATOR2:
      jj_consume_token(NOT_EQUALS_OPERATOR2);
                {if (true) return BinaryOperatorNode.NE;}
      break;
    case LESS_THAN_OPERATOR:
      jj_consume_token(LESS_THAN_OPERATOR);
                {if (true) return BinaryOperatorNode.LT;}
      break;
    case GREATER_THAN_OPERATOR:
      jj_consume_token(GREATER_THAN_OPERATOR);
                {if (true) return BinaryOperatorNode.GT;}
      break;
    case LESS_THAN_OR_EQUALS_OPERATOR:
      jj_consume_token(LESS_THAN_OR_EQUALS_OPERATOR);
                {if (true) return BinaryOperatorNode.LE;}
      break;
    case GREATER_THAN_OR_EQUALS_OPERATOR:
      jj_consume_token(GREATER_THAN_OR_EQUALS_OPERATOR);
                {if (true) return BinaryOperatorNode.GE;}
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="additiveExpression">additiveExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode additiveExpression(ValueNode farLeftOperand, int compOp, boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       leftOperand;
        int                     operator;
        int                     nodeType;
    leftOperand = multiplicativeExpression(null, 0, inSelectClause);
    label_13:
    while (true) {
      switch (jj_nt.kind) {
      case PLUS_SIGN:
      case MINUS_SIGN:
        ;
        break;
      default:
        jj_la1[103] = jj_gen;
        break label_13;
      }
      operator = additiveOperator();
      leftOperand = multiplicativeExpression(leftOperand, operator, inSelectClause);
    }
                if (farLeftOperand == null)
                        {if (true) return leftOperand;}

                switch (compOp)
                {
                  case BinaryOperatorNode.EQ:
                        nodeType = C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE;
                        break;

                  case BinaryOperatorNode.NE:
                        nodeType = C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE;
                        break;

                  case BinaryOperatorNode.LT:
                        nodeType = C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE;
                        break;

                  case BinaryOperatorNode.GT:
                        nodeType = C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE;
                        break;

                  case BinaryOperatorNode.LE:
                        nodeType = C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE;
                        break;

                  case BinaryOperatorNode.GE:
                        nodeType = C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE;
                        break;

                  default:
                        if (SanityManager.DEBUG)
                        SanityManager.THROWASSERT("Unknown comparison operator " + compOp);
                        nodeType = 0;
                        break;
                }

                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        nodeType,
                                                        farLeftOperand,
                                                        leftOperand,
                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="additiveOperator">additiveOperator</A>
 */
  final public int additiveOperator() throws ParseException, StandardException {
        Token tok;
    switch (jj_nt.kind) {
    case PLUS_SIGN:
      tok = jj_consume_token(PLUS_SIGN);
                {if (true) return BinaryOperatorNode.PLUS;}
      break;
    case MINUS_SIGN:
      tok = jj_consume_token(MINUS_SIGN);
                {if (true) return BinaryOperatorNode.MINUS;}
      break;
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="multiplicativeExpression">multiplicativeExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode multiplicativeExpression(ValueNode farLeftOperand, int additiveOperator, boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       leftOperand;
        int                     multOp;
    leftOperand = unaryExpression(null, 0, inSelectClause);
    label_14:
    while (true) {
      switch (jj_nt.kind) {
      case ASTERISK:
      case SOLIDUS:
      case CONCATENATION_OPERATOR:
        ;
        break;
      default:
        jj_la1[105] = jj_gen;
        break label_14;
      }
      multOp = multiplicativeOperator();
      leftOperand = unaryExpression(leftOperand, multOp, inSelectClause);
    }
                if (farLeftOperand == null)
                        {if (true) return leftOperand;}

                switch (additiveOperator)
                {
                  case BinaryOperatorNode.PLUS:
                        {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.BINARY_PLUS_OPERATOR_NODE,
                                                                        farLeftOperand,
                                                                        leftOperand,
                                                                        getContextManager()
                                                                        );}

                  case BinaryOperatorNode.MINUS:
                        {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.BINARY_MINUS_OPERATOR_NODE,
                                                                        farLeftOperand,
                                                                        leftOperand,
                                                                        getContextManager()
                                                                        );}

                  default:
                        if (SanityManager.DEBUG)
                        SanityManager.THROWASSERT(
                                        "Unexpected operator value of " + additiveOperator);
                        {if (true) return null;}
                }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="multiplicativeOperator">multiplicativeOperator</A>
 */
  final public int multiplicativeOperator() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
                {if (true) return BinaryOperatorNode.TIMES;}
      break;
    case SOLIDUS:
      jj_consume_token(SOLIDUS);
                {if (true) return BinaryOperatorNode.DIVIDE;}
      break;
    case CONCATENATION_OPERATOR:
      jj_consume_token(CONCATENATION_OPERATOR);
                {if (true) return BinaryOperatorNode.CONCATENATE;}
      break;
    default:
      jj_la1[106] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="unaryExpression">unaryExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode unaryExpression(ValueNode farLeftOperand, int multiplicativeOperator, boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       value;
        String          sign = null;
        int                     tokKind1;
        int                     tokKind2;
    if (( (tokKind1 = getToken(1).kind) == PLUS_SIGN ||
                                               tokKind1 == MINUS_SIGN )
                                            &&
                                            ( (tokKind2 = getToken(2).kind) != EXACT_NUMERIC &&
                                               tokKind2 != APPROXIMATE_NUMERIC)) {
      sign = sign();
    } else {
      ;
    }
    value = primaryExpression(inSelectClause);
                if ("-".equals(sign))
                {
                        value = (ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.UNARY_MINUS_OPERATOR_NODE,
                                                                                value,
                                                                                getContextManager());
                }
                else if ("+".equals(sign))
                {
                        value = (ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.UNARY_PLUS_OPERATOR_NODE,
                                                                                value,
                                                                                getContextManager());
                }
                else if (SanityManager.DEBUG)
                {
                        if (sign != null)
                        {
                                SanityManager.THROWASSERT("Unknown unary operator '"
                                                                                        + sign
                                                                                        + "'");
                        }
                }

                {if (true) return multOp(farLeftOperand, value, multiplicativeOperator);}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="sign">sign</A>
 */
  final public String sign() throws ParseException {
        Token   s;
    switch (jj_nt.kind) {
    case PLUS_SIGN:
      s = jj_consume_token(PLUS_SIGN);
                {if (true) return s.image;}
      break;
    case MINUS_SIGN:
      s = jj_consume_token(MINUS_SIGN);
                {if (true) return s.image;}
      break;
    default:
      jj_la1[107] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="primaryExpressionXX">primaryExpressionXX</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode primaryExpressionXX(boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       value;
    value = primary(inSelectClause);
    label_15:
    while (true) {
      if (jj_2_21(1)) {
        ;
      } else {
        break label_15;
      }
      value = nonStaticMethodCallOrFieldAccess(value);
    }
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public ValueNode nonStaticMethodCallOrFieldAccess(ValueNode receiver) throws ParseException, StandardException {
        ValueNode value;
    value = nonStaticMethodInvocation(receiver);
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="nonStaticMethodInvocation">nonStaticMethodInvocation</A>
 */
  final public ValueNode nonStaticMethodInvocation(ValueNode receiver) throws ParseException, StandardException {
        Vector                                  parameterList = new Vector();
        MethodCallNode                  methodNode;
        ParameterNode                   parameterNode;
    if (getToken(3).kind == LEFT_PAREN) {
      switch (jj_nt.kind) {
      case FIELD_REFERENCE:
        jj_consume_token(FIELD_REFERENCE);
        break;
      case PERIOD:
        jj_consume_token(PERIOD);
        break;
      default:
        jj_la1[108] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      methodNode = methodName(receiver);
      methodCallParameterList(parameterList);
                /*
		** ? parameters are not allowed for the receiver --
		** unless the receiver is standing in for a named parameter,
		** whose type is therefore known.
		*/
                if (receiver instanceof ParameterNode)
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER,
                                                                                                methodNode.getMethodName());}
                }

                methodNode.addParms(parameterList);

                /*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                                methodNode,
                                                                getContextManager());}
    } else {
      switch (jj_nt.kind) {
      case PERIOD:
        jj_consume_token(PERIOD);
        methodNode = methodName(receiver);
                /*
		** ? parameters are not allowed for the receiver --
		** unless the receiver is standing in for a named parameter,
		** whose type is therefore known.
		*/
                if (receiver instanceof ParameterNode)
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER,
                                                                                                methodNode.getMethodName());}
                }

                methodNode.addParms(parameterList);

                /*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                                methodNode,
                                                                getContextManager());}
        break;
      default:
        jj_la1[109] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="methodName">methodName</A>
 */
  final public MethodCallNode methodName(ValueNode receiver) throws ParseException, StandardException {
        String  methodName;
    /*
    	** NOTE: allowing a delimited identifier as a method name is necessary,
    	** because Java is case-sensitive.  But this also allows identifiers that
    	** do not match Java syntax.  This will probably not cause a problem
    	** in later phases, like binding and code generation.
    	*/
            methodName = caseSensitiveIdentifierPlusReservedWords();
                {if (true) return (MethodCallNode) nodeFactory.getNode(
                                                                                C_NodeTypes.NON_STATIC_METHOD_CALL_NODE,
                                                                                methodName,
                                                                                receiver,
                                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="staticMethodName">staticMethodName</A>
 */
  final public MethodCallNode staticMethodName(String javaClassName) throws ParseException, StandardException {
        String  methodName;
    /*
    	** NOTE: allowing a delimited identifier as a method name is necessary,
    	** because Java is case-sensitive.  But this also allows identifiers that
    	** do not match Java syntax.  This will probably not cause a problem
    	** in later phases, like binding and code generation.
    	*/
            methodName = caseSensitiveIdentifierPlusReservedWords();
                {if (true) return (MethodCallNode) nodeFactory.getNode(
                                                                C_NodeTypes.STATIC_METHOD_CALL_NODE,
                                                                methodName,
                                                                javaClassName,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="methodParameter">methodParameter</A>
 */
  final public void methodParameter(Vector parameterList) throws ParseException, StandardException {
        ValueNode       parameter;
    if (jj_2_22(1)) {
      parameter = additiveExpression(null,0,false);
                parameterList.addElement(parameter);
    } else {
      switch (jj_nt.kind) {
      case NULL:
        parameter = nullSpecification();
                parameterList.addElement(parameter);
        break;
      default:
        jj_la1[110] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/*
 * <A NAME="primary">primary</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode primary(boolean inSelectClause) throws ParseException, StandardException {
        String          javaClassName;
        ValueNode       value;
    if (javaClassFollows()) {
      value = staticClassReference();
                {if (true) return value;}
    } else if (jj_2_23(1)) {
      value = valueExpressionPrimary(inSelectClause);
                {if (true) return value;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="staticClassReference">staticClassReference</A>
 */
  final public ValueNode staticClassReference() throws ParseException, StandardException {
        String          javaClassName;
        ValueNode value;
    javaClassName = javaClass();
    jj_consume_token(DOUBLE_COLON);
    value = staticClassReferenceType(javaClassName);
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="staticClassReferenceType">staticClassReferenceType</A>
 */
  final public ValueNode staticClassReferenceType(String javaClassName) throws ParseException, StandardException {
        ValueNode value;
    if ((getToken(2).kind == LEFT_PAREN)) {
      value = staticMethodInvocation(javaClassName);
                {if (true) return value;}
    } else {
      switch (jj_nt.kind) {
      case ADD:
      case ALL:
      case ALLOCATE:
      case ALTER:
      case AND:
      case ANY:
      case ARE:
      case AS:
      case ASC:
      case ASSERTION:
      case AT:
      case AUTHORIZATION:
      case AVG:
      case BEGIN:
      case BETWEEN:
      case BINARY:
      case BIT:
      case BOTH:
      case BY:
      case CASCADE:
      case CASCADED:
      case CASE:
      case CAST:
      case CHAR:
      case CHARACTER:
      case CHECK:
      case CLOSE:
      case COALESCE:
      case COLLATE:
      case COLLATION:
      case COLUMN:
      case COMMIT:
      case CONNECT:
      case CONNECTION:
      case CONSTRAINT:
      case CONSTRAINTS:
      case CONTINUE:
      case CONVERT:
      case CORRESPONDING:
      case COUNT:
      case CREATE:
      case CURRENT:
      case CURRENT_DATE:
      case CURRENT_TIME:
      case CURRENT_TIMESTAMP:
      case CURRENT_USER:
      case CURSOR:
      case D:
      case DEALLOCATE:
      case DEC:
      case DECIMAL:
      case DECLARE:
      case _DEFAULT:
      case DEFERRABLE:
      case DEFERRED:
      case DELETE:
      case DESC:
      case DESCRIBE:
      case DIAGNOSTICS:
      case DISCONNECT:
      case DISTINCT:
      case DOUBLE:
      case DROP:
      case ELSE:
      case END:
      case ENDEXEC:
      case ESCAPE:
      case EXCEPT:
      case EXCEPTION:
      case EXEC:
      case EXECUTE:
      case EXISTS:
      case EXTERNAL:
      case FALSE:
      case FETCH:
      case FIRST:
      case FLOAT:
      case FOR:
      case FOREIGN:
      case FOUND:
      case FROM:
      case FULL:
      case FUNCTION:
      case GET:
      case GLOBAL:
      case GO:
      case GOTO:
      case GRANT:
      case GROUP:
      case HAVING:
      case HOUR:
      case IDENTITY:
      case IMMEDIATE:
      case IN:
      case INDICATOR:
      case INITIALLY:
      case INNER:
      case INPUT:
      case INSENSITIVE:
      case INSERT:
      case INT:
      case INTEGER:
      case INTERSECT:
      case INTO:
      case IS:
      case ISOLATION:
      case JOIN:
      case KEY:
      case LAST:
      case LEFT:
      case LIKE:
      case LOWER:
      case MATCH:
      case MAX:
      case MIN:
      case MINUTE:
      case MODULE:
      case NATIONAL:
      case NATURAL:
      case NCHAR:
      case NEXT:
      case NO:
      case NOT:
      case NULL:
      case NULLIF:
      case NUMERIC:
      case OF:
      case ON:
      case ONLY:
      case OPEN:
      case OPTION:
      case OR:
      case ORDER:
      case OUTER:
      case OUTPUT:
      case OVERLAPS:
      case PAD:
      case PARTIAL:
      case PREPARE:
      case PRESERVE:
      case PRIMARY:
      case PRIOR:
      case PRIVILEGES:
      case PROCEDURE:
      case PUBLIC:
      case READ:
      case REAL:
      case REFERENCES:
      case RELATIVE:
      case RESTRICT:
      case REVOKE:
      case RIGHT:
      case ROLLBACK:
      case ROWS:
      case SCHEMA:
      case SCROLL:
      case SECOND:
      case SELECT:
      case SESSION_USER:
      case SET:
      case SMALLINT:
      case SOME:
      case SPACE:
      case SQL:
      case SQLCODE:
      case SQLERROR:
      case SQLSTATE:
      case SUBSTRING:
      case SUM:
      case SYSTEM_USER:
      case T:
      case TABLE:
      case TEMPORARY:
      case TIMEZONE_HOUR:
      case TIMEZONE_MINUTE:
      case TO:
      case TRANSACTION:
      case TRANSLATE:
      case TRANSLATION:
      case TRUE:
      case TS:
      case UNION:
      case UNIQUE:
      case UNKNOWN:
      case UPDATE:
      case UPPER:
      case USER:
      case USING:
      case VALUE:
      case VALUES:
      case VARBINARY:
      case VARCHAR:
      case VARYING:
      case VIEW:
      case WHENEVER:
      case WHERE:
      case WITH:
      case WORK:
      case WRITE:
      case YEAR:
      case ABS:
      case ABSVAL:
      case ACTION:
      case ALWAYS:
      case BLOB:
      case C:
      case CALLED:
      case CLOB:
      case COBOL:
      case COMMITTED:
      case CONCAT:
      case CONTAINS:
      case DATA:
      case DATE:
      case DAY:
      case DYNAMIC:
      case FORTRAN:
      case GENERATED:
      case IDENTITY_VAL_LOCAL:
      case INCREMENT:
      case INITIAL:
      case INOUT:
      case INTERVAL:
      case LANGUAGE:
      case LARGE:
      case LENGTH:
      case LEVEL:
      case LOCKS:
      case LOCKSIZE:
      case LOGGED:
      case MOD:
      case MODIFIES:
      case MODIFY:
      case MONTH:
      case _MORE:
      case MUMPS:
      case NAME:
      case NCLOB:
      case NULLABLE:
      case NUMBER:
      case OBJECT:
      case PASCAL:
      case PLI:
      case PRECISION:
      case RELEASE:
      case REPEATABLE:
      case RETURNS:
      case ROW:
      case SAVEPOINT:
      case SCALE:
      case SERIALIZABLE:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_HOUR:
      case SQL_TSI_DAY:
      case SQL_TSI_WEEK:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case START:
      case STATEMENT:
      case SYNONYM:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TRUNCATE:
      case TYPE:
      case UNCOMMITTED:
      case USAGE:
      case WHEN:
      case BOOLEAN:
      case CALL:
      case CURDATE:
      case CURTIME:
      case DATABASE:
      case GET_CURRENT_CONNECTION:
      case EXPLAIN:
      case LONGINT:
      case LONG:
      case LTRIM:
      case RTRIM:
      case SUBSTR:
      case XML:
      case XMLPARSE:
      case XMLSERIALIZE:
      case XMLEXISTS:
      case AFTER:
      case BEFORE:
      case CLASS:
      case COMPRESS:
      case CONTENT:
      case CS:
      case DB2SQL:
      case DIRTY:
      case DOCUMENT:
      case EACH:
      case EXCLUSIVE:
      case FN:
      case INDEX:
      case JAVA:
      case LCASE:
      case LOCATE:
      case LOCK:
      case MESSAGE_LOCALE:
      case METHOD:
      case MODE:
      case NEW:
      case NEW_TABLE:
      case NVARCHAR:
      case OJ:
      case OFF:
      case OLD:
      case OLD_TABLE:
      case OUT:
      case PARAMETER:
      case PASSING:
      case PROPERTIES:
      case READS:
      case REF:
      case REFERENCING:
      case RENAME:
      case RESET:
      case RESULT:
      case RETAIN:
      case RR:
      case RS:
      case SEQUENTIAL:
      case SETS:
      case SHARE:
      case SQLID:
      case SPECIFIC:
      case SQRT:
      case STABILITY:
      case STRIP:
      case STYLE:
      case TRIGGER:
      case UCASE:
      case UR:
      case WHITESPACE:
      case IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        value = staticClassFieldReference(javaClassName);
                {if (true) return value;}
        break;
      default:
        jj_la1[111] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="staticClassFieldReference">staticClassFieldReference</A>
 */
  final public ValueNode staticClassFieldReference(String javaClassName) throws ParseException, StandardException {
        String          fieldName = null;
    fieldName = caseSensitiveIdentifierPlusReservedWords();
                {if (true) return  (ValueNode) nodeFactory.getNode(
                                        C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                        nodeFactory.getNode(
                                                                C_NodeTypes.STATIC_CLASS_FIELD_REFERENCE_NODE,
                                                                javaClassName,
                                                                fieldName,
                                                                nextToLastTokenDelimitedIdentifier,
                                                                getContextManager()),
                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="nonSecondDatetimeField">nonSecondDatetimeField</A>
 */
  final public int nonSecondDatetimeField() throws ParseException {
    switch (jj_nt.kind) {
    case YEAR:
      jj_consume_token(YEAR);
                {if (true) return DateTimeDataValue.YEAR_FIELD;}
      break;
    case MONTH:
      jj_consume_token(MONTH);
                {if (true) return DateTimeDataValue.MONTH_FIELD;}
      break;
    case DAY:
      jj_consume_token(DAY);
                {if (true) return DateTimeDataValue.DAY_FIELD;}
      break;
    case HOUR:
      jj_consume_token(HOUR);
                {if (true) return DateTimeDataValue.HOUR_FIELD;}
      break;
    case MINUTE:
      jj_consume_token(MINUTE);
                {if (true) return DateTimeDataValue.MINUTE_FIELD;}
      break;
    default:
      jj_la1[112] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ValueNode escapedValueFunction() throws ParseException, StandardException {
        ValueNode       value;
    ValueNode   str1;
    ValueNode   str2;
        ValueNode       startPosition;
    ValueNode   length = null;
    if (jj_2_24(1)) {
      value = miscBuiltinsCore(true /* is JDBC escape */);
                {if (true) return value;}
    } else {
      switch (jj_nt.kind) {
      case SUBSTRING:
        jj_consume_token(SUBSTRING);
        jj_consume_token(LEFT_PAREN);
        value = additiveExpression(null, 0, false);
        jj_consume_token(COMMA);
        startPosition = additiveExpression(null, 0, false);
        switch (jj_nt.kind) {
        case COMMA:
          jj_consume_token(COMMA);
          length = additiveExpression(null, 0, false);
          break;
        default:
          jj_la1[113] = jj_gen;
          ;
        }
        jj_consume_token(RIGHT_PAREN);
        {if (true) return getSubstringNode(value, startPosition, length, Boolean.FALSE);}
        break;
      case CURDATE:
        jj_consume_token(CURDATE);
        jj_consume_token(LEFT_PAREN);
        jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                                                ReuseFactory.getInteger(
                                                                        CurrentDatetimeOperatorNode.CURRENT_DATE),
                                                                getContextManager());}
        break;
      case CURTIME:
        jj_consume_token(CURTIME);
        jj_consume_token(LEFT_PAREN);
        jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                                        ReuseFactory.getInteger(
                                                                CurrentDatetimeOperatorNode.CURRENT_TIME),
                                                        getContextManager());}
        break;
      case CONCAT:
        jj_consume_token(CONCAT);
        jj_consume_token(LEFT_PAREN);
        str1 = additiveExpression(null,0,false);
        jj_consume_token(COMMA);
        str2 = additiveExpression(null,0,false);
        jj_consume_token(RIGHT_PAREN);
        {if (true) return (ValueNode) nodeFactory.getNode(
                            C_NodeTypes.CONCATENATION_OPERATOR_NODE,
                            str1,
                            str2,
                            getContextManager());}
        break;
      case CURRENT_USER:
      case SESSION_USER:
      case USER:
        /* Method versions of USER special registers
        	 * are ODBC remnants.  Only supported
        	 * when escaped.
        	 */
                value = userNode();
        jj_consume_token(LEFT_PAREN);
        jj_consume_token(RIGHT_PAREN);
                {if (true) return value;}
        break;
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
        value = timestampArithmeticFuncion();
        {if (true) return value;}
        break;
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="timestampArithmeticFuncion">timestampArithmeticFuncion</A>
 */
  final public ValueNode timestampArithmeticFuncion() throws ParseException, StandardException {
    ValueNode intervalType;
    ValueNode tstamp1;
    ValueNode tstamp2;
    ValueNode count;
    switch (jj_nt.kind) {
    case TIMESTAMPADD:
      jj_consume_token(TIMESTAMPADD);
      jj_consume_token(LEFT_PAREN);
      intervalType = jdbcIntervalType();
      jj_consume_token(COMMA);
      count = additiveExpression(null,0,false);
      jj_consume_token(COMMA);
      tstamp1 = additiveExpression(null,0,false);
      jj_consume_token(RIGHT_PAREN);
        {if (true) return (ValueNode) nodeFactory.getNode( C_NodeTypes.TIMESTAMP_ADD_FN_NODE,
                                                tstamp1,
                                                intervalType,
                                                count,
                                                ReuseFactory.getInteger( TernaryOperatorNode.TIMESTAMPADD),
                                                null,
                                                getContextManager());}
      break;
    case TIMESTAMPDIFF:
      jj_consume_token(TIMESTAMPDIFF);
      jj_consume_token(LEFT_PAREN);
      intervalType = jdbcIntervalType();
      jj_consume_token(COMMA);
      tstamp1 = additiveExpression(null,0,false);
      jj_consume_token(COMMA);
      tstamp2 = additiveExpression(null,0,false);
      jj_consume_token(RIGHT_PAREN);
        {if (true) return (ValueNode) nodeFactory.getNode( C_NodeTypes.TIMESTAMP_DIFF_FN_NODE,
                                                tstamp2,
                                                intervalType,
                                                tstamp1,
                                                ReuseFactory.getInteger( TernaryOperatorNode.TIMESTAMPDIFF),
                                                null,
                                                getContextManager());}
      break;
    default:
      jj_la1[115] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="jdbcIntervalType">jdbcIntervalType</A>
 */
  final public ValueNode jdbcIntervalType() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case SQL_TSI_FRAC_SECOND:
      jj_consume_token(SQL_TSI_FRAC_SECOND);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.FRAC_SECOND_INTERVAL);}
      break;
    case SQL_TSI_SECOND:
      jj_consume_token(SQL_TSI_SECOND);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.SECOND_INTERVAL);}
      break;
    case SQL_TSI_MINUTE:
      jj_consume_token(SQL_TSI_MINUTE);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.MINUTE_INTERVAL);}
      break;
    case SQL_TSI_HOUR:
      jj_consume_token(SQL_TSI_HOUR);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.HOUR_INTERVAL);}
      break;
    case SQL_TSI_DAY:
      jj_consume_token(SQL_TSI_DAY);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.DAY_INTERVAL);}
      break;
    case SQL_TSI_WEEK:
      jj_consume_token(SQL_TSI_WEEK);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.WEEK_INTERVAL);}
      break;
    case SQL_TSI_MONTH:
      jj_consume_token(SQL_TSI_MONTH);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.MONTH_INTERVAL);}
      break;
    case SQL_TSI_QUARTER:
      jj_consume_token(SQL_TSI_QUARTER);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.QUARTER_INTERVAL);}
      break;
    case SQL_TSI_YEAR:
      jj_consume_token(SQL_TSI_YEAR);
        {if (true) return getJdbcIntervalNode( DateTimeDataValue.YEAR_INTERVAL);}
      break;
    default:
      jj_la1[116] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="numericValueFunction">numericValueFunction</A>
 */
  final public ValueNode numericValueFunction() throws ParseException, StandardException {
        ValueNode       value;
        int                     field;
    switch (jj_nt.kind) {
    case ABS:
      jj_consume_token(ABS);
      value = absFunction();
                {if (true) return value;}
      break;
    case ABSVAL:
      jj_consume_token(ABSVAL);
      value = absFunction();
                {if (true) return value;}
      break;
    case SQRT:
      jj_consume_token(SQRT);
      jj_consume_token(LEFT_PAREN);
      value = additiveExpression(null,0,false);
      jj_consume_token(RIGHT_PAREN);
        {if (true) return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.SQRT_OPERATOR_NODE,
                value,
                getContextManager());}
      break;
    case MOD:
      jj_consume_token(MOD);
      value = modFunction();
                {if (true) return value;}
      break;
    case IDENTITY_VAL_LOCAL:
      jj_consume_token(IDENTITY_VAL_LOCAL);
      jj_consume_token(LEFT_PAREN);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.IDENTITY_VAL_NODE,
                                                getContextManager());}
      break;
    default:
      jj_la1[117] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="coalesceFunction">coalesceFunction</A>
 */
  final public ValueNode coalesceFunction(String coalesceOrValue) throws ParseException, StandardException {
    ValueNodeList expressionList = (ValueNodeList) nodeFactory.getNode(
        C_NodeTypes.VALUE_NODE_LIST,
        getContextManager());
    jj_consume_token(LEFT_PAREN);
    coalesceExpression(expressionList);
    label_16:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[118] = jj_gen;
        break label_16;
      }
      jj_consume_token(COMMA);
      coalesceExpression(expressionList);
    }
    jj_consume_token(RIGHT_PAREN);
        {if (true) return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.COALESCE_FUNCTION_NODE,
                coalesceOrValue,
                expressionList,
                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="coalesceExpression">coalesceExpression</A>
 */
  final public void coalesceExpression(ValueNodeList expressionList) throws ParseException, StandardException {
        ValueNode       expression;
    expression = additiveExpression(null,0,false);
                expressionList.addElement(expression);
  }

/*
 * <A NAME="absFunction">absFunction</A>
 */
  final public ValueNode absFunction() throws ParseException, StandardException {
    ValueNode value;
    jj_consume_token(LEFT_PAREN);
    value = additiveExpression(null,0,false);
    jj_consume_token(RIGHT_PAREN);
        {if (true) return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.ABSOLUTE_OPERATOR_NODE,
                value,
                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="modFunction">modFunction</A>
 */
  final public ValueNode modFunction() throws ParseException, StandardException {
    ValueNode int1;
        ValueNode int2;
    jj_consume_token(LEFT_PAREN);
    int1 = additiveExpression(null,0,false);
    jj_consume_token(COMMA);
    int2 = additiveExpression(null,0,false);
    jj_consume_token(RIGHT_PAREN);
        {if (true) return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.MOD_OPERATOR_NODE,
                int1, int2,
                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="datetimeField">datetimeField</A>
 */
  final public int datetimeField() throws ParseException {
        int field;
    switch (jj_nt.kind) {
    case HOUR:
    case MINUTE:
    case YEAR:
    case DAY:
    case MONTH:
      field = nonSecondDatetimeField();
                {if (true) return field;}
      break;
    case SECOND:
      jj_consume_token(SECOND);
                {if (true) return DateTimeDataValue.SECOND_FIELD;}
      break;
    default:
      jj_la1[119] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ValueNode characterValueFunction() throws ParseException, StandardException {
        ValueNode       value = null;
        ValueNode       str1;
        ValueNode       str2;
        Token           upperTok = null;
        Token           lowerTok = null;
        ValueNode       startPosition;
    ValueNode   length = null;
    switch (jj_nt.kind) {
    case SUBSTR:
      jj_consume_token(SUBSTR);
      jj_consume_token(LEFT_PAREN);
      value = additiveExpression(null,0,false);
      jj_consume_token(COMMA);
      startPosition = additiveExpression(null,0,false);
      switch (jj_nt.kind) {
      case COMMA:
        jj_consume_token(COMMA);
        length = additiveExpression(null,0,false);
        break;
      default:
        jj_la1[120] = jj_gen;
        ;
      }
      jj_consume_token(RIGHT_PAREN);
        {if (true) return getSubstringNode( value, startPosition, length, Boolean.FALSE );}
      break;
    case LOWER:
    case UPPER:
      switch (jj_nt.kind) {
      case UPPER:
        upperTok = jj_consume_token(UPPER);
        break;
      case LOWER:
        lowerTok = jj_consume_token(LOWER);
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LEFT_PAREN);
      value = additiveExpression(null,0,false);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                        C_NodeTypes.SIMPLE_STRING_OPERATOR_NODE,
                                        value,
                                        (upperTok != null) ? "upper" : "lower",
                                        getContextManager());}
      break;
    case LCASE:
    case UCASE:
      switch (jj_nt.kind) {
      case UCASE:
        upperTok = jj_consume_token(UCASE);
        break;
      case LCASE:
        lowerTok = jj_consume_token(LCASE);
        break;
      default:
        jj_la1[122] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LEFT_PAREN);
      value = additiveExpression(null,0,false);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                        C_NodeTypes.SIMPLE_STRING_OPERATOR_NODE,
                                        value,
                                        (upperTok != null) ? "upper" : "lower",
                                        getContextManager());}
      break;
    case LTRIM:
    case RTRIM:
      value = trimFunction();
                {if (true) return value;}
      break;
    case LOCATE:
      jj_consume_token(LOCATE);
      jj_consume_token(LEFT_PAREN);
      str1 = additiveExpression(null,0,false);
      jj_consume_token(COMMA);
      str2 = additiveExpression(null,0,false);
      switch (jj_nt.kind) {
      case COMMA:
        jj_consume_token(COMMA);
        value = additiveExpression(null,0,false);
        break;
      default:
        jj_la1[123] = jj_gen;
        ;
      }
      jj_consume_token(RIGHT_PAREN);
                // if start is missing, start is equal to 1
        {if (true) return (ValueNode) nodeFactory.getNode(
                            C_NodeTypes.LOCATE_FUNCTION_NODE,
                            str1,
                            str2,
                            (value == null) ? getNodeFactory().getNode(
                                        C_NodeTypes.INT_CONSTANT_NODE,
                                        ReuseFactory.getInteger(1),
                                        getContextManager() )
                                                                                        : value,
                            ReuseFactory.getInteger(TernaryOperatorNode.LOCATE),
                            null,
                            getContextManager());}
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ValueNode trimFunction() throws ParseException, StandardException {
        ValueNode       source;
        Integer         trimType;
    trimType = trimType();
    jj_consume_token(LEFT_PAREN);
    source = additiveExpression(null,0,false);
    jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.TRIM_OPERATOR_NODE,
                                                                        source,
                                                                        source,
                                                                        null,
                                                                        ReuseFactory.getInteger(TernaryOperatorNode.TRIM),
                                                                        trimType,
                                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public Integer trimType() throws ParseException {
    switch (jj_nt.kind) {
    case RTRIM:
      jj_consume_token(RTRIM);
                {if (true) return ReuseFactory.getInteger(StringDataValue.TRAILING);}
      break;
    case LTRIM:
      jj_consume_token(LTRIM);
                {if (true) return ReuseFactory.getInteger(StringDataValue.LEADING);}
      break;
    default:
      jj_la1[125] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="valueExpressionPrimary">valueExpressionPrimary</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
  final public ValueNode valueExpressionPrimary(boolean inSelectClause) throws ParseException, StandardException {
        ValueNode       value;
        int                     tokKind;
    if (escapedValueFunctionFollows()) {
      jj_consume_token(LEFT_BRACE);
      jj_consume_token(FN);
      value = escapedValueFunction();
      jj_consume_token(RIGHT_BRACE);
                {if (true) return value;}
    } else if (getToken(2).kind == SCHEMA || getToken(2).kind == SQLID) {
      jj_consume_token(CURRENT);
      switch (jj_nt.kind) {
      case SCHEMA:
        jj_consume_token(SCHEMA);
        break;
      case SQLID:
        jj_consume_token(SQLID);
        break;
      default:
        jj_la1[126] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.CURRENT_SCHEMA_NODE,
                                                getContextManager());}
    } else if (getToken(2).kind == ISOLATION) {
      jj_consume_token(CURRENT);
      jj_consume_token(ISOLATION);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.CURRENT_ISOLATION_NODE,
                                                getContextManager());}
    } else {
      switch (jj_nt.kind) {
      case CASE:
      case CURRENT_USER:
      case FALSE:
      case NULLIF:
      case SESSION_USER:
      case TRUE:
      case USER:
      case LEFT_BRACE:
      case PLUS_SIGN:
      case MINUS_SIGN:
      case QUESTION_MARK:
      case EXACT_NUMERIC:
      case STRING:
      case HEX_STRING:
      case APPROXIMATE_NUMERIC:
        /* Omitted "case_expression" */
                value = valueSpecification();
                {if (true) return value;}
        break;
      default:
        jj_la1[127] = jj_gen;
        if (newInvocationFollows(1)) {
          value = newInvocation();
                {if (true) return value;}
        } else if (aggregateFollows()) {
          value = aggregateNode();
                {if (true) return value;}
        } else if (miscBuiltinFollows()) {
          value = miscBuiltins();
                {if (true) return value;}
        } else {
          switch (jj_nt.kind) {
          case BINARY:
          case COALESCE:
          case D:
          case MODULE:
          case T:
          case TS:
          case VALUE:
          case VARBINARY:
          case ABS:
          case ABSVAL:
          case ACTION:
          case ALWAYS:
          case BLOB:
          case C:
          case CALLED:
          case CLOB:
          case COBOL:
          case COMMITTED:
          case CONCAT:
          case CONTAINS:
          case DATA:
          case DATE:
          case DAY:
          case DYNAMIC:
          case FORTRAN:
          case GENERATED:
          case IDENTITY_VAL_LOCAL:
          case INCREMENT:
          case INITIAL:
          case INTERVAL:
          case LANGUAGE:
          case LARGE:
          case LENGTH:
          case LEVEL:
          case LOCKS:
          case LOCKSIZE:
          case LOGGED:
          case MOD:
          case MODIFIES:
          case MODIFY:
          case MONTH:
          case _MORE:
          case MUMPS:
          case NAME:
          case NCLOB:
          case NULLABLE:
          case NUMBER:
          case OBJECT:
          case PASCAL:
          case PLI:
          case PRECISION:
          case RELEASE:
          case REPEATABLE:
          case RETURNS:
          case ROW:
          case SAVEPOINT:
          case SCALE:
          case SERIALIZABLE:
          case SQL_TSI_FRAC_SECOND:
          case SQL_TSI_SECOND:
          case SQL_TSI_MINUTE:
          case SQL_TSI_HOUR:
          case SQL_TSI_DAY:
          case SQL_TSI_WEEK:
          case SQL_TSI_MONTH:
          case SQL_TSI_QUARTER:
          case SQL_TSI_YEAR:
          case START:
          case STATEMENT:
          case SYNONYM:
          case THEN:
          case TIME:
          case TIMESTAMP:
          case TIMESTAMPADD:
          case TIMESTAMPDIFF:
          case TRUNCATE:
          case TYPE:
          case UNCOMMITTED:
          case USAGE:
          case WHEN:
          case CURDATE:
          case CURTIME:
          case DATABASE:
          case LONG:
          case AFTER:
          case BEFORE:
          case CLASS:
          case COMPRESS:
          case CONTENT:
          case CS:
          case DB2SQL:
          case DIRTY:
          case DOCUMENT:
          case EACH:
          case EXCLUSIVE:
          case FN:
          case INDEX:
          case JAVA:
          case LCASE:
          case LOCATE:
          case LOCK:
          case MESSAGE_LOCALE:
          case METHOD:
          case MODE:
          case NEW:
          case NEW_TABLE:
          case OJ:
          case OFF:
          case OLD:
          case OLD_TABLE:
          case PARAMETER:
          case PASSING:
          case PROPERTIES:
          case READS:
          case REF:
          case REFERENCING:
          case RENAME:
          case RESET:
          case RESULT:
          case RETAIN:
          case RR:
          case RS:
          case SEQUENTIAL:
          case SETS:
          case SHARE:
          case SQLID:
          case SPECIFIC:
          case SQRT:
          case STABILITY:
          case STRIP:
          case STYLE:
          case TRIGGER:
          case UCASE:
          case UR:
          case WHITESPACE:
          case IDENTIFIER:
          case DELIMITED_IDENTIFIER:
            value = columnReference();
                {if (true) return value;}
            break;
          case LEFT_PAREN:
            jj_consume_token(LEFT_PAREN);
            if (getToken(1).kind == SELECT || getToken(1).kind == VALUES) {
              value = subquery(SubqueryNode.EXPRESSION_SUBQUERY, null);
            } else if (inSelectClause) {
              value = additiveExpression(null,0, inSelectClause);
            } else if (jj_2_25(1)) {
              //following will happen if we are not coming here for select/values clause
                              value = valueExpression(inSelectClause);
            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(RIGHT_PAREN);
                {if (true) return value;}
            break;
          case CAST:
            value = castSpecification();
                {if (true) return value;}
            break;
          default:
            jj_la1[128] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="miscBuiltins">miscBuiltins</A>
 */
  final public ValueNode miscBuiltins() throws ParseException, StandardException {
        ValueNode value;
    if (( (getToken(1).kind == GET_CURRENT_CONNECTION ||
                    getToken(1).kind == ABS ||
                    getToken(1).kind == ABSVAL ||
                    getToken(1).kind == SQRT ||
                    getToken(1).kind == MOD ||
                    getToken(1).kind == COALESCE ||
                    getToken(1).kind == VALUE ||
                    getToken(1).kind == IDENTITY_VAL_LOCAL ||
                    getToken(1).kind == SUBSTRING ||
                    getToken(1).kind == SUBSTR ||
                    getToken(1).kind == UPPER ||
                    getToken(1).kind == LOWER ||
                    getToken(1).kind == UCASE ||
                    getToken(1).kind == LCASE ||
                    getToken(1).kind == LTRIM ||
                    getToken(1).kind == RTRIM ||
                    getToken(1).kind == DATE ||
                    getToken(1).kind == TIME ||
                    getToken(1).kind == TIMESTAMP ||
                    getToken(1).kind == DOUBLE ||
                    getToken(1).kind == CHAR ||
                    getToken(1).kind == VARCHAR ||
                    getToken(1).kind == INTEGER ||
                    getToken(1).kind == SMALLINT ||
                    getToken(1).kind == LONGINT ||
                    getToken(1).kind == YEAR ||
                    getToken(1).kind == MONTH ||
                    getToken(1).kind == DAY ||
                    getToken(1).kind == HOUR ||
                    getToken(1).kind == MINUTE ||
                    getToken(1).kind == SECOND ||
                    getToken(1).kind == LENGTH ||
                    getToken(1).kind == LOCATE ||
                    getToken(1).kind == XMLPARSE ||
                    getToken(1).kind == XMLSERIALIZE ||
                    getToken(1).kind == XMLEXISTS ) &&
                  getToken(2).kind == LEFT_PAREN
                  )) {
      /* miscBuiltins() are composed of the core
      	 * system, string and numeric functions,
      	 * date functions
      	 * and static method calls.
      	 */
              value = miscBuiltinsCore(false /* not JDBC escape */);
                {if (true) return value;}
    } else if (jj_2_26(1)) {
      value = datetimeValueFunction();
                {if (true) return value;}
    } else {
      switch (jj_nt.kind) {
      case BINARY:
      case COALESCE:
      case D:
      case MODULE:
      case T:
      case TS:
      case VALUE:
      case VARBINARY:
      case ABS:
      case ABSVAL:
      case ACTION:
      case ALWAYS:
      case BLOB:
      case C:
      case CALLED:
      case CLOB:
      case COBOL:
      case COMMITTED:
      case CONCAT:
      case CONTAINS:
      case DATA:
      case DATE:
      case DAY:
      case DYNAMIC:
      case FORTRAN:
      case GENERATED:
      case IDENTITY_VAL_LOCAL:
      case INCREMENT:
      case INITIAL:
      case INTERVAL:
      case LANGUAGE:
      case LARGE:
      case LENGTH:
      case LEVEL:
      case LOCKS:
      case LOCKSIZE:
      case LOGGED:
      case MOD:
      case MODIFIES:
      case MODIFY:
      case MONTH:
      case _MORE:
      case MUMPS:
      case NAME:
      case NCLOB:
      case NULLABLE:
      case NUMBER:
      case OBJECT:
      case PASCAL:
      case PLI:
      case PRECISION:
      case RELEASE:
      case REPEATABLE:
      case RETURNS:
      case ROW:
      case SAVEPOINT:
      case SCALE:
      case SERIALIZABLE:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_HOUR:
      case SQL_TSI_DAY:
      case SQL_TSI_WEEK:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case START:
      case STATEMENT:
      case SYNONYM:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TRUNCATE:
      case TYPE:
      case UNCOMMITTED:
      case USAGE:
      case WHEN:
      case CURDATE:
      case CURTIME:
      case DATABASE:
      case LONG:
      case AFTER:
      case BEFORE:
      case CLASS:
      case COMPRESS:
      case CONTENT:
      case CS:
      case DB2SQL:
      case DIRTY:
      case DOCUMENT:
      case EACH:
      case EXCLUSIVE:
      case FN:
      case INDEX:
      case JAVA:
      case LCASE:
      case LOCATE:
      case LOCK:
      case MESSAGE_LOCALE:
      case METHOD:
      case MODE:
      case NEW:
      case NEW_TABLE:
      case OJ:
      case OFF:
      case OLD:
      case OLD_TABLE:
      case PARAMETER:
      case PASSING:
      case PROPERTIES:
      case READS:
      case REF:
      case REFERENCING:
      case RENAME:
      case RESET:
      case RESULT:
      case RETAIN:
      case RR:
      case RS:
      case SEQUENTIAL:
      case SETS:
      case SHARE:
      case SQLID:
      case SPECIFIC:
      case SQRT:
      case STABILITY:
      case STRIP:
      case STYLE:
      case TRIGGER:
      case UCASE:
      case UR:
      case WHITESPACE:
      case IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        /* This is where we build a node for static method aliases */
                value = routineInvocation();
                {if (true) return value;}
        break;
      default:
        jj_la1[129] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ValueNode miscBuiltinsCore(boolean isJDBCEscape) throws ParseException, StandardException {
        ValueNode value;
    switch (jj_nt.kind) {
    case GET_CURRENT_CONNECTION:
      jj_consume_token(GET_CURRENT_CONNECTION);
      jj_consume_token(LEFT_PAREN);
      jj_consume_token(RIGHT_PAREN);
                checkInternalFeature("GETCURRENTCONNECTION()");
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                                nodeFactory.getNode(
                                                                        C_NodeTypes.GET_CURRENT_CONNECTION_NODE,
                                                                        getContextManager()),
                                                                getContextManager());}
      break;
    case ABS:
    case ABSVAL:
    case IDENTITY_VAL_LOCAL:
    case MOD:
    case SQRT:
      value = numericValueFunction();
                {if (true) return value;}
      break;
    case LOWER:
    case UPPER:
    case LTRIM:
    case RTRIM:
    case SUBSTR:
    case LCASE:
    case LOCATE:
    case UCASE:
      value = characterValueFunction();
                {if (true) return value;}
      break;
    default:
      jj_la1[130] = jj_gen;
      if (jj_2_27(1)) {
        value = dataTypeScalarFunction();
                {if (true) return value;}
      } else {
        switch (jj_nt.kind) {
        case COALESCE:
          jj_consume_token(COALESCE);
          value = coalesceFunction("COALESCE");
                {if (true) return value;}
          break;
        case VALUE:
          jj_consume_token(VALUE);
          value = coalesceFunction("VALUE");
                {if (true) return value;}
          break;
        case LENGTH:
          jj_consume_token(LENGTH);
          jj_consume_token(LEFT_PAREN);
          value = additiveExpression(null,0, false);
          jj_consume_token(RIGHT_PAREN);
                ContextManager  localCM = getContextManager();
                if( isJDBCEscape)
                        {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.CHAR_LENGTH_OPERATOR_NODE,
                                                                (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.TRIM_OPERATOR_NODE,
                                                                        value,
                                                                                value,
                                                                                null,
                                                                        ReuseFactory.getInteger(TernaryOperatorNode.TRIM),
                                                                        ReuseFactory.getInteger(StringDataValue.TRAILING),
                                        localCM),
                                                                localCM);}
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.DB2_LENGTH_OPERATOR_NODE,
                                                        value,
                                                        localCM);}
          break;
        case XMLPARSE:
        case XMLSERIALIZE:
        case XMLEXISTS:
          value = xmlFunction();
                {if (true) return value;}
          break;
        default:
          jj_la1[131] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dataTypeScalarFunction">dataTypeScalarFunction</A>
 */
  final public ValueNode dataTypeScalarFunction() throws ParseException, StandardException {
        DataTypeDescriptor dts;
        ValueNode value;           //converted result
        ValueNode operand;
        int charType;
        int length = -1;
    switch (jj_nt.kind) {
    case HOUR:
    case MINUTE:
    case SECOND:
    case YEAR:
    case DATE:
    case DAY:
    case MONTH:
    case TIME:
    case TIMESTAMP:
      //Note: When you add a new data type function, in addition to adding it 
              // here, you need to add it to miscBuiltins()
              value = dateTimeScalarFunction();
                {if (true) return value;}
      break;
    default:
      jj_la1[133] = jj_gen;
      if (jj_2_28(1)) {
        dts = numericFunctionType();
        jj_consume_token(LEFT_PAREN);
        operand = additiveExpression(null,0, false);
        jj_consume_token(RIGHT_PAREN);
                        value = (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.CAST_NODE,
                                                                        operand,
                                                                        dts,
                                                                        getContextManager());
                        ((CastNode) value).setForDataTypeFunction(true);

                        {if (true) return value;}
      } else {
        switch (jj_nt.kind) {
        case CHAR:
        case VARCHAR:
          charType = charOrVarchar();
          jj_consume_token(LEFT_PAREN);
          operand = additiveExpression(null,0, false);
          switch (jj_nt.kind) {
          case COMMA:
            jj_consume_token(COMMA);
            length = length();
            break;
          default:
            jj_la1[132] = jj_gen;
            ;
          }
          jj_consume_token(RIGHT_PAREN);
                // Always check db2 limits for this function. It's new
                checkTypeLimits(charType,length);
                value = (ValueNode) nodeFactory.getNode(
                                                                                                C_NodeTypes.CAST_NODE,
                                                                                                operand,
                                                                                                new Integer(charType),
                                                                                                new Integer(length),
                                                                                                getContextManager());

                ((CastNode) value).setForDataTypeFunction(true);
                {if (true) return value;}
          break;
        default:
          jj_la1[134] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="xmlFunction">xmlFunction</A>
 *
 * This method parses the built-in functions used with
 * the XML datatype.
 *
 */
  final public ValueNode xmlFunction() throws ParseException, StandardException {
        ValueNode value;
        checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "XML");
    switch (jj_nt.kind) {
    case XMLPARSE:
      jj_consume_token(XMLPARSE);
      jj_consume_token(LEFT_PAREN);
      xmlDocOrContent();
      value = xmlParseValue();
      jj_consume_token(RIGHT_PAREN);
                {if (true) return value;}
      break;
    case XMLSERIALIZE:
      jj_consume_token(XMLSERIALIZE);
      jj_consume_token(LEFT_PAREN);
      value = xmlSerializeValue();
      jj_consume_token(RIGHT_PAREN);
                {if (true) return value;}
      break;
    case XMLEXISTS:
      jj_consume_token(XMLEXISTS);
      jj_consume_token(LEFT_PAREN);
      value = xmlExistsValue();
      jj_consume_token(RIGHT_PAREN);
                {if (true) return value;}
      break;
    default:
      jj_la1[135] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="xmlParseValue">xmlParseValue</A>
 *
 * Syntax is as follows:
 *
 *     XMLPARSE( DOCUMENT <string-value-expression> PRESERVE WHITESPACE )
 *
 * The result of this operation will be an XML value, which can either
 * be used transiently or else can be stored persistently in a table that
 * has an XML column.  For example:
 *
 * ij> CREATE TABLE x_table (id INT, xdoc XML);
 * 0 rows inserted/updated/deleted
 * ij> INSERT INTO x_table VALUES (1, XMLPARSE(DOCUMENT '<simp> doc </simp>'
 * PRESERVE WHITESPACE));
 * 1 row inserted/updated/deleted
 *
 * We only allow XML documents (as opposed to XML content) to be
 * parsed into XML values.  Note that we require the "PRESERVE WHITESPACE"
 * keyword to be explicit; this is because the SQL/XML (2003) spec says that
 * if no whitespace option is given, the default is "STRIP WHITESPACE", which
 * we don't support (yet).
 *
 * By the time we get to this method, the "DOCUMENT" keyword has already
 * been parsed.
 *
 */
  final public ValueNode xmlParseValue() throws ParseException, StandardException {
        ValueNode value;
        boolean wsOption;
    value = additiveExpression(null,0,false);
    wsOption = xmlPreserveWhitespace();
                {if (true) return (ValueNode) nodeFactory.getNode(
                                        C_NodeTypes.XML_PARSE_OPERATOR_NODE,
                                        value,
                                        ReuseFactory.getInteger(UnaryOperatorNode.XMLPARSE_OP),
                                        new Object[] {(wsOption ? Boolean.TRUE : Boolean.FALSE)},
                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="xmlPreserveWhitespace">xmlPreserveWhitespace</A>
 *
 * For now, we only support the PRESERVE WHITESPACE option.
 *
 */
  final public boolean xmlPreserveWhitespace() throws ParseException, StandardException {
    if ((getToken(1).kind != STRIP) &&
                    (getToken(1).kind != PRESERVE)) {
                {if (true) throw StandardException.newException(
                        SQLState.LANG_XML_KEYWORD_MISSING, "PRESERVE WHITESPACE");}
    } else {
      switch (jj_nt.kind) {
      case STRIP:
        jj_consume_token(STRIP);
        jj_consume_token(WHITESPACE);
          // don't preserve whitespace.
                {if (true) throw StandardException.newException(
                        SQLState.LANG_UNSUPPORTED_XML_FEATURE, "STRIP WHITESPACE");}
        break;
      case PRESERVE:
        jj_consume_token(PRESERVE);
        jj_consume_token(WHITESPACE);
          // must preserve whitespace.
                {if (true) return true;}
        break;
      default:
        jj_la1[136] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="xmlSerializeValue">xmlSerializeValue</A>
 *
 * Syntax is as follows:
 *
 *   XMLSERIALIZE( <xml-value-expression> AS <string-data-type> )
 *
 * The result of this operation will be a string value with the type specified
 * by the user.  For example:
 *
 * ij> SELECT id, XMLSERIALIZE(xdoc AS varchar(30)) FROM x_table;
 * ID         |2
 * ------------------------------------------
 * 1          |<simp> doc </simp>
 *
 */
  final public ValueNode xmlSerializeValue() throws ParseException, StandardException {
        ValueNode value;
        DataTypeDescriptor targetType;
    value = additiveExpression(null,0,false);
    targetType = xmlSerializeTargetType();
                {if (true) return (ValueNode) nodeFactory.getNode(
                                        C_NodeTypes.XML_SERIALIZE_OPERATOR_NODE,
                                        value,
                                        ReuseFactory.getInteger(UnaryOperatorNode.XMLSERIALIZE_OP),
                                        new Object[] {targetType},
                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="xmlSerializeTargetType">xmlSerializeTargetType</A>
 *
 * Parse the target type of an XMLSERIALIZE operation.
 *
 */
  final public DataTypeDescriptor xmlSerializeTargetType() throws ParseException, StandardException {
        DataTypeDescriptor targetType;
    if ((getToken(1).kind != AS) || (getToken(2).kind == RIGHT_PAREN)) {
                {if (true) throw StandardException.newException(
                        SQLState.LANG_XML_KEYWORD_MISSING, "AS <string-type>");}
    } else {
      switch (jj_nt.kind) {
      case AS:
        jj_consume_token(AS);
        targetType = dataTypeDDL();
                {if (true) return targetType;}
        break;
      default:
        jj_la1[137] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="xmlExistsValue">xmlExistsValue</A>
 *
 * Syntax is as follows:
 *
 *   XMLEXISTS( <xpath-expression> PASSING BY VALUE <xml-value-expression> )
 *
 * The result of this operation will be a boolean true/false/unknown value:
 *   -- Unknown if either <xpath-expression> or <xml-value-expression> is null;
 *   -- True if at least one node in the given xml-value matches the given
 *      XPath expression;
 *   -- False otherwise.
 *
 * For example:
 *
 * ij> SELECT id FROM x_table WHERE XMLEXISTS('/simple' PASSING BY VALUE xdoc);
 * ID
 * -----------
 * 1
 *
 */
  final public ValueNode xmlExistsValue() throws ParseException, StandardException {
        ValueNode xpathExpr;
        ValueNode xmlValue;
    xpathExpr = additiveExpression(null,0,false);
    xmlPassingMechanism();
    xmlValue = additiveExpression(null, 0, false);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                        C_NodeTypes.XML_EXISTS_OPERATOR_NODE,
                                        xpathExpr,
                                        xmlValue,
                                        ReuseFactory.getInteger(BinaryOperatorNode.XMLEXISTS_OP),
                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="xmlPassingMechanism">xmlPassingMechanism</A>
 *
 * For now, we only support the BY VALUE option because,
 * at query time, we take the XML string value from disk and
 * pass it into Xalan, which creates a "copy" of the XML
 * value internally (as DOM/DTM) and then executes against
 * that.  Because Xalan creates this copy, this impl
 * is BY VALUE.
 *
 */
  final public void xmlPassingMechanism() throws ParseException, StandardException {
    if (getToken(3).kind == REF) {
      jj_consume_token(PASSING);
      jj_consume_token(BY);
      jj_consume_token(REF);
          // pass the XML value by reference
                {if (true) throw StandardException.newException(
                        SQLState.LANG_UNSUPPORTED_XML_FEATURE, "BY REF");}
    } else {
      switch (jj_nt.kind) {
      case PASSING:
        jj_consume_token(PASSING);
        jj_consume_token(BY);
        jj_consume_token(VALUE);
          // pass a 'copy' of the XML value.
                {if (true) return;}
        break;
      default:
        jj_la1[138] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/*
 * <A NAME="numericFunctionType">numericFunctionType</A>
 */
  final public DataTypeDescriptor numericFunctionType() throws ParseException, StandardException {
        DataTypeDescriptor dts;
    if (jj_2_29(1)) {
      dts = doubleType();
                {if (true) return dts;}
    } else {
      switch (jj_nt.kind) {
      case INT:
      case INTEGER:
      case SMALLINT:
      case LONGINT:
        dts = exactIntegerType();
                {if (true) return dts;}
        break;
      default:
        jj_la1[139] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dateTimeScalarFunction">dateTimeScalarFunction</A>
 */
  final public ValueNode dateTimeScalarFunction() throws ParseException, StandardException {
        ValueNode       value;
        ValueNode       timestampNode;
        int             field;
    switch (jj_nt.kind) {
    case TIME:
      jj_consume_token(TIME);
      jj_consume_token(LEFT_PAREN);
      value = additiveExpression(null,0, false);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.CAST_NODE,
                                                        value,
                                                        DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIME),
                                                        getContextManager());}
      break;
    case DATE:
      jj_consume_token(DATE);
      jj_consume_token(LEFT_PAREN);
      value = additiveExpression(null,0, false);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.UNARY_DATE_TIMESTAMP_OPERATOR_NODE,
                                                        value,
                                                        DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.DATE),
                                                        getContextManager());}
      break;
    case TIMESTAMP:
      jj_consume_token(TIMESTAMP);
      jj_consume_token(LEFT_PAREN);
      value = additiveExpression(null,0, false);
      timestampNode = timestampFunctionCompletion(value);
                {if (true) return timestampNode;}
      break;
    case HOUR:
    case MINUTE:
    case SECOND:
    case YEAR:
    case DAY:
    case MONTH:
      field = datetimeField();
      jj_consume_token(LEFT_PAREN);
      value = additiveExpression(null,0, false);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.EXTRACT_OPERATOR_NODE,
                                                                ReuseFactory.getInteger(field),
                                                                value,
                                                                getContextManager());}
      break;
    default:
      jj_la1[140] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="timestampFunctionCompletion">timestampFunctionCompletion</A>
 */
  final public ValueNode timestampFunctionCompletion(ValueNode firstArg) throws ParseException, StandardException {
        ValueNode timeValue;
    switch (jj_nt.kind) {
    case RIGHT_PAREN:
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.UNARY_DATE_TIMESTAMP_OPERATOR_NODE,
                                                        firstArg,
                                                        DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIMESTAMP),
                                                        getContextManager());}
      break;
    case COMMA:
      jj_consume_token(COMMA);
      timeValue = additiveExpression(null,0, false);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.TIMESTAMP_OPERATOR_NODE,
                                                        firstArg,
                                                        timeValue,
                                                        getContextManager());}
      break;
    default:
      jj_la1[141] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="booleanLiteral">booleanLiteral</A>
 */
  final public Token booleanLiteral() throws ParseException {
        Token tok;
    switch (jj_nt.kind) {
    case TRUE:
      tok = jj_consume_token(TRUE);
                {if (true) return tok;}
      break;
    case FALSE:
      tok = jj_consume_token(FALSE);
                {if (true) return tok;}
      break;
    default:
      jj_la1[142] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="generalValueSpecification">generalValueSpecification</A>
 */
  final public ValueNode generalValueSpecification() throws ParseException, StandardException {
                ValueNode       parm;
    switch (jj_nt.kind) {
    case QUESTION_MARK:
      parm = dynamicParameterSpecification();
                {if (true) return parm;}
      break;
    case CURRENT_USER:
    case SESSION_USER:
    case USER:
      parm = userNode();
                {if (true) return parm;}
      break;
    default:
      jj_la1[143] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ValueNode userNode() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case USER:
      jj_consume_token(USER);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.USER_NODE,
                                                                getContextManager());}
      break;
    case CURRENT_USER:
      jj_consume_token(CURRENT_USER);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.CURRENT_USER_NODE,
                                                getContextManager());}
      break;
    case SESSION_USER:
      jj_consume_token(SESSION_USER);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.SESSION_USER_NODE,
                                                getContextManager());}
      break;
    default:
      jj_la1[144] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="newInvocation">newInvocation</A>
 */
  final public JavaToSQLValueNode newInvocation() throws ParseException, StandardException {
        QueryTreeNode   newNode;
        Vector  parameterList = new Vector();
        String  javaClassName;
    jj_consume_token(NEW);
    javaClassName = javaClassName();
    methodCallParameterList(parameterList);
                if (!javaClassName.startsWith("org.apache.derby.diag.") && !javaClassName.startsWith("org.apache.derby.catalog.") && !javaClassName.startsWith("com.ibm.db2j."))
                {
                        checkInternalFeature(javaClassName);
                }
                newNode =  nodeFactory.getNode(C_NodeTypes.NEW_INVOCATION_NODE,
                                                                           javaClassName,
                                                                           parameterList,
                                                                           lastTokenDelimitedIdentifier,
                                                                           getContextManager());

                /*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
                {if (true) return (JavaToSQLValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                                newNode,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="staticMethodInvocation">staticMethodInvocation</A>
 */
  final public ValueNode staticMethodInvocation(String javaClassName) throws ParseException, StandardException {
        Vector  parameterList = new Vector();
        MethodCallNode  methodNode;
    methodNode = staticMethodName(javaClassName);
    methodCallParameterList(parameterList);
                methodNode.addParms(parameterList);

                /*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                                methodNode,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/**
 * <A NAME="methodCallParameterList">methodCallParameterList</A>
*/
  final public void methodCallParameterList(Vector parameterList) throws ParseException, StandardException {
    jj_consume_token(LEFT_PAREN);
    if (jj_2_30(1)) {
      methodParameter(parameterList);
      label_17:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[145] = jj_gen;
          break label_17;
        }
        jj_consume_token(COMMA);
        methodParameter(parameterList);
      }
    } else {
      ;
    }
    jj_consume_token(RIGHT_PAREN);
  }

/*
 * <A NAME="routineInvocation">routineInvocation</A>
 */
  final public ValueNode routineInvocation() throws ParseException, StandardException {
        Vector  parameterList = new Vector();
        TableName       routineName;
        MethodCallNode  methodNode;
    routineName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    methodCallParameterList(parameterList);
                methodNode = (MethodCallNode) nodeFactory.getNode(
                                                                C_NodeTypes.STATIC_METHOD_CALL_NODE,
                                                                routineName,
                                                                null,
                                                                getContextManager());

                methodNode.addParms(parameterList);

                /*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                                methodNode,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="javaClass">javaClass</A>
 */
  final public String javaClass() throws ParseException, StandardException {
        String javaClassName;
    javaClassName = javaClassName();
                {if (true) return javaClassName;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="columnMethodInvocation">columnMethodInvocation</A>
 */
  final public ValueNode columnMethodInvocation() throws ParseException, StandardException {
        ValueNode       columnReference;
        ValueNode       methodNode;
    columnReference = columnNameForInvocation();
    methodNode = nonStaticMethodInvocation(columnReference);
                {if (true) return methodNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="columnNameForInvocation">columnNameForInvocation</A>
 */
  final public ValueNode columnNameForInvocation() throws ParseException, StandardException {
        String firstName;
        String secondName = null;
        String thirdName = null;
        String          columnName = null;
        String          tableName = null;
        String          schemaName = null;
        TableName       tabName = null;
        ValueNode       retval;
    firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
    if (getToken(1).kind == PERIOD &&
                                            getToken(3).kind == PERIOD) {
      jj_consume_token(PERIOD);
      secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
      if (getToken(1).kind == PERIOD &&
                                                      getToken(3).kind == PERIOD) {
        jj_consume_token(PERIOD);
        thirdName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
      } else {
        ;
      }
    } else {
      ;
    }
                // Figure out what each identifier stands for
                if (thirdName == null)
                {
                        if (secondName == null)
                        {
                                // There's only one identifier, so it must be a column name
                                columnName = firstName;
                        }
                        else
                        {
                                // There are two identifiers, so they are table and column names
                                tableName = firstName;
                                columnName = secondName;
                        }
                }
                else
                {
                        // There are three identifiers,
                        // so they are schema, table, and column names
                        schemaName = firstName;
                        tableName = secondName;
                        columnName = thirdName;
                }

                if (tableName != null)
                {
                        // There is a table name, so get a TableName node
                        tabName =
                                (TableName) nodeFactory.getNode(
                                                        C_NodeTypes.TABLE_NAME,
                                                        schemaName,
                                                        tableName,
                                                        new Integer(nextToLastIdentifierToken.beginOffset),
                                                        new Integer(nextToLastIdentifierToken.endOffset),
                                                        getContextManager());
                }

                // Get the column reference
                retval = (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.COLUMN_REFERENCE,
                                                                        columnName,
                                                                        tabName,
                                                                        new Integer(lastIdentifierToken.beginOffset),
                                                                        new Integer(lastIdentifierToken.endOffset),
                                                                        getContextManager());

                {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="columnReference">columnReference</A>
 */
  final public ColumnReference columnReference() throws ParseException, StandardException {
        String          firstName;
        String          secondName = null;
        String          thirdName = null;
        String          columnName = null;
        String          tableName = null;
        String          schemaName = null;
        TableName       tabName = null;
    firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
    if (getToken(1).kind == PERIOD &&
                                            getToken(3).kind != LEFT_PAREN) {
      jj_consume_token(PERIOD);
      secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
      if (getToken(1).kind == PERIOD &&
                                                      getToken(3).kind != LEFT_PAREN) {
        jj_consume_token(PERIOD);
        thirdName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
      } else {
        ;
      }
    } else {
      ;
    }
                // Figure out what each name stands for
                if (thirdName == null)
                {
                        if (secondName == null)
                        {
                                // Only one name, must be column name
                                columnName = firstName;
                        }
                        else
                        {
                                // Two names: table.column
                                tableName = firstName;
                                columnName = secondName;
                        }
                }
                else
                {
                        // Three names: schema.table.column
                        schemaName = firstName;
                        tableName = secondName;
                        columnName = thirdName;
                }

                checkIdentifierLengthLimit(columnName, Limits.MAX_IDENTIFIER_LENGTH);
                if (schemaName != null)
                        checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);
                if (tableName != null)
                        checkIdentifierLengthLimit(tableName, Limits.MAX_IDENTIFIER_LENGTH);

                if (tableName != null)
                {
                        tabName = (TableName) nodeFactory.getNode(
                                                        C_NodeTypes.TABLE_NAME,
                                                        schemaName,
                                                        tableName,
                                                        new Integer(nextToLastIdentifierToken.beginOffset),
                                                        new Integer(nextToLastIdentifierToken.endOffset),
                                                        getContextManager());
                }

                {if (true) return (ColumnReference) nodeFactory.getNode(
                                                                C_NodeTypes.COLUMN_REFERENCE,
                                                                columnName,
                                                                tabName,
                                                                new Integer(lastIdentifierToken.beginOffset),
                                                                new Integer(lastIdentifierToken.endOffset),
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
void
columnReference() throws StandardException :
{}
{
	/*
	**
	** I re-wrote the above rule because it caused a grammar ambiguitity.
	** The problem is that we are parsing a dot-separated list of identifiers,
	** and the grammar doesn't know what the identifiers stand for, but the
	** syntax assumed that it did.  For example, in schema.table.column,
	** the grammar doesn't know when it parses the first identifier whether
	** it will be a catalog name, schema name, table name, or column name.
	**
	** I think this problem could be solved by increasing the lookahead.
	** I will try that solution next.  I like that solution better because,
	** if it works, it will be easier for the grammar to figure out what
	** each identifier stands for.
	**

	[ <MODULE> <PERIOD> <IDENTIFIER> |
	  [ [ [ <IDENTIFIER> <PERIOD> ] <IDENTIFIER> <PERIOD> ] <IDENTIFIER> <PERIOD> ]
	]
	<IDENTIFIER>
}
*/
  final public OrderByList orderByClause() throws ParseException, StandardException {
        OrderByList orderCols;
    jj_consume_token(ORDER);
    jj_consume_token(BY);
    orderCols = sortSpecificationList();
                {if (true) return orderCols;}
    throw new Error("Missing return statement in function");
  }

  final public int atIsolationLevel() throws ParseException, StandardException {
        int isolationLevel;
    jj_consume_token(WITH);
    isolationLevel = isolationLevelDB2Abbrev();
                {if (true) return isolationLevel;}
    throw new Error("Missing return statement in function");
  }

  final public OrderByList sortSpecificationList() throws ParseException, StandardException {
        OrderByList orderCols = (OrderByList) nodeFactory.getNode(
                                                                                        C_NodeTypes.ORDER_BY_LIST,
                                                                                        getContextManager());
    sortSpecification(orderCols);
    label_18:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[146] = jj_gen;
        break label_18;
      }
      jj_consume_token(COMMA);
      sortSpecification(orderCols);
    }
                {if (true) return orderCols;}
    throw new Error("Missing return statement in function");
  }

  final public void sortSpecification(OrderByList orderCols) throws ParseException, StandardException {
        OrderByColumn orderCol;
    orderCol = sortKey();
    switch (jj_nt.kind) {
    case ASC:
    case DESC:
      orderingSpecification(orderCol);
      break;
    default:
      jj_la1[147] = jj_gen;
      ;
    }
                orderCols.addOrderByColumn(orderCol);
  }

  final public OrderByColumn sortKey() throws ParseException, StandardException {
        ValueNode columnExpression;
    columnExpression = additiveExpression(null,0,true);
                {if (true) return (OrderByColumn) nodeFactory.getNode(
                                                                C_NodeTypes.ORDER_BY_COLUMN,
                                                                columnExpression,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public void orderingSpecification(OrderByColumn orderCol) throws ParseException {
    switch (jj_nt.kind) {
    case ASC:
      jj_consume_token(ASC);
      break;
    case DESC:
      jj_consume_token(DESC);
                orderCol.setDescending();
      break;
    default:
      jj_la1[148] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * <A NAME="forUpdateClause">forUpdateClause</A>
 */
  final public int forUpdateClause(Vector columnList) throws ParseException, StandardException {
        int     retval;
    switch (jj_nt.kind) {
    case UPDATE:
      jj_consume_token(UPDATE);
      switch (jj_nt.kind) {
      case OF:
        jj_consume_token(OF);
        forUpdateColumnList(columnList);
        break;
      default:
        jj_la1[149] = jj_gen;
        ;
      }
                {if (true) return CursorNode.UPDATE;}
      break;
    case READ:
      jj_consume_token(READ);
      jj_consume_token(ONLY);
                {if (true) return CursorNode.READ_ONLY;}
      break;
    case FETCH:
      jj_consume_token(FETCH);
      jj_consume_token(ONLY);
                {if (true) return CursorNode.READ_ONLY;}
      break;
    default:
      jj_la1[150] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="forUpdateColumnList">forUpdateColumnList</A>
 */
  final public void forUpdateColumnList(Vector columnList) throws ParseException, StandardException {
    forUpdateColumn(columnList);
    label_19:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[151] = jj_gen;
        break label_19;
      }
      jj_consume_token(COMMA);
      forUpdateColumn(columnList);
    }
  }

/*
 * <A NAME="forUpdateColumn">forUpdateColumn</A>
 */
  final public void forUpdateColumn(Vector columnList) throws ParseException, StandardException {
        String           columnName;
    /* identifier() used to be columnName() */
            columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                columnList.addElement(columnName);
  }

/*
 * <A NAME="setClauseList">setClauseList</A>
 */
  final public ResultColumnList setClauseList() throws ParseException, StandardException {
        ResultColumnList        columnList = (ResultColumnList) nodeFactory.getNode(
                                                                                                C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                                getContextManager());
    setClause(columnList);
    label_20:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[152] = jj_gen;
        break label_20;
      }
      jj_consume_token(COMMA);
      setClause(columnList);
    }
                {if (true) return columnList;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="setClause">setClause</A>
 */
  final public void setClause(ResultColumnList columnList) throws ParseException, StandardException {
        ResultColumn resultColumn;
        ColumnReference  columnName;
        ValueNode        valueNode;
    /* identifier() used to be objectColumn() */
            /*
    		SQL92 only wants identifiers here (column names)
    		but JBuilder expects table.column, so we allow the
    		general form.
    	 */
            columnName = columnReference();
    jj_consume_token(EQUALS_OPERATOR);
    valueNode = updateSource(columnName.getColumnName());
                resultColumn = (ResultColumn) nodeFactory.getNode(
                                                                                C_NodeTypes.RESULT_COLUMN,
                                                                                columnName,
                                                                                valueNode,
                                                                                getContextManager());
                columnList.addResultColumn(resultColumn);
  }

/*
 * <A NAME="updateSource">updateSource</A>
 */
  final public ValueNode updateSource(String columnName) throws ParseException, StandardException {
        ValueNode       valueNode;
    if (jj_2_31(1)) {
      valueNode = additiveExpression(null,0, false);
                {if (true) return valueNode;}
    } else {
      switch (jj_nt.kind) {
      case NULL:
        valueNode = nullSpecification();
                {if (true) return valueNode;}
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.DEFAULT_NODE,
                                                                columnName,
                                                                getContextManager());}
        break;
      default:
        jj_la1[153] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="nullSpecification">nullSpecification</A>
 */
  final public ValueNode nullSpecification() throws ParseException, StandardException {
    jj_consume_token(NULL);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="insertColumnsAndSource">insertColumnsAndSource</A>
 */
  final public QueryTreeNode insertColumnsAndSource(QueryTreeNode targetTable) throws ParseException, StandardException {
        Properties                      targetProperties = null;
        ResultSetNode   queryExpression;
        ResultColumnList        columnList = null;
    if (getToken(1).kind == LEFT_PAREN && ! subqueryFollows()) {
      jj_consume_token(LEFT_PAREN);
      columnList = insertColumnList();
      jj_consume_token(RIGHT_PAREN);
    } else {
      ;
    }
    switch (jj_nt.kind) {
    case PROPERTIES:
      targetProperties = propertyList();
      break;
    default:
      jj_la1[154] = jj_gen;
      ;
    }
    queryExpression = queryExpression(null, NO_SET_OP);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                        C_NodeTypes.INSERT_NODE,
                                                        targetTable,
                                                        columnList,
                                                        queryExpression,
                                                        targetProperties,
                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="insertColumnList">insertColumnList</A>
 */
  final public ResultColumnList insertColumnList() throws ParseException, StandardException {
        ResultColumnList        columnList = (ResultColumnList) nodeFactory.getNode(
                                                                                                C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                                getContextManager());
    columnQualifiedNameList(columnList);
                {if (true) return columnList;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="columnQualifiedNameList">columnQualifiedNameList</A>
 */
  final public void columnQualifiedNameList(ResultColumnList columnList) throws ParseException, StandardException {
    columnQualifiedNameItem(columnList);
    label_21:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[155] = jj_gen;
        break label_21;
      }
      jj_consume_token(COMMA);
      columnQualifiedNameItem(columnList);
    }
  }

/*
 * <A NAME="columnQualifiedNameItem">columnQualifiedNameItem</A>
 */
  final public void columnQualifiedNameItem(ResultColumnList columnList) throws ParseException, StandardException {
        ColumnReference         columnRef;
        ResultColumn    resultColumn;
    /*
    		SQL92 only wants identifiers here (column names)
    		but JBuilder expects table.column, so we allow the
    		general form.
    	 */
            columnRef = columnReference();
                /*
		** Store the column names for the result columns in the
		** result column list.  We don't know yet what valueNodes
		** should be hooked up to each result column, so set that
		** to null for now.
		*/
                resultColumn = (ResultColumn) nodeFactory.getNode(
                                                                                C_NodeTypes.RESULT_COLUMN,
                                                                                columnRef,
                                                                                null,
                                                                                getContextManager());
                columnList.addResultColumn(resultColumn);
  }

/*
 * <A NAME="rowValueConstructor">rowValueConstructor</A>
 */
  final public ResultSetNode rowValueConstructor(ResultSetNode leftRSN) throws ParseException, StandardException {
        ResultColumnList        resultColumns = (ResultColumnList) nodeFactory.getNode(
                                                                                                C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                                getContextManager());
        ResultSetNode           newRSN;
    if (rowValueConstructorListFollows()) {
      jj_consume_token(LEFT_PAREN);
      rowValueConstructorList(resultColumns);
      jj_consume_token(RIGHT_PAREN);
                /* If leftRSN is null, simply return the newRSN, else generate and
		 * return a UNION ALL above the 2 RSNs, after verifying that the size()
		 * of both RSNs RCLs is the same.
		 */
                newRSN = (ResultSetNode) nodeFactory.getNode(
                                                                C_NodeTypes.ROW_RESULT_SET_NODE,
                                                                resultColumns,
                                                                null,
                                                                getContextManager());
                if (leftRSN != null)
                {
                        if (leftRSN.getResultColumns().size() !=
                                newRSN.getResultColumns().size())
                        {
                                {if (true) throw StandardException.newException(SQLState.LANG_ROW_VALUE_CONSTRUCTOR_UNMATCHED_COLUMNS);}
                        }

                        newRSN = (ResultSetNode) nodeFactory.getNode(
                                                                        C_NodeTypes.UNION_NODE,
                                                                        leftRSN,
                                                                        newRSN,
                                                                        Boolean.TRUE,
                                                                        Boolean.TRUE,
                                                                        null,
                                                                        getContextManager());
                }
                {if (true) return newRSN;}
    } else {
      rowValueConstructorElement(resultColumns);
                /* If leftRSN is null, simply return the newRSN, else generate and
		 * return a UNION ALL above the 2 RSNs, after verifying that the size()
		 * of both RSNs RCLs is the same.
		 */
                newRSN = (ResultSetNode) nodeFactory.getNode(
                                                                C_NodeTypes.ROW_RESULT_SET_NODE,
                                                                resultColumns,
                                                                null,
                                                                getContextManager());
                if (leftRSN != null)
                {
                        if (leftRSN.getResultColumns().size() !=
                                newRSN.getResultColumns().size())
                        {
                                {if (true) throw StandardException.newException(SQLState.LANG_ROW_VALUE_CONSTRUCTOR_UNMATCHED_COLUMNS);}
                        }

                        newRSN = (ResultSetNode) nodeFactory.getNode(
                                                                        C_NodeTypes.UNION_NODE,
                                                                        leftRSN,
                                                                        newRSN,
                                                                        Boolean.TRUE,
                                                                        Boolean.TRUE,
                                                                        null,
                                                                        getContextManager());
                }
                {if (true) return newRSN;}
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="rowValueConstructorElement">rowValueConstructorElement</A>
 */
  final public void rowValueConstructorElement(ResultColumnList resultColumns) throws ParseException, StandardException {
        ValueNode       value;
    if (jj_2_32(1)) {
      value = additiveExpression(null, 0, true);
                resultColumns.addResultColumn(
                        (ResultColumn) nodeFactory.getNode(
                                                        C_NodeTypes.RESULT_COLUMN,
                                                        null,
                                                        value,
                                                        getContextManager())
                                );
    } else {
      switch (jj_nt.kind) {
      case NULL:
        value = nullSpecification();
                resultColumns.addResultColumn(
                        (ResultColumn) nodeFactory.getNode(
                                                        C_NodeTypes.RESULT_COLUMN,
                                                        null,
                                                        value,
                                                        getContextManager())
                                );
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
                resultColumns.addResultColumn(
                        (ResultColumn) nodeFactory.getNode(
                                                        C_NodeTypes.RESULT_COLUMN,
                                                        null,
                                                        (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.DEFAULT_NODE,
                                                                null,
                                                                getContextManager()),
                                                        getContextManager())
                                );
        break;
      default:
        jj_la1[156] = jj_gen;
                {if (true) throw StandardException.newException(SQLState.LANG_EMPTY_VALUES_CLAUSE);}
      }
    }
  }

/*
 * <A NAME="rowValueConstructorList">rowValueConstructorList</A>
 */
  final public void rowValueConstructorList(ResultColumnList resultColumns) throws ParseException, StandardException {
    rowValueConstructorElement(resultColumns);
    label_22:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[157] = jj_gen;
        break label_22;
      }
      jj_consume_token(COMMA);
      rowValueConstructorElement(resultColumns);
    }
  }

/*
 * <A NAME="tableSubquery">tableSubquery</A>
 */
  final public SubqueryNode tableSubquery(int subqueryType, ValueNode leftOperand) throws ParseException, StandardException {
        SubqueryNode    subqueryNode;
    subqueryNode = subquery(subqueryType, leftOperand);
                {if (true) return subqueryNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="subquery">subquery</A>
 */
  final public SubqueryNode subquery(int subqueryType, ValueNode leftOperand) throws ParseException, StandardException {
        ResultSetNode   queryExpression;
        SubqueryNode    subqueryNode;
    queryExpression = queryExpression(null, NO_SET_OP);
                subqueryNode = (SubqueryNode) nodeFactory.getNode(
                                                                                C_NodeTypes.SUBQUERY_NODE,
                                                                                queryExpression,
                                                                                ReuseFactory.getInteger(subqueryType),
                                                                                leftOperand,
                                                                                getContextManager());
                {if (true) return subqueryNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="inPredicateValue">inPredicateValue</A>
 */
  final public ValueNode inPredicateValue(ValueNode leftOperand) throws ParseException, StandardException {
        ValueNode               retval;
        int                             tokKind;
    jj_consume_token(LEFT_PAREN);
    if (subqueryFollows()) {
      retval = tableSubquery(SubqueryNode.IN_SUBQUERY, leftOperand);
    } else if (jj_2_33(1)) {
      retval = inValueList(leftOperand);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RIGHT_PAREN);
                {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="inValueList">inValueList</A>
 */
  final public ValueNode inValueList(ValueNode leftOperand) throws ParseException, StandardException {
        ValueNodeList   inList = (ValueNodeList) nodeFactory.getNode(
                                                                                        C_NodeTypes.VALUE_NODE_LIST,
                                                                                        getContextManager());
    inElement(inList);
    label_23:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[158] = jj_gen;
        break label_23;
      }
      jj_consume_token(COMMA);
      inElement(inList);
    }
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.IN_LIST_OPERATOR_NODE,
                                                                leftOperand,
                                                                inList,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="inElement">inElement</A>
 */
  final public void inElement(ValueNodeList inList) throws ParseException, StandardException {
        ValueNode valueNode;
    valueNode = additiveExpression(null, 0, false);
                inList.addElement(valueNode);
  }

/*
 * <A NAME="quantifier">quantifier</A>
 */
  final public int quantifier(int opType) throws ParseException, StandardException {
        int retval = 0;
    switch (jj_nt.kind) {
    case ALL:
      jj_consume_token(ALL);
                switch (opType)
                {
                        case BinaryOperatorNode.EQ:
                                retval = SubqueryNode.EQ_ALL_SUBQUERY;
                                break;

                        case BinaryOperatorNode.NE:
                                retval = SubqueryNode.NE_ALL_SUBQUERY;
                                break;

                        case BinaryOperatorNode.LE:
                                retval = SubqueryNode.LE_ALL_SUBQUERY;
                                break;

                        case BinaryOperatorNode.LT:
                                retval = SubqueryNode.LT_ALL_SUBQUERY;
                                break;

                        case BinaryOperatorNode.GE:
                                retval = SubqueryNode.GE_ALL_SUBQUERY;
                                break;

                        case BinaryOperatorNode.GT:
                                retval = SubqueryNode.GT_ALL_SUBQUERY;
                                break;

                        default:
                                if (SanityManager.DEBUG)
                                SanityManager.THROWASSERT(
                                                "Invalid value for opType (" + opType +
                                                ") passed to quantifier()");
                }
                {if (true) return retval;}
      break;
    case ANY:
    case SOME:
      some();
                switch (opType)
                {
                        case BinaryOperatorNode.EQ:
                                retval = SubqueryNode.EQ_ANY_SUBQUERY;
                                break;

                        case BinaryOperatorNode.NE:
                                retval = SubqueryNode.NE_ANY_SUBQUERY;
                                break;

                        case BinaryOperatorNode.LE:
                                retval = SubqueryNode.LE_ANY_SUBQUERY;
                                break;

                        case BinaryOperatorNode.LT:
                                retval = SubqueryNode.LT_ANY_SUBQUERY;
                                break;

                        case BinaryOperatorNode.GE:
                                retval = SubqueryNode.GE_ANY_SUBQUERY;
                                break;

                        case BinaryOperatorNode.GT:
                                retval = SubqueryNode.GT_ANY_SUBQUERY;
                                break;

                        default:
                                if (SanityManager.DEBUG)
                                SanityManager.THROWASSERT(
                                                "Invalid value for opType (" + opType +
                                                ") passed to quantifier()");
                }
                {if (true) return retval;}
      break;
    default:
      jj_la1[159] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="some">some</A>
 */
  final public void some() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case SOME:
      jj_consume_token(SOME);
      break;
    case ANY:
      jj_consume_token(ANY);
      break;
    default:
      jj_la1[160] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * <A NAME="existsExpression">existsExpression</A>
 */
  final public SubqueryNode existsExpression() throws ParseException, StandardException {
        SubqueryNode    subqueryNode;
    jj_consume_token(EXISTS);
    jj_consume_token(LEFT_PAREN);
    subqueryNode = tableSubquery(SubqueryNode.EXISTS_SUBQUERY, null);
    jj_consume_token(RIGHT_PAREN);
                {if (true) return subqueryNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="tableExpression">tableExpression</A>
 */
  final public SelectNode tableExpression(ResultColumnList selectList) throws ParseException, StandardException {
        SelectNode      selectNode;
        FromList        fromList;
        ValueNode       whereClause = null;
        GroupByList     groupByList = null;
        ValueNode       havingClause = null;
        Token           whereToken;
    fromList = fromClause();
    switch (jj_nt.kind) {
    case WHERE:
      whereToken = jj_consume_token(WHERE);
      whereClause = whereClause(whereToken);
      break;
    default:
      jj_la1[161] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case GROUP:
      groupByList = groupByClause();
      break;
    default:
      jj_la1[162] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case HAVING:
      havingClause = havingClause();
      break;
    default:
      jj_la1[163] = jj_gen;
      ;
    }
                selectNode = (SelectNode) nodeFactory.getNode(
                                                        C_NodeTypes.SELECT_NODE,
                                                        selectList,
                                                        null,           /* AGGREGATE list */
                                                        fromList,
                                                        whereClause,
                                                        groupByList,
                                                        getContextManager());

                /* A SELECT with a GROUP BY or HAVING clause is the one instance where the
		 * parser will generate a tree that does not exactly match the query.
		 * The resulting tree is an outer SelectNode with the HAVING clause
		 * as its WHERE clause and a FromList containing a single FromSubquery -
		 * the user SELECT, minus the HAVING clause.
		 * The outer SELECT gets a SELECT *.
		 * The FromSubquery will have a null name, something that the user cannot do,
		 * to enable the binding of any correlated columns in the HAVING clause.
		 */
                if (groupByList != null || havingClause != null)
                {
                        FromSubquery            fromSubquery;
                        ResultColumnList        outerRCL =
                                                                                (ResultColumnList) nodeFactory.getNode(
                                                                                                C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                                getContextManager());

                        /* Wrap the user SELECT in a FromSubquery */
                        fromList = (FromList) nodeFactory.getNode(
                                                                        C_NodeTypes.FROM_LIST,
                                                                        getNodeFactory().doJoinOrderOptimization(),
                                                                        getContextManager());
                        fromSubquery = (FromSubquery) nodeFactory.getNode(
                                                                                                        C_NodeTypes.FROM_SUBQUERY,
                                                                                                        selectNode,
                                                                                                        null,
                                                                                                        null,
                                                                                                        null,
                                                                                                        getContextManager());
                        fromList.addElement(fromSubquery);

                        /* Pull any aggregates out of the HAVING clause and append them to 
			 * SELECT list in the user's select, replacing the aggregates in
			 * the HAVING clause with ColumnReferences to the aggregate.
			 * Do NOT replace anything below a ResultSetNode.  This means that
			 * we'll replace
			 * 		FROM x HAVING max(x.x) > 2
			 * but not
			 *		FROM x HAVING x.x = (select max(y.y) from y)
			 * Aggregates under a SELECT are all fixed up correctly
			 * later, but here we need to get the aggregates that
			 * aren't under result sets.
			 *
			 * Appended ResultColumns marked as generated so the wrapper
			 * select won't see them when the * is expanded.
			 *
			 * RESOLVE - someday we should try to find matching aggregates
			 * instead of just adding them.
             *
             * NOTE: This rewriting of the query tree makes the handling of an ORDER BY
             * clause difficult. See OrderByColumn.pullUpOrderByColumn. It makes specific
             * assumptions about the structure of the generated query tree. Do not make
             * any changes to this transformation without carefully considering the
             * OrderByColumn pullUpOrderByColumn and bindOrderByColumn methods.
			 */
                        if (havingClause != null)
                        {
                                ReplaceAggregatesWithCRVisitor visitor =
                                        new ReplaceAggregatesWithCRVisitor(selectList, ResultSetNode.class);
                                havingClause = (ValueNode)havingClause.accept(visitor);

                                // fix for HAVING without GROUP BY, makes sure we get one
                                // aggregate operator by adding a count(*), this fixes beetle 5853, 5890
                                if (groupByList == null) {
                                        ValueNode vn = (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.AGGREGATE_NODE,
                                                                null,
                                                                org.apache.derby.impl.sql.compile.CountAggregateDefinition.class,
                                                                Boolean.FALSE, // distinct Boolean.TRUE?
                                                                "COUNT(*)",
                                                                getContextManager());
                                        AggregateNode n = (AggregateNode) vn;
                                        n.replaceAggregatesWithColumnReferences(selectList, 0);
                                }
                        }

                        outerRCL.addResultColumn((ResultColumn) nodeFactory.getNode(
                                                                                                C_NodeTypes.ALL_RESULT_COLUMN,
                                                                                                null,
                                                                                                getContextManager()));
                        // wrap another selectNode on the outside of the subquery
                        selectNode = (SelectNode) nodeFactory.getNode(
                                                                                C_NodeTypes.SELECT_NODE,
                                                                                outerRCL,       /* SELECT * from user SELECT */
                                                                                null,           /* AGGREGATE list */
                                                                                fromList,
                                                                                havingClause,
                                                                                null,           /* GROUP BY list */
                                                                                getContextManager());

                        /* Mark the wrapping FromSubquery and SelectNode as appropriate */
                        if (groupByList != null)
                        {
                                fromSubquery.markAsForGroupByClause();
                                selectNode.markAsForGroupByClause();
                        }
                        if (havingClause != null)
                        {
                                fromSubquery.markAsForHavingClause();
                                selectNode.markAsForHavingClause();
                        }
                }
                {if (true) return selectNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="fromClause">fromClause</A>
 */
  final public FromList fromClause() throws ParseException, StandardException {
        FromList fromList = (FromList) nodeFactory.getNode(
                                                                        C_NodeTypes.FROM_LIST,
                                                                        getNodeFactory().doJoinOrderOptimization(),
                                                                        getContextManager());
        int     tokKind;
        Token   beginToken;
        Token   endToken;
    jj_consume_token(FROM);
                beginToken = getToken(1);
    if (propertyListFollows()) {
      fromListProperties(fromList);
    } else {
      ;
    }
    dummyTableReferenceRule(fromList);
    label_24:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[164] = jj_gen;
        break label_24;
      }
      jj_consume_token(COMMA);
      dummyTableReferenceRule(fromList);
    }
                                                                         endToken = getToken(0);
                fromList.setBeginOffset( beginToken.beginOffset);
                fromList.setEndOffset( endToken.endOffset);
                {if (true) return fromList;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="fromListProperties">fromListProperties</A>
 */
  final public void fromListProperties(FromList fromList) throws ParseException, StandardException {
        Properties properties;
    properties = propertyList();
                fromList.setProperties(properties);
  }

/* This rule created simply as a way to add the result of tableReference()
 * to the fromList.
 */
  final public void dummyTableReferenceRule(FromList fromList) throws ParseException, StandardException {
        FromTable tableReference;
    switch (jj_nt.kind) {
    case TABLE:
      jj_consume_token(TABLE);
      if (getToken(1).kind == LEFT_PAREN &&
                                      (
                                              getToken(2).kind == SELECT ||
                                              getToken(2).kind == VALUES
                                      )) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      tableReference = tableReferenceTypes(false);
                fromList.addFromTable(tableReference);
      break;
    default:
      jj_la1[165] = jj_gen;
      if (jj_2_34(1)) {
        tableReference = tableReferenceTypes(false);
                fromList.addFromTable(tableReference);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public FromTable tableReferenceTypes(boolean nestedInParens) throws ParseException, StandardException {
        FromTable tableReference;
    if (jj_2_35(1)) {
      tableReference = tableReference(nestedInParens);
                {if (true) return tableReference ;}
    } else {
      switch (jj_nt.kind) {
      case LEFT_BRACE:
        jj_consume_token(LEFT_BRACE);
        jj_consume_token(OJ);
        tableReference = tableReference(nestedInParens);
        jj_consume_token(RIGHT_BRACE);
                {if (true) return tableReference;}
        break;
      default:
        jj_la1[166] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Object[] optionalTableClauses() throws ParseException, StandardException {
        Object[]                         otc = null;
        Properties                      tableProperties = null;
        ResultColumnList        derivedRCL = null;
        String                          correlationName = null;
    if (propertyListFollows()) {
      otc = optionalTableProperties();
                otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;
                otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;
                {if (true) return otc;}
    } else {
      switch (jj_nt.kind) {
      case AS:
      case BINARY:
      case COALESCE:
      case D:
      case MODULE:
      case T:
      case TS:
      case VALUE:
      case VARBINARY:
      case ABS:
      case ABSVAL:
      case ACTION:
      case ALWAYS:
      case BLOB:
      case C:
      case CALLED:
      case CLOB:
      case COBOL:
      case COMMITTED:
      case CONCAT:
      case CONTAINS:
      case DATA:
      case DATE:
      case DAY:
      case DYNAMIC:
      case FORTRAN:
      case GENERATED:
      case IDENTITY_VAL_LOCAL:
      case INCREMENT:
      case INITIAL:
      case INTERVAL:
      case LANGUAGE:
      case LARGE:
      case LENGTH:
      case LEVEL:
      case LOCKS:
      case LOCKSIZE:
      case LOGGED:
      case MOD:
      case MODIFIES:
      case MODIFY:
      case MONTH:
      case _MORE:
      case MUMPS:
      case NAME:
      case NCLOB:
      case NULLABLE:
      case NUMBER:
      case OBJECT:
      case PASCAL:
      case PLI:
      case PRECISION:
      case RELEASE:
      case REPEATABLE:
      case RETURNS:
      case ROW:
      case SAVEPOINT:
      case SCALE:
      case SERIALIZABLE:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_HOUR:
      case SQL_TSI_DAY:
      case SQL_TSI_WEEK:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case START:
      case STATEMENT:
      case SYNONYM:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TRUNCATE:
      case TYPE:
      case UNCOMMITTED:
      case USAGE:
      case WHEN:
      case CURDATE:
      case CURTIME:
      case DATABASE:
      case LONG:
      case AFTER:
      case BEFORE:
      case CLASS:
      case COMPRESS:
      case CONTENT:
      case CS:
      case DB2SQL:
      case DIRTY:
      case DOCUMENT:
      case EACH:
      case EXCLUSIVE:
      case FN:
      case INDEX:
      case JAVA:
      case LCASE:
      case LOCATE:
      case LOCK:
      case MESSAGE_LOCALE:
      case METHOD:
      case MODE:
      case NEW:
      case NEW_TABLE:
      case OJ:
      case OFF:
      case OLD:
      case OLD_TABLE:
      case PARAMETER:
      case PASSING:
      case PROPERTIES:
      case READS:
      case REF:
      case REFERENCING:
      case RENAME:
      case RESET:
      case RESULT:
      case RETAIN:
      case RR:
      case RS:
      case SEQUENTIAL:
      case SETS:
      case SHARE:
      case SQLID:
      case SPECIFIC:
      case SQRT:
      case STABILITY:
      case STRIP:
      case STYLE:
      case TRIGGER:
      case UCASE:
      case UR:
      case WHITESPACE:
      case IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        switch (jj_nt.kind) {
        case AS:
          jj_consume_token(AS);
          break;
        default:
          jj_la1[167] = jj_gen;
          ;
        }
        correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
        switch (jj_nt.kind) {
        case LEFT_PAREN:
          jj_consume_token(LEFT_PAREN);
          derivedRCL = derivedColumnList();
          jj_consume_token(RIGHT_PAREN);
          break;
        default:
          jj_la1[168] = jj_gen;
          ;
        }
        switch (jj_nt.kind) {
        case PROPERTIES:
          tableProperties = propertyList();
          break;
        default:
          jj_la1[169] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[170] = jj_gen;
        ;
      }
                otc = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];
                otc[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] = tableProperties;
                otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;
                otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;
                {if (true) return otc;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Object[] optionalTableProperties() throws ParseException, StandardException {
        Object[]                        otc = null;
        Properties                      tableProperties = null;
    tableProperties = propertyList();
                otc = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];
                otc[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] = tableProperties;
                {if (true) return otc;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="tableReference">tableReference</A>
 */
  final public FromTable tableReference(boolean nestedInParens) throws ParseException, StandardException {
        JavaToSQLValueNode      javaToSQLNode = null;
        TableName                       tableName;
        String                          correlationName = null;
        ResultColumnList        derivedRCL = null;
        FromTable                       fromTable;
        TableOperatorNode       joinTable = null;
        FromTable                       tableReference;
        Object[]                        optionalTableClauses = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];
        Properties                      tableProperties = null;
        ResultSetNode           derivedTable;
    if (newInvocationFollows(1)) {
      javaToSQLNode = newInvocation();
      switch (jj_nt.kind) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[171] = jj_gen;
        ;
      }
      correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
      switch (jj_nt.kind) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        derivedRCL = derivedColumnList();
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[172] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case PROPERTIES:
        optionalTableClauses = optionalTableProperties();
        break;
      default:
        jj_la1[173] = jj_gen;
        ;
      }
      label_25:
      while (true) {
        if (joinedTableExpressionFollows()) {
          ;
        } else {
          break label_25;
        }
        joinTable = joinedTableExpression((joinTable != null) ?
                                                                                        joinTable :
                                                                                        (FromTable) nodeFactory.getNode(
                                                                                                C_NodeTypes.FROM_VTI,
                                                                                                javaToSQLNode.getJavaValueNode(),
                                                                                                correlationName,
                                                                                                derivedRCL,
                                                                                                ((optionalTableClauses != null) ?
                                                                                                        (Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :
                                                                                                        (Properties) null),
                                                                                                getContextManager()),
                                                                                nestedInParens);
      }
                /* Build a derived table if not a join expression */
                if (joinTable == null)
                {
                        fromTable = (FromTable) nodeFactory.getNode(
                                                                C_NodeTypes.FROM_VTI,
                                                                javaToSQLNode.getJavaValueNode(),
                                                                correlationName,
                                                                derivedRCL,
                                                                ((optionalTableClauses != null) ?
                                                                        (Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :
                                                                        (Properties) null),
                                                                getContextManager());
                }
                else
                {
                        fromTable = joinTable;
                }

                {if (true) return fromTable;}
    } else {
      switch (jj_nt.kind) {
      case BINARY:
      case COALESCE:
      case D:
      case MODULE:
      case T:
      case TS:
      case VALUE:
      case VARBINARY:
      case ABS:
      case ABSVAL:
      case ACTION:
      case ALWAYS:
      case BLOB:
      case C:
      case CALLED:
      case CLOB:
      case COBOL:
      case COMMITTED:
      case CONCAT:
      case CONTAINS:
      case DATA:
      case DATE:
      case DAY:
      case DYNAMIC:
      case FORTRAN:
      case GENERATED:
      case IDENTITY_VAL_LOCAL:
      case INCREMENT:
      case INITIAL:
      case INTERVAL:
      case LANGUAGE:
      case LARGE:
      case LENGTH:
      case LEVEL:
      case LOCKS:
      case LOCKSIZE:
      case LOGGED:
      case MOD:
      case MODIFIES:
      case MODIFY:
      case MONTH:
      case _MORE:
      case MUMPS:
      case NAME:
      case NCLOB:
      case NULLABLE:
      case NUMBER:
      case OBJECT:
      case PASCAL:
      case PLI:
      case PRECISION:
      case RELEASE:
      case REPEATABLE:
      case RETURNS:
      case ROW:
      case SAVEPOINT:
      case SCALE:
      case SERIALIZABLE:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_HOUR:
      case SQL_TSI_DAY:
      case SQL_TSI_WEEK:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case START:
      case STATEMENT:
      case SYNONYM:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TRUNCATE:
      case TYPE:
      case UNCOMMITTED:
      case USAGE:
      case WHEN:
      case CURDATE:
      case CURTIME:
      case DATABASE:
      case LONG:
      case AFTER:
      case BEFORE:
      case CLASS:
      case COMPRESS:
      case CONTENT:
      case CS:
      case DB2SQL:
      case DIRTY:
      case DOCUMENT:
      case EACH:
      case EXCLUSIVE:
      case FN:
      case INDEX:
      case JAVA:
      case LCASE:
      case LOCATE:
      case LOCK:
      case MESSAGE_LOCALE:
      case METHOD:
      case MODE:
      case NEW:
      case NEW_TABLE:
      case OJ:
      case OFF:
      case OLD:
      case OLD_TABLE:
      case PARAMETER:
      case PASSING:
      case PROPERTIES:
      case READS:
      case REF:
      case REFERENCING:
      case RENAME:
      case RESET:
      case RESULT:
      case RETAIN:
      case RR:
      case RS:
      case SEQUENTIAL:
      case SETS:
      case SHARE:
      case SQLID:
      case SPECIFIC:
      case SQRT:
      case STABILITY:
      case STRIP:
      case STYLE:
      case TRIGGER:
      case UCASE:
      case UR:
      case WHITESPACE:
      case IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        /* identifier() used to be correlationName() */
                tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        optionalTableClauses = optionalTableClauses();
        label_26:
        while (true) {
          if (joinedTableExpressionFollows()) {
            ;
          } else {
            break label_26;
          }
          joinTable = joinedTableExpression((joinTable != null) ?
                                                                                          joinTable :
                                                                                          (FromTable) nodeFactory.getNode(
                                                                                                          C_NodeTypes.FROM_BASE_TABLE,
                                                                                                          tableName,
                                                                                                          (String) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME],
                                                                                                          (ResultColumnList) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL],
                                                                                                          (Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES],
                                                                                                          getContextManager()),
                                                                                  nestedInParens);
        }
                /* Build a from table if not a join expression */
                if (joinTable == null)
                {
                        fromTable = (FromTable) nodeFactory.getNode(
                                                                                        C_NodeTypes.FROM_BASE_TABLE,
                                                                                        tableName,
                                                                                                (String) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME],
                                                                                                (ResultColumnList) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL],
                                                                                                (Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES],
                                                                                        getContextManager());
                }
                else
                {
                        fromTable = joinTable;
                }
                {if (true) return fromTable;}
        break;
      default:
        jj_la1[177] = jj_gen;
        if (getToken(1).kind == LEFT_PAREN &&
                                        (
                                                getToken(2).kind == SELECT ||
                                                getToken(2).kind == VALUES
                                        )) {
          derivedTable = derivedTable();
          switch (jj_nt.kind) {
          case AS:
            jj_consume_token(AS);
            break;
          default:
            jj_la1[174] = jj_gen;
            ;
          }
          correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
          switch (jj_nt.kind) {
          case LEFT_PAREN:
            jj_consume_token(LEFT_PAREN);
            derivedRCL = derivedColumnList();
            jj_consume_token(RIGHT_PAREN);
            break;
          default:
            jj_la1[175] = jj_gen;
            ;
          }
          switch (jj_nt.kind) {
          case PROPERTIES:
            optionalTableClauses = optionalTableProperties();
            break;
          default:
            jj_la1[176] = jj_gen;
            ;
          }
          label_27:
          while (true) {
            if (joinedTableExpressionFollows()) {
              ;
            } else {
              break label_27;
            }
            joinTable = joinedTableExpression((joinTable != null) ?
                                                                                            joinTable :
                                                                                            (FromTable) nodeFactory.getNode(
                                                                                                                    C_NodeTypes.FROM_SUBQUERY,
                                                                                                                    derivedTable,
                                                                                                                    correlationName,
                                                                                                                    derivedRCL,
                                                                                                                    ((optionalTableClauses != null) ?
                                                                                                                            (Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :
                                                                                                                            (Properties) null),
                                                                                                                    getContextManager()),
                                                                                    nestedInParens);
          }
                /* Build a derived table if not a join expression */
                if (joinTable == null)
                {
                        fromTable = (FromTable) nodeFactory.getNode(
                                                                                        C_NodeTypes.FROM_SUBQUERY,
                                                                                        derivedTable,
                                                                                        correlationName,
                                                                                        derivedRCL,
                                                                                        ((optionalTableClauses != null) ?
                                                                                                (Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :
                                                                                                (Properties) null),
                                                                                        getContextManager());
                }
                else
                {
                        fromTable = joinTable;
                }

                {if (true) return fromTable;}
        } else {
          switch (jj_nt.kind) {
          case LEFT_PAREN:
            jj_consume_token(LEFT_PAREN);
            tableReference = tableReferenceTypes(true);
            jj_consume_token(RIGHT_PAREN);
            label_28:
            while (true) {
              if (joinedTableExpressionFollows()) {
                ;
              } else {
                break label_28;
              }
              joinTable = joinedTableExpression((joinTable != null) ?
                                                                                              joinTable :
                                                                                              tableReference,
                                                                                      nestedInParens);
            }
                if (joinTable == null)
                {
                        fromTable = tableReference;
                }
                else
                {
                        fromTable = joinTable;
                }

                {if (true) return fromTable;}
            break;
          default:
            jj_la1[178] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="derivedColumnList">derivedColumnList</A>
 */
  final public ResultColumnList derivedColumnList() throws ParseException, StandardException {
        ResultColumnList        resultColumns =
                                                                        (ResultColumnList) nodeFactory.getNode(
                                                                                        C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                        getContextManager());
    columnNameList(resultColumns);
                {if (true) return resultColumns;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="columnNameList">columnNameList</A>
 */
  final public void columnNameList(ResultColumnList columnList) throws ParseException, StandardException {
    columnNameItem(columnList);
    label_29:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[179] = jj_gen;
        break label_29;
      }
      jj_consume_token(COMMA);
      columnNameItem(columnList);
    }
  }

/*
 * <A NAME="columnNameItem">columnNameItem</A>
 */
  final public void columnNameItem(ResultColumnList columnList) throws ParseException, StandardException {
        String          columnName;
        ResultColumn    resultColumn;
    /* identifier() used to be columnName() */
            columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                /*
		** Store the column names for the result columns in the
		** result column list.  We don't know yet what valueNodes
		** should be hooked up to each result column, so set that
		** to null for now.
		*/
                resultColumn = (ResultColumn) nodeFactory.getNode(
                                                                        C_NodeTypes.RESULT_COLUMN,
                                                                        columnName,
                                                                        null,
                                                                        getContextManager());
                columnList.addResultColumn(resultColumn);
  }

/*
 * <A NAME="indexColumnList">indexColumnList</A>
 */
  final public void indexColumnList(Vector columnList) throws ParseException, StandardException {
    indexColumnItem(columnList);
    label_30:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[180] = jj_gen;
        break label_30;
      }
      jj_consume_token(COMMA);
      indexColumnItem(columnList);
    }
  }

/*
 * <A NAME="indexColumnItem">indexColumnItem</A>
 */
  final public void indexColumnItem(Vector columnList) throws ParseException, StandardException {
        String          columnName;
    /* identifier never ends with a space; appending a space meaning desc */
            columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
    switch (jj_nt.kind) {
    case ASC:
    case DESC:
      switch (jj_nt.kind) {
      case ASC:
        jj_consume_token(ASC);
        break;
      case DESC:
        jj_consume_token(DESC);
                                                                                     columnName = columnName + ' ';
        break;
      default:
        jj_la1[181] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[182] = jj_gen;
      ;
    }
                /*
		** Store the column names for the index columns in the
		** index column list.
		*/
                columnList.addElement(columnName);
  }

/*
 * <A NAME="derivedTable">derivedTable</A>
 */
  final public ResultSetNode derivedTable() throws ParseException, StandardException {
        SubqueryNode tableSubquery;
    jj_consume_token(LEFT_PAREN);
    tableSubquery = tableSubquery(SubqueryNode.FROM_SUBQUERY, null);
    jj_consume_token(RIGHT_PAREN);
                {if (true) return tableSubquery.getResultSet();}
    throw new Error("Missing return statement in function");
  }

  final public TableOperatorNode joinedTableExpression(ResultSetNode leftRSN, boolean nestedInParens) throws ParseException, StandardException {
        TableOperatorNode joinNode;
    joinNode = qualifiedJoin(leftRSN, nestedInParens);
                {if (true) return joinNode;}
    throw new Error("Missing return statement in function");
  }

  final public TableOperatorNode qualifiedJoin(ResultSetNode leftRSN, boolean nestedInParens) throws ParseException, StandardException {
        int                                     joinType = JoinNode.INNERJOIN;
        ResultSetNode           rightRSN;
        TableOperatorNode       ton = null;
        Object[]                        onOrUsingClause = null;
        ResultColumnList        usingClause = null;
        ValueNode                       onClause;
    switch (jj_nt.kind) {
    case INNER:
    case LEFT:
    case RIGHT:
      joinType = joinType();
      break;
    default:
      jj_la1[183] = jj_gen;
      ;
    }
    jj_consume_token(JOIN);
    rightRSN = tableReferenceTypes(nestedInParens);
    onOrUsingClause = joinSpecification(leftRSN, rightRSN);
                /* If NATURAL OR UNION is specified, then no joinSpecification()
		 * is required, otherwise it is required.
		 */

                /* RESOLVE - Since we don't support NATURAL or UNION joins yet,
		 * onOrUsingClause must be non-null.  (Change error message if and
		 * when grammar changes.)
		 */

                /* Figure out whether an ON or USING clause was used */
                onClause = (ValueNode) onOrUsingClause[ON_CLAUSE];
                usingClause = (ResultColumnList) onOrUsingClause[USING_CLAUSE];

                if (onClause == null && usingClause == null)
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_MISSING_JOIN_SPECIFICATION,
                                                        JoinNode.joinTypeToString(joinType));}
                }

                switch(joinType)
                {
                        case JoinNode.INNERJOIN:
                                ton = (TableOperatorNode) nodeFactory.getNode(
                                                                        C_NodeTypes.JOIN_NODE,
                                                                        leftRSN,
                                                                        rightRSN,
                                                                        onClause,
                                                                        usingClause,
                                                                        null,
                                                                        null,
                                                                        getContextManager());
                                break;

                        case JoinNode.LEFTOUTERJOIN:
                                ton = (TableOperatorNode) nodeFactory.getNode(
                                                                                C_NodeTypes.HALF_OUTER_JOIN_NODE,
                                                                                leftRSN,
                                                                                rightRSN,
                                                                                onClause,
                                                                                usingClause,
                                                                                Boolean.FALSE,
                                                                                null,
                                                                                getContextManager());
                                break;

                        case JoinNode.RIGHTOUTERJOIN:
                                ton = (TableOperatorNode) nodeFactory.getNode(
                                                                                C_NodeTypes.HALF_OUTER_JOIN_NODE,
                                                                                leftRSN,
                                                                                rightRSN,
                                                                                onClause,
                                                                                usingClause,
                                                                                Boolean.TRUE,
                                                                                null,
                                                                                getContextManager());
                                break;


                        default:
                                if (SanityManager.DEBUG)
                                {
                                        SanityManager.ASSERT(false, "Unexpected joinType");
                                }
                                {if (true) return null;}
                }

                /* Mark whether or not we are nested within parens */
                ton.setNestedInParens(nestedInParens);
                {if (true) return ton;}
    throw new Error("Missing return statement in function");
  }

  final public int joinType() throws ParseException, StandardException {
        int joinType;
    switch (jj_nt.kind) {
    case INNER:
      jj_consume_token(INNER);
                {if (true) return JoinNode.INNERJOIN;}
      break;
    case LEFT:
    case RIGHT:
      joinType = outerJoinType();
      switch (jj_nt.kind) {
      case OUTER:
        jj_consume_token(OUTER);
        break;
      default:
        jj_la1[184] = jj_gen;
        ;
      }
                {if (true) return joinType;}
      break;
    default:
      jj_la1[185] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int outerJoinType() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case LEFT:
      jj_consume_token(LEFT);
                {if (true) return JoinNode.LEFTOUTERJOIN;}
      break;
    case RIGHT:
      jj_consume_token(RIGHT);
                {if (true) return JoinNode.RIGHTOUTERJOIN;}
      break;
    default:
      jj_la1[186] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Object[] joinSpecification(ResultSetNode leftRSN, ResultSetNode rightRSN) throws ParseException, StandardException {
        Object[]                        onOrUsingClause = new Object[ON_OR_USING_CLAUSE_SIZE];
        ResultColumnList        usingClause = null;
        ValueNode                       joinClause = null;
    joinClause = joinCondition();
                onOrUsingClause[ON_CLAUSE] = joinClause;
                onOrUsingClause[USING_CLAUSE] = usingClause;
                {if (true) return onOrUsingClause;}
    throw new Error("Missing return statement in function");
  }

  final public ValueNode joinCondition() throws ParseException, StandardException {
        ValueNode joinClause;
    jj_consume_token(ON);
    joinClause = valueExpression(false);
                {if (true) return joinClause;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="tableValueConstructor">tableValueConstructor</A>
 */
  final public ResultSetNode tableValueConstructor() throws ParseException, StandardException {
        ResultSetNode   resultSetNode;
    jj_consume_token(VALUES);
    resultSetNode = tableValueConstructorList();
                {if (true) return resultSetNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="tableValueConstructorList">tableValueConstructorList</A>
 */
  final public ResultSetNode tableValueConstructorList() throws ParseException, StandardException {
        ResultSetNode   resultSetNode;
    resultSetNode = rowValueConstructor(null);
    label_31:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[187] = jj_gen;
        break label_31;
      }
      jj_consume_token(COMMA);
      resultSetNode = rowValueConstructor(resultSetNode);
    }
                if (resultSetNode instanceof UnionNode)
                {
                        ((UnionNode) resultSetNode).markTopTableConstructor();
                }

                {if (true) return resultSetNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="explicitTable">explicitTable</A>
 */

/*
 * <A NAME="datetimeValueFunction">datetimeValueFunction</A>
 */
  final public ValueNode datetimeValueFunction() throws ParseException, StandardException {
        int prec = -1;
    if ((getToken(1).kind == CURRENT && getToken(2).kind == DATE)) {
      jj_consume_token(CURRENT);
      jj_consume_token(DATE);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                                                ReuseFactory.getInteger(
                                                                        CurrentDatetimeOperatorNode.CURRENT_DATE),
                                                                getContextManager());}
    } else {
      switch (jj_nt.kind) {
      case CURRENT_DATE:
        jj_consume_token(CURRENT_DATE);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                                                ReuseFactory.getInteger(
                                                                        CurrentDatetimeOperatorNode.CURRENT_DATE),
                                                                getContextManager());}
        break;
      default:
        jj_la1[188] = jj_gen;
        if ((getToken(1).kind == CURRENT && getToken(2).kind == TIME)) {
          jj_consume_token(CURRENT);
          jj_consume_token(TIME);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                                        ReuseFactory.getInteger(
                                                                CurrentDatetimeOperatorNode.CURRENT_TIME),
                                                        getContextManager());}
        } else {
          switch (jj_nt.kind) {
          case CURRENT_TIME:
            jj_consume_token(CURRENT_TIME);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                                        ReuseFactory.getInteger(
                                                                CurrentDatetimeOperatorNode.CURRENT_TIME),
                                                        getContextManager());}
            break;
          default:
            jj_la1[189] = jj_gen;
            if ((getToken(1).kind == CURRENT && getToken(2).kind == TIMESTAMP)) {
              jj_consume_token(CURRENT);
              jj_consume_token(TIMESTAMP);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                                        ReuseFactory.getInteger(
                                                                CurrentDatetimeOperatorNode.CURRENT_TIMESTAMP),
                                                        getContextManager());}
            } else {
              switch (jj_nt.kind) {
              case CURRENT_TIMESTAMP:
                jj_consume_token(CURRENT_TIMESTAMP);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                                        ReuseFactory.getInteger(
                                                                CurrentDatetimeOperatorNode.CURRENT_TIMESTAMP),
                                                        getContextManager());}
                break;
              default:
                jj_la1[190] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
** Note that set function and aggregate are used
** interchangeably in the parser.  The tree has
** aggregate nodes.
*/
  final public ValueNode aggregateNode() throws ParseException, StandardException {
        ValueNode agg;
    switch (jj_nt.kind) {
    case COUNT:
      jj_consume_token(COUNT);
      jj_consume_token(LEFT_PAREN);
      switch (jj_nt.kind) {
      case ASTERISK:
        jj_consume_token(ASTERISK);
                        agg = (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.AGGREGATE_NODE,
                                                                null,
                                                                CountAggregateDefinition.class,
                                                                Boolean.FALSE,
                                                                "COUNT(*)",
                                                                getContextManager());
        break;
      default:
        jj_la1[191] = jj_gen;
        if (jj_2_36(1)) {
          agg = aggregateExpression("COUNT", CountAggregateDefinition.class);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RIGHT_PAREN);
                {if (true) return agg;}
      break;
    case AVG:
    case BINARY:
    case COALESCE:
    case D:
    case MAX:
    case MIN:
    case MODULE:
    case SUM:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      agg = generalAggregate();
                {if (true) return agg;}
      break;
    default:
      jj_la1[192] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ValueNode aggregateExpression(String aggName, Class aggClass) throws ParseException, StandardException {
        boolean         distinct = false;
        ValueNode       value;
    if (jj_2_37(1)) {
      distinct = setQuantifier();
    } else {
      ;
    }
    value = additiveExpression(null, 0, false);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.AGGREGATE_NODE,
                                                                value,
                                                                aggClass,
                                                                distinct ? Boolean.TRUE : Boolean.FALSE,
                                                                aggName,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public ValueNode generalAggregate() throws ParseException, StandardException {
        Token                   aggToken;
        String                  methodAliasString;
        ValueNode       aggExpr;
        ValueNode               value;
    switch (jj_nt.kind) {
    case AVG:
    case MAX:
    case MIN:
    case SUM:
      aggToken = builtInAggregateType();
      jj_consume_token(LEFT_PAREN);
      aggExpr = aggregateExpression(aggName(aggToken), aggClass(aggToken));
      jj_consume_token(RIGHT_PAREN);
                {if (true) return aggExpr;}
      break;
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      /*
      	** If we know we have a distinct, then we can catch
      	** a user aggregate here; otherwise, we have to generate
      	** a staticMethodNode and fix it up later.
      	*/
              methodAliasString = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
      jj_consume_token(LEFT_PAREN);
      setQuantifier();
      value = additiveExpression(null, 0, false);
      jj_consume_token(RIGHT_PAREN);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.AGGREGATE_NODE,
                                                                value,
                                                                methodAliasString,
                                                                Boolean.TRUE,
                                                                methodAliasString,
                                                                getContextManager());}
      break;
    default:
      jj_la1[193] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
** All built in aggregates are pretty similar to user
** defined aggregates, except we know what to map to
** without looking up the class name.
**
** NOTE: COUNT is omitted here because the COUNT aggregate is
** factored into a different rule, to distinguish between
** COUNT(*) and COUNT(<expression>).
*/
  final public Token builtInAggregateType() throws ParseException, StandardException {
        Token   retval;
    switch (jj_nt.kind) {
    case MAX:
      retval = jj_consume_token(MAX);
      break;
    case AVG:
      retval = jj_consume_token(AVG);
      break;
    case MIN:
      retval = jj_consume_token(MIN);
      break;
    case SUM:
      retval = jj_consume_token(SUM);
      break;
    default:
      jj_la1[194] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

  final public ValueNode castSpecification() throws ParseException, StandardException {
        DataTypeDescriptor dts;
        ValueNode                treeTop;
        ValueNode                value;
        int                              charType;
        int                              length = -1;
    jj_consume_token(CAST);
    jj_consume_token(LEFT_PAREN);
    value = castOperand();
    jj_consume_token(AS);
    dts = dataTypeCast();
    jj_consume_token(RIGHT_PAREN);
                treeTop = (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.CAST_NODE,
                                                                        value,
                                                                        dts,
                                                                        getContextManager());

                /* We need to generate a SQL->Java conversion tree above us if
		 * the dataTypeCast is a user type.
		 */
                if (! dts.getTypeId().builtIn())
                {
                        treeTop = (ValueNode) nodeFactory.getNode(
                                                        C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                        nodeFactory.getNode(
                                                                                        C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
                                                                                        treeTop,
                                                                                        getContextManager()),
                                                        getContextManager());
                }

                {if (true) return treeTop;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="charOrVarchar">charOrVarchar</A>
 */
  final public int charOrVarchar() throws ParseException {
    switch (jj_nt.kind) {
    case CHAR:
      jj_consume_token(CHAR);
                {if (true) return Types.CHAR;}
      break;
    case VARCHAR:
      jj_consume_token(VARCHAR);
                {if (true) return Types.VARCHAR;}
      break;
    default:
      jj_la1[195] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ValueNode castOperand() throws ParseException, StandardException {
        ValueNode value;
    if (jj_2_38(1)) {
      value = additiveExpression(null, 0, false);
                {if (true) return value;}
    } else {
      switch (jj_nt.kind) {
      case NULL:
        jj_consume_token(NULL);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                        getContextManager());}
        break;
      default:
        jj_la1[196] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dynamicParameterSpecification">dynamicParameterSpecification</A>
 */
  final public ParameterNode dynamicParameterSpecification() throws ParseException, StandardException {
    jj_consume_token(QUESTION_MARK);
                {if (true) return makeParameterNode( );}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="whereClause">whereClause</A>
 */
  final public ValueNode whereClause(Token beginToken) throws ParseException, StandardException {
        ValueNode       value;
        Token           endToken;
    /* valueExpression() was searchCondition() */
            value = valueExpression(false);
                endToken = getToken(0);

                value.setBeginOffset( beginToken.endOffset + 1 );
                value.setEndOffset( endToken.endOffset );

                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public GroupByList groupByClause() throws ParseException, StandardException {
        GroupByList groupingCols;
    jj_consume_token(GROUP);
    jj_consume_token(BY);
    groupingCols = groupingColumnReferenceList();
                {if (true) return groupingCols;}
    throw new Error("Missing return statement in function");
  }

  final public GroupByList groupingColumnReferenceList() throws ParseException, StandardException {
        GroupByList groupingCols = (GroupByList) nodeFactory.getNode(
                                                                        C_NodeTypes.GROUP_BY_LIST,
                                                                        getContextManager());
    groupingColumnReference(groupingCols);
    label_32:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[197] = jj_gen;
        break label_32;
      }
      jj_consume_token(COMMA);
      groupingColumnReference(groupingCols);
    }
                {if (true) return groupingCols;}
    throw new Error("Missing return statement in function");
  }

  final public void groupingColumnReference(GroupByList groupingCols) throws ParseException, StandardException {
        ColumnReference colRef;
    colRef = columnReference();
                groupingCols.addGroupByColumn(
                        (GroupByColumn) nodeFactory.getNode(
                                                        C_NodeTypes.GROUP_BY_COLUMN,
                                                        colRef,
                                                        getContextManager()));
  }

  final public ValueNode havingClause() throws ParseException, StandardException {
        ValueNode value;
    jj_consume_token(HAVING);
    value = valueExpression(false);
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode schemaDefinition() throws ParseException, StandardException {
        String  schemaName;
    jj_consume_token(SCHEMA);
    schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                if (schemaName.startsWith("SYS"))
                        {if (true) throw StandardException.newException(SQLState.INVALID_SCHEMA_SYS, schemaName);}

                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                C_NodeTypes.CREATE_SCHEMA_NODE,
                                schemaName,
                                null,
                                getContextManager()
                                );}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="tableDefinition">tableDefinition</A>
 */
  final public QueryTreeNode tableDefinition() throws ParseException, StandardException {
        char                            lockGranularity = TableDescriptor.DEFAULT_LOCK_GRANULARITY;
        Properties                      properties = null;
        TableName                       tableName;
        TableElementList        tableElementList;
    jj_consume_token(TABLE);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    tableElementList = tableElementList();
    switch (jj_nt.kind) {
    case PROPERTIES:
      properties = propertyList();
      break;
    default:
      jj_la1[198] = jj_gen;
      ;
    }
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.CREATE_TABLE_NODE,
                                                                tableName,
                                                                tableElementList,
                                                                properties,
                                                                new Character(lockGranularity),
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public Properties propertyList() throws ParseException, StandardException {
        Properties properties = new FormatableProperties();
    jj_consume_token(PROPERTIES);
    property(properties);
    label_33:
    while (true) {
      if (anotherPropertyFollows()) {
        ;
      } else {
        break label_33;
      }
      jj_consume_token(COMMA);
      property(properties);
    }
                checkInternalFeature("PROPERTIES");
                {if (true) return properties;}
    throw new Error("Missing return statement in function");
  }

  final public void property(Properties properties) throws ParseException, StandardException {
        String key;
        String value;
    key = javaDSL();
    jj_consume_token(EQUALS_OPERATOR);
    value = propertyValue();
                // Do not allow user to specify multiple values for the same key
                if (properties.put(key, value) != null)
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, key);}
                }
  }

  final public String propertyValue() throws ParseException, StandardException {
        int        intValue;
        String value;
    switch (jj_nt.kind) {
    case ADD:
    case ALL:
    case ALLOCATE:
    case ALTER:
    case AND:
    case ANY:
    case ARE:
    case AS:
    case ASC:
    case ASSERTION:
    case AT:
    case AUTHORIZATION:
    case AVG:
    case BEGIN:
    case BETWEEN:
    case BINARY:
    case BIT:
    case BOTH:
    case BY:
    case CASCADE:
    case CASCADED:
    case CASE:
    case CAST:
    case CHAR:
    case CHARACTER:
    case CHECK:
    case CLOSE:
    case COALESCE:
    case COLLATE:
    case COLLATION:
    case COLUMN:
    case COMMIT:
    case CONNECT:
    case CONNECTION:
    case CONSTRAINT:
    case CONSTRAINTS:
    case CONTINUE:
    case CONVERT:
    case CORRESPONDING:
    case COUNT:
    case CREATE:
    case CURRENT:
    case CURRENT_DATE:
    case CURRENT_TIME:
    case CURRENT_TIMESTAMP:
    case CURRENT_USER:
    case CURSOR:
    case D:
    case DEALLOCATE:
    case DEC:
    case DECIMAL:
    case DECLARE:
    case _DEFAULT:
    case DEFERRABLE:
    case DEFERRED:
    case DELETE:
    case DESC:
    case DESCRIBE:
    case DIAGNOSTICS:
    case DISCONNECT:
    case DISTINCT:
    case DOUBLE:
    case DROP:
    case ELSE:
    case END:
    case ENDEXEC:
    case ESCAPE:
    case EXCEPT:
    case EXCEPTION:
    case EXEC:
    case EXECUTE:
    case EXISTS:
    case EXTERNAL:
    case FALSE:
    case FETCH:
    case FIRST:
    case FLOAT:
    case FOR:
    case FOREIGN:
    case FOUND:
    case FROM:
    case FULL:
    case FUNCTION:
    case GET:
    case GLOBAL:
    case GO:
    case GOTO:
    case GRANT:
    case GROUP:
    case HAVING:
    case HOUR:
    case IDENTITY:
    case IMMEDIATE:
    case IN:
    case INDICATOR:
    case INITIALLY:
    case INNER:
    case INPUT:
    case INSENSITIVE:
    case INSERT:
    case INT:
    case INTEGER:
    case INTERSECT:
    case INTO:
    case IS:
    case ISOLATION:
    case JOIN:
    case KEY:
    case LAST:
    case LEFT:
    case LIKE:
    case LOWER:
    case MATCH:
    case MAX:
    case MIN:
    case MINUTE:
    case MODULE:
    case NATIONAL:
    case NATURAL:
    case NCHAR:
    case NEXT:
    case NO:
    case NOT:
    case NULL:
    case NULLIF:
    case NUMERIC:
    case OF:
    case ON:
    case ONLY:
    case OPEN:
    case OPTION:
    case OR:
    case ORDER:
    case OUTER:
    case OUTPUT:
    case OVERLAPS:
    case PAD:
    case PARTIAL:
    case PREPARE:
    case PRESERVE:
    case PRIMARY:
    case PRIOR:
    case PRIVILEGES:
    case PROCEDURE:
    case PUBLIC:
    case READ:
    case REAL:
    case REFERENCES:
    case RELATIVE:
    case RESTRICT:
    case REVOKE:
    case RIGHT:
    case ROLLBACK:
    case ROWS:
    case SCHEMA:
    case SCROLL:
    case SECOND:
    case SELECT:
    case SESSION_USER:
    case SET:
    case SMALLINT:
    case SOME:
    case SPACE:
    case SQL:
    case SQLCODE:
    case SQLERROR:
    case SQLSTATE:
    case SUBSTRING:
    case SUM:
    case SYSTEM_USER:
    case T:
    case TABLE:
    case TEMPORARY:
    case TIMEZONE_HOUR:
    case TIMEZONE_MINUTE:
    case TO:
    case TRANSACTION:
    case TRANSLATE:
    case TRANSLATION:
    case TRUE:
    case TS:
    case UNION:
    case UNIQUE:
    case UNKNOWN:
    case UPDATE:
    case UPPER:
    case USER:
    case USING:
    case VALUE:
    case VALUES:
    case VARBINARY:
    case VARCHAR:
    case VARYING:
    case VIEW:
    case WHENEVER:
    case WHERE:
    case WITH:
    case WORK:
    case WRITE:
    case YEAR:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INOUT:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case BOOLEAN:
    case CALL:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case GET_CURRENT_CONNECTION:
    case EXPLAIN:
    case LONGINT:
    case LONG:
    case LTRIM:
    case RTRIM:
    case SUBSTR:
    case XML:
    case XMLPARSE:
    case XMLSERIALIZE:
    case XMLEXISTS:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case NVARCHAR:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case OUT:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      value = caseInsensitiveIdentifierPlusReservedWords();
                {if (true) return value;}
      break;
    case EXACT_NUMERIC:
      intValue = uint_value();
                {if (true) return String.valueOf(intValue);}
      break;
    case STRING:
      value = string();
                {if (true) return value;}
      break;
    default:
      jj_la1[199] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="DB2lockGranularityClause">DB2lockGranularityClause</A>
 */
  final public char DB2lockGranularityClause() throws ParseException, StandardException {
        char lockGranularity;
    jj_consume_token(LOCKSIZE);
    lockGranularity = lockGranularity();
                {if (true) return lockGranularity;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="lockGranularity">lockGranularity</A>
 */
  final public char lockGranularity() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case TABLE:
      jj_consume_token(TABLE);
                {if (true) return TableDescriptor.TABLE_LOCK_GRANULARITY;}
      break;
    case ROW:
      jj_consume_token(ROW);
                {if (true) return TableDescriptor.ROW_LOCK_GRANULARITY;}
      break;
    default:
      jj_la1[200] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="indexDefinition">indexDefinition</A>
 */
  final public QueryTreeNode indexDefinition() throws ParseException, StandardException {
        Boolean         unique = Boolean.FALSE;
        Properties      properties = null;
        TableName       indexName;
        TableName       tableName;
        Vector  indexColumnList = new Vector();
    switch (jj_nt.kind) {
    case UNIQUE:
      unique = unique();
      break;
    default:
      jj_la1[201] = jj_gen;
      ;
    }
    jj_consume_token(INDEX);
    indexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    jj_consume_token(ON);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    jj_consume_token(LEFT_PAREN);
    indexColumnList(indexColumnList);
    jj_consume_token(RIGHT_PAREN);
    switch (jj_nt.kind) {
    case PROPERTIES:
      properties = propertyList();
      break;
    default:
      jj_la1[202] = jj_gen;
      ;
    }
                /* User allowed to specify schema name on table and index.
		 * If no schema name specified for index, then it "inherits" 
		 * its schema name from the table.
		 * If index has a schema name and table does not, then
		 * table "inherits" its schema name from the index.
		 * If schema names are specified for both objects, then the
		 * schema names must be the same.
		 */
                if (indexName.getSchemaName() == null)
                {
                        indexName.setSchemaName(tableName.getSchemaName());
                }
                else if (tableName.getSchemaName() == null)
                {
                        tableName.setSchemaName(indexName.getSchemaName());
                }
                else
                {
                        /* schema name specified for both */
                        if (! (indexName.getSchemaName().equals(
                                                tableName.getSchemaName())))
                        {
                                {if (true) throw StandardException.newException(SQLState.LANG_INDEX_AND_TABLE_IN_DIFFERENT_SCHEMAS,
                                                        indexName,
                                                        tableName);}
                        }
                }
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.CREATE_INDEX_NODE,
                                                                unique,
                                                                DEFAULT_INDEX_TYPE,
                                                                indexName,
                                                                tableName,
                                                                indexColumnList,
                                                                properties,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="unique">unique</A>
 */
  final public Boolean unique() throws ParseException, StandardException {
    jj_consume_token(UNIQUE);
                {if (true) return Boolean.TRUE;}
    throw new Error("Missing return statement in function");
  }

/**
	CREATE PROCEDURE

	procedureElements contains the description of the procedure.
	(CREATE FUNCTIONS shares this lyout), see functionDefinition

	0 - Object[] 3 element array for parameters
	1 - TableName - specific name
	2 - Integer - dynamic result set count
	3 - String language (always java) - ignore
	4 - String external name (also passed directly to create alias node - ignore
	5 - Short parameter style (always java) - ignore 
	6 - Short - SQL allowed.
	7 - Boolean - CALLED ON NULL INPUT (always TRUE for procedures)
	8 - TypeDescriptor - return type (always NULL for procedures)
*/
  final public QueryTreeNode procedureDefinition() throws ParseException, StandardException {
        TableName procedureName;
        Object[] procedureElements = new Object[9];
    jj_consume_token(PROCEDURE);
    procedureName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    procedureElements[0] = procedureParameterList();
    label_34:
    while (true) {
      routineElement(true, procedureElements);
      switch (jj_nt.kind) {
      case EXTERNAL:
      case NO:
      case CALLED:
      case CONTAINS:
      case DYNAMIC:
      case LANGUAGE:
      case MODIFIES:
      case RETURNS:
      case PARAMETER:
      case READS:
      case RESULT:
      case SPECIFIC:
        ;
        break;
      default:
        jj_la1[203] = jj_gen;
        break label_34;
      }
    }
                        // some of the procedure elements are mandatory
                    if ((procedureElements[3] == null) || (procedureElements[4] == null) || (procedureElements[5] == null))
                                {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MISSING ELEMENT");}

                        {if (true) return getCreateAliasNode(
                                                        procedureName,
                                                        (String) procedureElements[4],
                                                        procedureElements,
                                                        AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR,
                                                        Boolean.FALSE);}
    throw new Error("Missing return statement in function");
  }

  final public void routineElement(boolean isProcedure, Object[] routineElements) throws ParseException, StandardException {
        int drs;
        int clausePosition = -1;
        Object clauseValue = null;
    switch (jj_nt.kind) {
    case SPECIFIC:
      jj_consume_token(SPECIFIC);
      clauseValue = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                          clausePosition = 1; {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, "SPECIFIC identifier");}
      break;
    case DYNAMIC:
    case RESULT:
      switch (jj_nt.kind) {
      case DYNAMIC:
        jj_consume_token(DYNAMIC);
        break;
      default:
        jj_la1[204] = jj_gen;
        ;
      }
      jj_consume_token(RESULT);
      jj_consume_token(SETS);
      drs = uint_value();
                        if (!isProcedure)
                                {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "RESULT SETS");}
                        clauseValue = ReuseFactory.getInteger(drs); clausePosition = 2;
      break;
    case LANGUAGE:
      jj_consume_token(LANGUAGE);
      jj_consume_token(JAVA);
                                     clauseValue = "JAVA"; clausePosition = 3;
      break;
    case EXTERNAL:
      jj_consume_token(EXTERNAL);
      jj_consume_token(NAME);
      clauseValue = string();
                                                           clausePosition = 4;
      break;
    case PARAMETER:
      jj_consume_token(PARAMETER);
      jj_consume_token(STYLE);
      clauseValue = parameterStyle();
                                                                     clausePosition = 5;
      break;
    case NO:
      jj_consume_token(NO);
      jj_consume_token(SQL);
                                                          clauseValue = ReuseFactory.getShort(RoutineAliasInfo.NO_SQL); clausePosition = 6;
      break;
    case CONTAINS:
      jj_consume_token(CONTAINS);
      jj_consume_token(SQL);
                                                  clauseValue = ReuseFactory.getShort(RoutineAliasInfo.CONTAINS_SQL); clausePosition = 6;
      break;
    case READS:
      jj_consume_token(READS);
      jj_consume_token(SQL);
      jj_consume_token(DATA);
                                          clauseValue = ReuseFactory.getShort(RoutineAliasInfo.READS_SQL_DATA); clausePosition = 6;
      break;
    case MODIFIES:
      jj_consume_token(MODIFIES);
      jj_consume_token(SQL);
      jj_consume_token(DATA);
                        if (!isProcedure)
                                {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MODIFIES SQL DATA");}
                        clauseValue = ReuseFactory.getShort(RoutineAliasInfo.MODIFIES_SQL_DATA); clausePosition = 6;
      break;
    case CALLED:
    case RETURNS:
      clauseValue = calledOnNullInput();
                                                 clausePosition = 7;
      break;
    default:
      jj_la1[205] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (clausePosition != -1) {
                        // check for repeated clause
                        if (routineElements[clausePosition] != null) {

                                String which = PROCEDURE_CLAUSE_NAMES[clausePosition];
                                {if (true) throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);}
                        }

                        routineElements[clausePosition] = clauseValue;
                }
  }

  final public Boolean calledOnNullInput() throws ParseException {
        Boolean calledOnNull;
    switch (jj_nt.kind) {
    case CALLED:
      jj_consume_token(CALLED);
                           calledOnNull = Boolean.TRUE;
      break;
    case RETURNS:
      jj_consume_token(RETURNS);
      jj_consume_token(NULL);
                                     calledOnNull = Boolean.FALSE;
      break;
    default:
      jj_la1[206] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(ON);
    jj_consume_token(NULL);
    jj_consume_token(INPUT);
                {if (true) return calledOnNull;}
    throw new Error("Missing return statement in function");
  }

  final public Short parameterStyle() throws ParseException {
    jj_consume_token(JAVA);
                                 {if (true) return ReuseFactory.getShort(RoutineAliasInfo.PS_JAVA);}
    throw new Error("Missing return statement in function");
  }

  final public Object[] procedureParameterList() throws ParseException, StandardException {
        Vector[] list = new Vector[3];
        list[0] = new Vector(); // name
        list[1] = new Vector(); // type
        list[2] = new Vector();
    jj_consume_token(LEFT_PAREN);
    switch (jj_nt.kind) {
    case BINARY:
    case COALESCE:
    case D:
    case IN:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INOUT:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case OUT:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      procedureParameterDefinition(list);
      label_35:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[207] = jj_gen;
          break label_35;
        }
        jj_consume_token(COMMA);
        procedureParameterDefinition(list);
      }
      break;
    default:
      jj_la1[208] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PAREN);
                {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="Definition">procedureParameterDefinition</A>
 */
  final public void procedureParameterDefinition(Vector[] list) throws ParseException, StandardException {
        DataTypeDescriptor      typeDescriptor;
        String                          parameterName;
        Integer                         inout;
    inout = inoutParameter();
    parameterName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
    typeDescriptor = dataTypeDDL();
                list[0].addElement(parameterName);
                list[1].addElement(typeDescriptor);
                list[2].addElement(inout);
  }

  final public Integer inoutParameter() throws ParseException {
        int mode = JDBC30Translation.PARAMETER_MODE_IN;
    switch (jj_nt.kind) {
    case IN:
    case INOUT:
    case OUT:
      switch (jj_nt.kind) {
      case IN:
        jj_consume_token(IN);

        break;
      case OUT:
        jj_consume_token(OUT);
                          mode = JDBC30Translation.PARAMETER_MODE_OUT;
        break;
      case INOUT:
        jj_consume_token(INOUT);
                            mode = JDBC30Translation.PARAMETER_MODE_IN_OUT;
        break;
      default:
        jj_la1[209] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[210] = jj_gen;
      ;
    }
          {if (true) return ReuseFactory.getInteger(mode);}
    throw new Error("Missing return statement in function");
  }

/**
	CREATE FUNCTION

	functionElements contains the description of the function.

	0 - Object[] 3 element array for parameters
	1 - TableName - specific name
	2 - Integer - dynamic result set count - always 0
	3 - String language (always java) - required to be set
	4 - String external name (also passed directly to create alias node - ignore
	5 - Short parameter style (always java) - required to be set 
	6 - Short - SQL allowed.
	7 - Boolean - CALLED ON NULL INPUT
	8 - TypeDescriptor - return type
*/
  final public QueryTreeNode functionDefinition() throws ParseException, StandardException {
        TableName functionName;
        Object[] functionElements = new Object[9];
    jj_consume_token(FUNCTION);
    functionName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    functionElements[0] = functionParameterList();
    jj_consume_token(RETURNS);
    functionElements[8] = dataTypeCommon();
    label_36:
    while (true) {
      routineElement(false, functionElements);
      switch (jj_nt.kind) {
      case EXTERNAL:
      case NO:
      case CALLED:
      case CONTAINS:
      case DYNAMIC:
      case LANGUAGE:
      case MODIFIES:
      case RETURNS:
      case PARAMETER:
      case READS:
      case RESULT:
      case SPECIFIC:
        ;
        break;
      default:
        jj_la1[211] = jj_gen;
        break label_36;
      }
    }
                        // some of the elements are mandatory
                    if ((functionElements[3] == null) || (functionElements[4] == null) || (functionElements[5] == null))
                                {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MISSING ELEMENT");}

                        {if (true) return getCreateAliasNode(
                                                        functionName,
                                                        (String) functionElements[4],
                                                        functionElements,
                                                        AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR,
                                                        Boolean.FALSE);}
    throw new Error("Missing return statement in function");
  }

  final public Object[] functionParameterList() throws ParseException, StandardException {
        Vector[] list = new Vector[3];
        list[0] = new Vector(); // name
        list[1] = new Vector(); // type
        list[2] = new Vector();
    jj_consume_token(LEFT_PAREN);
    switch (jj_nt.kind) {
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      functionParameterDefinition(list);
      label_37:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[212] = jj_gen;
          break label_37;
        }
        jj_consume_token(COMMA);
        functionParameterDefinition(list);
      }
      break;
    default:
      jj_la1[213] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PAREN);
                {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="Definition">functionParameterDefinition</A>
 */
  final public void functionParameterDefinition(Vector[] list) throws ParseException, StandardException {
        DataTypeDescriptor      typeDescriptor;
        String                          parameterName;
        Integer                         inout;
    parameterName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
    typeDescriptor = dataTypeDDL();
                list[0].addElement(parameterName);
                list[1].addElement(typeDescriptor);
                list[2].addElement(ReuseFactory.getInteger(JDBC30Translation.PARAMETER_MODE_IN));
  }

  final public QueryTreeNode viewDefinition(Token beginToken) throws ParseException, StandardException {
        int                                     checkOptionType;
        ResultColumnList        resultColumns = null;
        ResultSetNode           queryExpression;
        TableName                       tableName;
        Token                           checkTok = null;
        Token                           endToken;
    jj_consume_token(VIEW);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    switch (jj_nt.kind) {
    case LEFT_PAREN:
      jj_consume_token(LEFT_PAREN);
      resultColumns = viewColumnList();
      jj_consume_token(RIGHT_PAREN);
      break;
    default:
      jj_la1[214] = jj_gen;
      ;
    }
    jj_consume_token(AS);
    queryExpression = queryExpression(null, NO_SET_OP);
                checkOptionType = ViewDescriptor.NO_CHECK_OPTION;
                endToken = getToken(0);
                /* Parameters not allowed in create view */
                HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);
                queryExpression.accept(visitor);
                if (visitor.hasNode())
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_VIEWS);}
                }

                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.CREATE_VIEW_NODE,
                                                                tableName,
                                                                resultColumns,
                                                                queryExpression,
                                                                ReuseFactory.getInteger(checkOptionType),
                                                                getStringSlicer().slice(
                                                                                                beginToken.beginOffset,
                                                                                                endToken.endOffset,false),
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public ResultColumnList viewColumnList() throws ParseException, StandardException {
        ResultColumnList        resultColumns = (ResultColumnList) nodeFactory.getNode(
                                                                                        C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                        getContextManager());
    columnNameList(resultColumns);
                {if (true) return resultColumns;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode triggerDefinition() throws ParseException, StandardException {
        Boolean                         isBefore;
        Boolean                         isRow;
        TableName                       tableName;
        TableName                       triggerName;
        Token[]                         tokenHolder = new Token[1];
        Token                           beginToken;
        Token                           checkTok = null;
        Token                           endToken;
        int                                     actionBegin;
        int                                     actionEnd;
        int                                     triggerEvent;
        QueryTreeNode           actionNode;
        ResultColumnList        triggerColumns = (ResultColumnList) nodeFactory.getNode(
                                                                                        C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                        getContextManager());
        Vector                          refClause = null;
    jj_consume_token(TRIGGER);
    triggerName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    isBefore = beforeOrAfter();
    triggerEvent = triggerEvent(triggerColumns);
    jj_consume_token(ON);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    switch (jj_nt.kind) {
    case REFERENCING:
      refClause = triggerReferencingClause();
      break;
    default:
      jj_la1[215] = jj_gen;
      ;
    }
    jj_consume_token(FOR);
    jj_consume_token(EACH);
    isRow = rowOrStatement();
    jj_consume_token(MODE);
    jj_consume_token(DB2SQL);
    //we are not top level statement
                    actionNode = proceduralStatement(tokenHolder);
                actionEnd = getToken(0).endOffset;
                actionBegin = tokenHolder[0].beginOffset;

                // No DML in action node for BEFORE triggers.
                if (isBefore.booleanValue() && (actionNode instanceof DMLModStatementNode)) {
                                {if (true) throw StandardException.newException(
                                        SQLState.LANG_UNSUPPORTED_TRIGGER_STMT,
                                        ((StatementNode) actionNode).statementToString(), "BEFORE");}
                                        }


                // no params in trigger action
                HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);
                actionNode.accept(visitor);
                if (visitor.hasNode())
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_TRIGGER_ACTION);}
                }

                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.CREATE_TRIGGER_NODE,
                                                                triggerName,
                                                                tableName,
                                                                ReuseFactory.getInteger(triggerEvent),
                                                                triggerColumns,
                                                                isBefore,
                                                                isRow,
                                                                Boolean.TRUE,                           // enabled
                                                                refClause,                      // referencing clause
                                                                null,// when clause node
                                                                null,           // when clause text
                                                                ReuseFactory.getInteger(0),
                                                                                        // when clause begin offset
                                                                actionNode,
                                                                getStringSlicer().slice(
                                                                        actionBegin,
                                                                        actionEnd,false),
                                                                ReuseFactory.getInteger(actionBegin),
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode synonymDefinition() throws ParseException, StandardException {
        TableName synonymName;
        TableName targetName;
    jj_consume_token(SYNONYM);
    synonymName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    jj_consume_token(FOR);
    targetName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                checkVersion(DataDictionary.DD_VERSION_DERBY_10_1,
                             "CREATE SYNONYM");

                {if (true) return  (StatementNode) getNodeFactory().getCreateAliasNode
                        (
                                synonymName,
                                targetName,
                                null,
                                AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR,
                                Boolean.FALSE,
                                getContextManager()
                        );}
    throw new Error("Missing return statement in function");
  }

  final public Boolean beforeOrAfter() throws ParseException {
    switch (jj_nt.kind) {
    case NO:
      jj_consume_token(NO);
      jj_consume_token(CASCADE);
      jj_consume_token(BEFORE);
                {if (true) return Boolean.TRUE;}
      break;
    case AFTER:
      jj_consume_token(AFTER);
                {if (true) return Boolean.FALSE;}
      break;
    default:
      jj_la1[216] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int triggerEvent(ResultColumnList rcl) throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case INSERT:
      jj_consume_token(INSERT);
                {if (true) return TriggerDescriptor.TRIGGER_EVENT_INSERT;}
      break;
    case DELETE:
      jj_consume_token(DELETE);
                {if (true) return TriggerDescriptor.TRIGGER_EVENT_DELETE;}
      break;
    case UPDATE:
      jj_consume_token(UPDATE);
      switch (jj_nt.kind) {
      case OF:
        jj_consume_token(OF);
        columnNameList(rcl);
        break;
      default:
        jj_la1[217] = jj_gen;
        ;
      }
                {if (true) return TriggerDescriptor.TRIGGER_EVENT_UPDATE;}
      break;
    default:
      jj_la1[218] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Boolean rowOrStatement() throws ParseException {
    switch (jj_nt.kind) {
    case ROW:
      token = jj_consume_token(ROW);
                {if (true) return Boolean.TRUE;}
      break;
    case STATEMENT:
      token = jj_consume_token(STATEMENT);
                {if (true) return Boolean.FALSE;}
      break;
    default:
      jj_la1[219] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Vector triggerReferencingClause() throws ParseException, StandardException {
        Vector vector = new Vector();
    jj_consume_token(REFERENCING);
    triggerReferencingExpression(vector);
    label_38:
    while (true) {
      switch (jj_nt.kind) {
      case NEW:
      case NEW_TABLE:
      case OLD:
      case OLD_TABLE:
        ;
        break;
      default:
        jj_la1[220] = jj_gen;
        break label_38;
      }
      triggerReferencingExpression(vector);
    }
                {if (true) return vector;}
    throw new Error("Missing return statement in function");
  }

  final public void triggerReferencingExpression(Vector vector) throws ParseException, StandardException {
        String  identifier;
        boolean isNew = true;
        boolean isRow = true;
    switch (jj_nt.kind) {
    case NEW:
      jj_consume_token(NEW);
      break;
    case OLD:
      jj_consume_token(OLD);
                 isNew = false;
      break;
    case NEW_TABLE:
      jj_consume_token(NEW_TABLE);
                        isRow = false;
      break;
    case OLD_TABLE:
      jj_consume_token(OLD_TABLE);
                        isNew = false; isRow = false;
      break;
    default:
      jj_la1[221] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(AS);
    identifier = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                vector.addElement(new TriggerReferencingStruct(isRow, isNew, identifier));
  }

/*
 * <A NAME="defaultClause">defaultClause</A>
 */
  final public ValueNode defaultClause(long[] autoIncrementInfo, String columnName) throws ParseException, StandardException {
        ValueNode       value;
        Token           beginToken;
        Token           endToken;
    switch (jj_nt.kind) {
    case _DEFAULT:
    case WITH:
      switch (jj_nt.kind) {
      case WITH:
        jj_consume_token(WITH);
        break;
      default:
        jj_la1[222] = jj_gen;
        ;
      }
      beginToken = jj_consume_token(_DEFAULT);
      value = defaultOption(beginToken, autoIncrementInfo, columnName);
                {if (true) return value;}
      break;
    case GENERATED:
      value = generatedColumnOption(autoIncrementInfo);
                {if (true) return value;}
      break;
    default:
      jj_la1[223] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="defaultNullOnlyClause">defaultNullOnlyClause</A>
 */
  final public ValueNode defaultNullOnlyClause() throws ParseException, StandardException {
    jj_consume_token(_DEFAULT);
    jj_consume_token(NULL);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="generatedColumnOption">generatedColumnOption</A>
 */

//ToCleanUp
//A specific class not such long[] should exists for autoIncrementInfo ...
  final public ValueNode generatedColumnOption(long[] autoIncrementInfo) throws ParseException, StandardException {
        ValueNode       value = null;
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = 1;
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = 1;
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] = 1;
    jj_consume_token(GENERATED);
    switch (jj_nt.kind) {
    case ALWAYS:
      jj_consume_token(ALWAYS);
                value = null;
      break;
    case BY:
      jj_consume_token(BY);
      jj_consume_token(_DEFAULT);
                checkVersion(DataDictionary.DD_VERSION_DERBY_10_1,
                             "GENERATED BY DEFAULT");

                value = (ValueNode) nodeFactory.getNode(C_NodeTypes.DEFAULT_NODE,
                                                        getContextManager()) ;
      break;
    default:
      jj_la1[224] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(AS);
    jj_consume_token(IDENTITY);
    switch (jj_nt.kind) {
    case LEFT_PAREN:
      jj_consume_token(LEFT_PAREN);
      autoIncrementBeginEnd(autoIncrementInfo);
      jj_consume_token(RIGHT_PAREN);
      break;
    default:
      jj_la1[225] = jj_gen;
      ;
    }
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="autoIncrementBeginEnd">autoIncrementBeginEnd</A>
 */
  final public void autoIncrementBeginEnd(long[] autoIncrementInfo) throws ParseException, StandardException {
        long            autoIncrementInitial = 1;
        long            autoIncrementIncrement = 1;
    switch (jj_nt.kind) {
    case INCREMENT:
      jj_consume_token(INCREMENT);
      jj_consume_token(BY);
      autoIncrementIncrement = exactNumber();
                autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
                {if (true) return;}
      break;
    case START:
      jj_consume_token(START);
      jj_consume_token(WITH);
      autoIncrementInitial = exactNumber();
      switch (jj_nt.kind) {
      case COMMA:
        jj_consume_token(COMMA);
        jj_consume_token(INCREMENT);
        jj_consume_token(BY);
        autoIncrementIncrement = exactNumber();
        break;
      default:
        jj_la1[226] = jj_gen;
        ;
      }
                autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = autoIncrementInitial;
                autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
                {if (true) return;}
      break;
    default:
      jj_la1[227] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * <A NAME="defaultOption">defaultOption</A>
 */
  final public ValueNode defaultOption(Token beginToken, long[] autoIncrementInfo,
        String columnName) throws ParseException, StandardException {
        Token           endToken;
        Token           errorTok = null;
        Token           initialTok = null;
        ValueNode       value;
    if (getToken(1).kind == NULL && !(getToken(2).kind == PERIOD ||
                            getToken(2).kind == DOUBLE_COLON)) {
      jj_consume_token(NULL);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                        getContextManager());}
    } else if (jj_2_39(1)) {
      value = DB2DefaultOption(columnName);
                endToken = getToken(0);
                value.setBeginOffset( beginToken.beginOffset );
                value.setEndOffset( endToken.endOffset );
                value = (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.DEFAULT_NODE,
                                                                value,
                                                                getStringSlicer().slice(
                                                                        beginToken.beginOffset + 7,
                                                                        endToken.endOffset,true),
                                                                getContextManager()
                                                        );
                {if (true) return value;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="DB2DefaultOption">DB2DefaultOption</A>
 */
  final public ValueNode DB2DefaultOption(String columnName) throws ParseException, StandardException {
        ValueNode       value;
    if (getToken(2).kind == SCHEMA || getToken(2).kind == SQLID) {
      jj_consume_token(CURRENT);
      switch (jj_nt.kind) {
      case SCHEMA:
        jj_consume_token(SCHEMA);
        break;
      case SQLID:
        jj_consume_token(SQLID);
        break;
      default:
        jj_la1[228] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.CURRENT_SCHEMA_NODE,
                                                getContextManager());}
    } else {
      switch (jj_nt.kind) {
      case USER:
        jj_consume_token(USER);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                C_NodeTypes.USER_NODE,
                                                                getContextManager());}
        break;
      default:
        jj_la1[229] = jj_gen;
        if (getToken(1).kind == DATE ||
                        getToken(1).kind == TIME ||
                        getToken(1).kind == TIMESTAMP) {
          value = miscBuiltins();
          // these functions are allowed as valid <cast-function> defaults.
          // Once "BLOB" is allowed as a cast-function (5281), a case should be
          // added for that, as well.
                {if (true) return value;}
        } else if (getToken(2).kind == LEFT_PAREN ||
                                        getToken(4).kind == LEFT_PAREN) {
          value = miscBuiltins();
                // If we have a function (as indicated by an open paren,
                // which can be either the 2nd token (w/ normal function name)
                // or the 4th token (w/ qualified function name)), then
                // it's not valid.  Catch it here and throw an "invalid
                // default" error (42894) instead of letting it go as
                // a syntax error (this matches DB2 UDB behavior).
                {if (true) throw StandardException.newException(
                        SQLState.LANG_DB2_INVALID_DEFAULT_VALUE,
                        columnName);}
        } else if (jj_2_40(1)) {
          value = datetimeValueFunction();
                {if (true) return value;}
        } else {
          switch (jj_nt.kind) {
          case FALSE:
          case TRUE:
          case LEFT_BRACE:
          case PLUS_SIGN:
          case MINUS_SIGN:
          case EXACT_NUMERIC:
          case STRING:
          case HEX_STRING:
          case APPROXIMATE_NUMERIC:
            // Only (valid) thing left is literals (i.e. actual constants).
                    value = literal();
                {if (true) return value;}
            break;
          default:
            jj_la1[230] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="literal">literal</A>
 */
  final public ValueNode literal() throws ParseException, StandardException {
        String  sign = "";
        Token   tok;
        String  datetimeString;
        String  bitString;
        ValueNode               constantNode;
    switch (jj_nt.kind) {
    case PLUS_SIGN:
    case MINUS_SIGN:
    case EXACT_NUMERIC:
    case APPROXIMATE_NUMERIC:
      switch (jj_nt.kind) {
      case PLUS_SIGN:
      case MINUS_SIGN:
        sign = sign();
        break;
      default:
        jj_la1[231] = jj_gen;
        ;
      }
      constantNode = numericLiteral(sign);
                {if (true) return constantNode;}
      break;
    case STRING:
      constantNode = stringLiteral();
                {if (true) return  constantNode;}
      break;
    case HEX_STRING:
      constantNode = hexLiteral();
                {if (true) return  constantNode;}
      break;
    case LEFT_BRACE:
      constantNode = dateTimeLiteral();
                {if (true) return constantNode;}
      break;
    case FALSE:
    case TRUE:
      tok = booleanLiteral();
                checkInternalFeature(tok.image);
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.BOOLEAN_CONSTANT_NODE,
                                                                        StringUtil.SQLEqualsIgnoreCase(tok.image, "true") ?
                                                                                Boolean.TRUE : Boolean.FALSE,
                                                                        getContextManager());}
      break;
    default:
      jj_la1[232] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="numericLiteral">numericLiteral</A>
 */
  final public ValueNode numericLiteral(String sign) throws ParseException, StandardException {
        Token   tok;
    switch (jj_nt.kind) {
    case EXACT_NUMERIC:
      tok = jj_consume_token(EXACT_NUMERIC);
                /*
		** The various java parse utilities can't handle leading +,
		** so only concatenate leading -.
		*/

                String num = tok.image;

                if (sign.equals("-"))
                        num = sign.concat(num);

                {if (true) return getNumericNode(num);}
      break;
    case APPROXIMATE_NUMERIC:
      tok = jj_consume_token(APPROXIMATE_NUMERIC);
                StringBuffer doubleImage;
                String doubleString;
                int ePosn, dotPosn; // Position of letter e and '.' in value
                Double          doubleValue;

                doubleImage = new StringBuffer(sign);
                doubleImage.append(tok.image);
                doubleString = doubleImage.toString();

                ePosn = doubleString.indexOf('E');
                if (ePosn == -1)
                        ePosn = doubleString.indexOf('e');
                if (SanityManager.DEBUG)
                        SanityManager.ASSERT(ePosn != -1, "no E or e in approximate numeric");

                // there is a limit on the length of a floatingpoint literal in DB2
                if (doubleString.length() > Limits.DB2_MAX_FLOATINGPOINT_LITERAL_LENGTH)
                        {if (true) throw StandardException.newException(SQLState.LANG_DB2_TOO_LONG_FLOATING_POINT_LITERAL, doubleString, TypeId.DOUBLE_NAME);}
                // if there is no '.' before the e, put one in
                dotPosn = doubleString.substring(0,ePosn).indexOf('.');
                if (dotPosn == -1) {
                        doubleImage.insert(ePosn,'.');
                        doubleString = doubleImage.toString();
                        ePosn++;
                }

                try
                {
                        doubleValue = Double.valueOf(doubleString);

                }
                catch (NumberFormatException nfe)
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, TypeId.DOUBLE_NAME);}
                }

                double dv = doubleValue.doubleValue();

                // When the value is 0 it's possible rounded, try to detect it by checking if the mantissa is 0.0
                //   "proof of correctness": any nonzero value (mantissa) with less than 30 characters will not be
                //                           rounded to 0.0 by a float/real. This correctly detects the case when
                //                           the radix/exponent being "too small" (1e-900) giving a value rounded to zero.
                if ( (dv == 0.0d) && (Double.parseDouble(doubleString.substring(0, ePosn-1)) != 0.0d) )
                {
                        {if (true) throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);}
                }

                if (Double.isNaN(dv) || Double.isInfinite(dv))
                        {if (true) throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);}

                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.DOUBLE_CONSTANT_NODE,
                                                                        doubleValue,
                                                                        getContextManager());}
      break;
    default:
      jj_la1[233] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dateTimeLiteral">dateTimeLiteral</A>
 */
  final public ValueNode dateTimeLiteral() throws ParseException, StandardException {
        ValueNode       constantNode;
    jj_consume_token(LEFT_BRACE);
    constantNode = escapedDateTimeLiteral();
    jj_consume_token(RIGHT_BRACE);
                {if (true) return constantNode;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="escapedDateTimeLiteral">escapedDateTimeLiteral</A>
 */
  final public ValueNode escapedDateTimeLiteral() throws ParseException, StandardException {
        ValueNode constantNode;
    switch (jj_nt.kind) {
    case D:
      jj_consume_token(D);
      constantNode = bareDateLiteral();
                {if (true) return constantNode;}
      break;
    case T:
      jj_consume_token(T);
      constantNode = bareTimeLiteral();
                {if (true) return constantNode;}
      break;
    case TS:
      jj_consume_token(TS);
      constantNode = bareTimestampLiteral();
                {if (true) return constantNode;}
      break;
    default:
      jj_la1[234] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="bareDateLiteral">bareDateLiteral</A>
 */
  final public ValueNode bareDateLiteral() throws ParseException, StandardException {
        String dateString;
    dateString = string();
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.USERTYPE_CONSTANT_NODE,
                                                getLanguageConnectionContext().getDataValueFactory().getDateValue(dateString, true),
                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="bareTimeLiteral">bareTimeLiteral</A>
 */
  final public ValueNode bareTimeLiteral() throws ParseException, StandardException {
        String timeString;
    timeString = string();
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.USERTYPE_CONSTANT_NODE,
                                                getLanguageConnectionContext().getDataValueFactory().getTimeValue(timeString, true),
                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="bareTimestampLiteral">bareTimestampLiteral</A>
 */
  final public ValueNode bareTimestampLiteral() throws ParseException, StandardException {
        String timestampString;
    timestampString = string();
                {if (true) return (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.USERTYPE_CONSTANT_NODE,
                                                getLanguageConnectionContext().getDataValueFactory().getTimestampValue(timestampString, true),
                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="string">string</A>
 */
  final public String string() throws ParseException, StandardException {
        Token   tok;
    tok = jj_consume_token(STRING);
                verifyImageLength(tok.image);
                /* Trim off the leading and trailing ', and compress all '' to ' */
                {if (true) return compressQuotes(tok.image.substring(1, tok.image.length() - 1),
                                                          SINGLEQUOTES);}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="stringLiteral">stringLiteral</A>
 */
  final public CharConstantNode stringLiteral() throws ParseException, StandardException {
        Token   tok;
        String  string;
    tok = jj_consume_token(STRING);
                //there is a maximum limit on the length of the string
                if (tok.image.length()-2 > Limits.DB2_MAX_CHARACTER_LITERAL_LENGTH)//-2 is for the beginning and ending quote
                        {if (true) throw StandardException.newException(SQLState.LANG_DB2_STRING_CONSTANT_TOO_LONG, StringUtil.formatForPrint(tok.image));}
                string = compressQuotes(tok.image.substring(1, tok.image.length() - 1), SINGLEQUOTES);
                /* Trim quotes from string. */
                {if (true) return (CharConstantNode) nodeFactory.getNode(
                                                                C_NodeTypes.CHAR_CONSTANT_NODE,
                                                                string,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="hexLiteral">hexLiteral</A>
 */
  final public ValueNode hexLiteral() throws ParseException, StandardException {
        Token   tok;
    tok = jj_consume_token(HEX_STRING);
                String hexLiteral = tok.image;

                //there is a maximum limit on the length of the hex constant
                if (hexLiteral.length()-3 > Limits.DB2_MAX_HEX_LITERAL_LENGTH)//-3 is for X' at the beginning and ' at the end
                        {if (true) throw StandardException.newException(SQLState.LANG_DB2_STRING_CONSTANT_TOO_LONG, StringUtil.formatForPrint(hexLiteral));}
                if ((hexLiteral.length()-3)%2 == 1)
                        {if (true) throw StandardException.newException(SQLState.LANG_DB2_INVALID_HEXADECIMAL_CONSTANT, StringUtil.formatForPrint(hexLiteral));}

                int bitLength = ((hexLiteral.length() - 3) / 2);
                {if (true) return (ValueNode)
                                nodeFactory.getNode(C_NodeTypes.VARBIT_CONSTANT_NODE,
                                                                        hexLiteral.substring(2, hexLiteral.length() - 1), ReuseFactory.getInteger(bitLength),
                                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public TableName constraintNameDefinition() throws ParseException, StandardException {
        TableName constraintName;
    jj_consume_token(CONSTRAINT);
    constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return constraintName;}
    throw new Error("Missing return statement in function");
  }

/*
 * DB2 requires column check constraints to refer to only that column. Cloudscape currently
 * doesn't care if check constraints are column level or table level. For DB2 compatibility
 * check that column check constraints only refer to that column.
 */
  final public ConstraintDefinitionNode checkConstraintDefinition(TableName constraintName, String columnName) throws ParseException, StandardException {
        Token           beginToken;
        Token           endToken;
        ValueNode       value;
        ResultColumnList rclList = null;
    jj_consume_token(CHECK);
    beginToken = jj_consume_token(LEFT_PAREN);
    value = valueExpression(false);
    endToken = jj_consume_token(RIGHT_PAREN);
                if (columnName != null)
                {
                        /* Column check constraint */
                        rclList = (ResultColumnList) nodeFactory.getNode(
                                                                        C_NodeTypes.RESULT_COLUMN_LIST,
                                                                        getContextManager());
                        rclList.addElement((ResultColumn) nodeFactory.getNode(
                                                                        C_NodeTypes.RESULT_COLUMN,
                                                                        columnName,
                                                                        null,
                                                                        getContextManager()));
                }

                value.setBeginOffset( beginToken.beginOffset );
                value.setEndOffset( endToken.endOffset );
                {if (true) return (ConstraintDefinitionNode) nodeFactory.getNode(
                                        C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                        constraintName,
                                        ReuseFactory.getInteger(DataDictionary.CHECK_CONSTRAINT),
                                        rclList,
                                        null,
                                        value,
                                        getStringSlicer().slice(
                                                beginToken.beginOffset,
                                                endToken.endOffset,true),
                                        getContextManager()
                                        );}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="spsRenameStatement">spsRenameStatement</A>
 */
  final public QueryTreeNode spsRenameStatement() throws ParseException, StandardException {
        QueryTreeNode qtn;
    jj_consume_token(RENAME);
    switch (jj_nt.kind) {
    case TABLE:
      qtn = renameTableStatement();
      break;
    case INDEX:
      qtn = renameIndexStatement();
      break;
    default:
      jj_la1[235] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return qtn;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="renameTableStatement">renameTableStatement</A>
 */
  final public QueryTreeNode renameTableStatement() throws ParseException, StandardException {
        QueryTreeNode qtn;
        TableName tableName;
        String newTableName;
    jj_consume_token(TABLE);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    jj_consume_token(TO);
    newTableName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.RENAME_NODE,
                                                                tableName,
                                                                null,
                                                                newTableName,
                                                                Boolean.FALSE,
                                                                ReuseFactory.getInteger(StatementType.RENAME_TABLE),
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="renameIndexStatement">renameIndexStatement</A>
 */
  final public QueryTreeNode renameIndexStatement() throws ParseException, StandardException {
        String oldIndexName;
        String newIndexName;
    jj_consume_token(INDEX);
    oldIndexName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
    jj_consume_token(TO);
    newIndexName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                QueryTreeNode qtn = nodeFactory.getNode(
                                                                C_NodeTypes.RENAME_NODE,
                                                                null,
                                                                oldIndexName,
                                                                newIndexName,
                                                                Boolean.FALSE,
ReuseFactory.getInteger(StatementType.RENAME_INDEX),
                                                                getContextManager());

                {if (true) return qtn;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode lockStatement() throws ParseException, StandardException {
        Boolean                                         exclusiveMode;
        TableName                                       tableName;
    jj_consume_token(LOCK);
    jj_consume_token(TABLE);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    jj_consume_token(IN);
    exclusiveMode = lockMode();
    jj_consume_token(MODE);
                {if (true) return nodeFactory.getNode(
                                                                C_NodeTypes.LOCK_TABLE_NODE,
                                                                tableName,
                                                                exclusiveMode,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public Boolean lockMode() throws ParseException {
    switch (jj_nt.kind) {
    case EXCLUSIVE:
      jj_consume_token(EXCLUSIVE);
                {if (true) return Boolean.TRUE;}
      break;
    case SHARE:
      jj_consume_token(SHARE);
                {if (true) return Boolean.FALSE;}
      break;
    default:
      jj_la1[236] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode execStatement() throws ParseException, StandardException {
        TableName       stmtName;
    jj_consume_token(EXECUTE);
    jj_consume_token(STATEMENT);
    stmtName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.EXEC_SPS_NODE,
                                                                stmtName,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public TransactionStatementNode setIsolationStatement() throws ParseException, StandardException {
        TransactionStatementNode tranNode;
    setIsolationHeader();
    switch (jj_nt.kind) {
    case TO:
    case EQUALS_OPERATOR:
      switch (jj_nt.kind) {
      case EQUALS_OPERATOR:
        jj_consume_token(EQUALS_OPERATOR);
        break;
      case TO:
        jj_consume_token(TO);
        break;
      default:
        jj_la1[237] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[238] = jj_gen;
      ;
    }
    tranNode = transactionMode();
                {if (true) return tranNode;}
    throw new Error("Missing return statement in function");
  }

  final public void setIsolationHeader() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case ISOLATION:
      jj_consume_token(ISOLATION);
      break;
    default:
      jj_la1[239] = jj_gen;
      if (getToken(1).kind == CURRENT && getToken(2).kind == ISOLATION) {
        jj_consume_token(CURRENT);
        jj_consume_token(ISOLATION);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public TransactionStatementNode transactionMode() throws ParseException, StandardException {
        int isolationLevel;
    isolationLevel = isolationLevelDB2OrReset();
                {if (true) return (TransactionStatementNode) nodeFactory.getNode(
                                                                C_NodeTypes.SET_TRANSACTION_ISOLATION_NODE,
                                                                ReuseFactory.getInteger(isolationLevel),
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public int isolationLevelDB2OrReset() throws ParseException {
        int isolationLevel;
    switch (jj_nt.kind) {
    case RESET:
      jj_consume_token(RESET);
                          {if (true) return ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;}
      break;
    default:
      jj_la1[240] = jj_gen;
      if (jj_2_41(1)) {
        isolationLevel = isolationLevelDB2();
                                                         {if (true) return isolationLevel;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public int isolationLevelDB2() throws ParseException {
        int isolationLevel;
    switch (jj_nt.kind) {
    case CS:
    case RR:
    case RS:
    case UR:
      isolationLevel = isolationLevelDB2Abbrev();
                                                             {if (true) return isolationLevel;}
      break;
    case REPEATABLE:
    case SERIALIZABLE:
      switch (jj_nt.kind) {
      case REPEATABLE:
        jj_consume_token(REPEATABLE);
        jj_consume_token(READ);
        break;
      case SERIALIZABLE:
        jj_consume_token(SERIALIZABLE);
        break;
      default:
        jj_la1[241] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                          {if (true) return ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL;}
      break;
    case CURSOR:
      jj_consume_token(CURSOR);
      jj_consume_token(STABILITY);
                          {if (true) return ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL;}
      break;
    case DIRTY:
      jj_consume_token(DIRTY);
      jj_consume_token(READ);
                          {if (true) return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;}
      break;
    default:
      jj_la1[242] = jj_gen;
      if (getToken(1).kind == READ && getToken(2).kind == COMMITTED) {
        jj_consume_token(READ);
        jj_consume_token(COMMITTED);
                          {if (true) return ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL;}
      } else if (getToken(1).kind == READ && getToken(2).kind == UNCOMMITTED) {
        jj_consume_token(READ);
        jj_consume_token(UNCOMMITTED);
                          {if (true) return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public int isolationLevelDB2Abbrev() throws ParseException {
    switch (jj_nt.kind) {
    case RR:
      jj_consume_token(RR);
                          {if (true) return ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL;}
      break;
    case RS:
      jj_consume_token(RS);
                         {if (true) return ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL;}
      break;
    case CS:
      jj_consume_token(CS);
                          {if (true) return ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL;}
      break;
    case UR:
      jj_consume_token(UR);
                          {if (true) return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;}
      break;
    default:
      jj_la1[243] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int isolationLevel() throws ParseException {
        int isolationLevel;
    jj_consume_token(ISOLATION);
    jj_consume_token(LEVEL);
    isolationLevel = levelOfIsolation();
                {if (true) return isolationLevel;}
    throw new Error("Missing return statement in function");
  }

  final public int levelOfIsolation() throws ParseException {
    switch (jj_nt.kind) {
    case READ:
      jj_consume_token(READ);
                {if (true) return levelOfIsolationRead();}
      break;
    case REPEATABLE:
      jj_consume_token(REPEATABLE);
      jj_consume_token(READ);
                {if (true) return ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL;}
      break;
    case SERIALIZABLE:
      jj_consume_token(SERIALIZABLE);
                {if (true) return ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL;}
      break;
    default:
      jj_la1[244] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int levelOfIsolationRead() throws ParseException {
    switch (jj_nt.kind) {
    case UNCOMMITTED:
      jj_consume_token(UNCOMMITTED);
                {if (true) return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;}
      break;
    case COMMITTED:
      jj_consume_token(COMMITTED);
                {if (true) return ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL;}
      break;
    default:
      jj_la1[245] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="simpleValueSpecification">simpleValueSpecification</A>
 */
  final public ValueNode simpleValueSpecification() throws ParseException, StandardException {
        ValueNode       value;
    value = literal();
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode setSchemaStatement() throws ParseException, StandardException {
        QueryTreeNode setSchema = null;
    setSchemaHeader();
    switch (jj_nt.kind) {
    case EQUALS_OPERATOR:
      jj_consume_token(EQUALS_OPERATOR);
      break;
    default:
      jj_la1[246] = jj_gen;
      ;
    }
    setSchema = setSchemaValues();
                if (parameterList != null && parameterList.size() > 0)
                {
                        setUpAndLinkParameters();
                        // set the type of parameter node, it should be a varchar max Limits.MAX_IDENTIFIER_LENGTH - non nullable
                        ParameterNode p = (ParameterNode)parameterList.elementAt(0);
                        p.setDescriptor(new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), false, Limits.MAX_IDENTIFIER_LENGTH));
                }
                {if (true) return setSchema;}
    throw new Error("Missing return statement in function");
  }

  final public void setSchemaHeader() throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case SCHEMA:
      jj_consume_token(SCHEMA);
      break;
    default:
      jj_la1[248] = jj_gen;
      if (getToken(1).kind == CURRENT && ( getToken(2).kind == SCHEMA ||  getToken(2).kind == SQLID )) {
        jj_consume_token(CURRENT);
        switch (jj_nt.kind) {
        case SCHEMA:
          jj_consume_token(SCHEMA);
          break;
        case SQLID:
          jj_consume_token(SQLID);
          break;
        default:
          jj_la1[247] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public QueryTreeNode setSchemaValues() throws ParseException, StandardException {
        String schemaName;
    switch (jj_nt.kind) {
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.SET_SCHEMA_NODE,
                                                                schemaName,
                                                                null,
                                                                getContextManager());}
      break;
    case USER:
      jj_consume_token(USER);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.SET_SCHEMA_NODE,
                                                                null,
                                                                ReuseFactory.getInteger(StatementType.SET_SCHEMA_USER),
                                                                getContextManager());}
      break;
    case QUESTION_MARK:
      dynamicParameterSpecification();
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.SET_SCHEMA_NODE,
                                                                null,
                                                                ReuseFactory.getInteger(StatementType.SET_SCHEMA_DYNAMIC),
                                                                getContextManager());}
      break;
    case STRING:
      schemaName = string();
                /* Max length for schema name is Limits.MAX_IDENTIFIER_LENGTH */
                checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.SET_SCHEMA_NODE,
                                                                schemaName,
                                                                null,
                                                                getContextManager());}
      break;
    default:
      jj_la1[249] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// Set the locale for messages coming from the database system. This
// is for support only, so we can get messages in our preferred language
// (usually English). I didn't want to create all the execution wiring
// to do this, so this command executes in the parser
  final public QueryTreeNode setMessageLocaleStatement() throws ParseException, StandardException {
        String messageLocale;
    jj_consume_token(MESSAGE_LOCALE);
    messageLocale = string();
                getContextManager().setMessageLocale(messageLocale);

                {if (true) return nodeFactory.getNode(
                                                                                        C_NodeTypes.NOP_STATEMENT_NODE,
                                                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="valueSpecification">valueSpecification</A>
 */
  final public ValueNode valueSpecification() throws ParseException, StandardException {
        ValueNode          value;
        ValueNode          leftExpression;
        ValueNode          rightExpression;
    switch (jj_nt.kind) {
    case FALSE:
    case TRUE:
    case LEFT_BRACE:
    case PLUS_SIGN:
    case MINUS_SIGN:
    case EXACT_NUMERIC:
    case STRING:
    case HEX_STRING:
    case APPROXIMATE_NUMERIC:
      value = literal();
                {if (true) return value;}
      break;
    case CURRENT_USER:
    case SESSION_USER:
    case USER:
    case QUESTION_MARK:
      value = generalValueSpecification();
                {if (true) return value;}
      break;
    case NULLIF:
      jj_consume_token(NULLIF);
      jj_consume_token(LEFT_PAREN);
      leftExpression = additiveExpression(null, 0, false);
      jj_consume_token(COMMA);
      rightExpression = additiveExpression(null, 0, false);
      jj_consume_token(RIGHT_PAREN);
                // "NULLIF(L, R)" is the same as "L=R ? CAST(NULL AS CHAR(1)) : L"
                // An impl assumption here is that Cloudscape can promote CHAR to any comparable datatypes such as numeric
                ContextManager cm = getContextManager();
                ValueNodeList thenElseList = (ValueNodeList) nodeFactory.getNode(C_NodeTypes.VALUE_NODE_LIST, cm);

                thenElseList.addElement((ValueNode) nodeFactory.getNode(
                                                                        C_NodeTypes.CAST_NODE,
                                                                        (ValueNode) nodeFactory.getNode(C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE, cm),
                                                                        DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),
                                                                        cm));
                thenElseList.addElement(leftExpression);

                {if (true) return (ValueNode) nodeFactory.getNode(
                                                                                        C_NodeTypes.CONDITIONAL_NODE,
                                                                                        (ValueNode) nodeFactory.getNode(
                                                                                                                C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
                                                                                                                leftExpression,
                                                                                                                rightExpression,
                                                                                                                cm),
                                                                                        thenElseList,
                                                                                        cm);}
      break;
    case CASE:
      jj_consume_token(CASE);
      value = whenThenExpression();
                {if (true) return value;}
      break;
    default:
      jj_la1[250] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="caseExpression">caseExpression</A>
 */
  final public ValueNode caseExpression() throws ParseException, StandardException {
        ValueNode          expr;
    switch (jj_nt.kind) {
    case END:
      jj_consume_token(END);
                {if (true) return ((ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.CAST_NODE,
                                                                                (ValueNode) nodeFactory.getNode(C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                                                                                                getContextManager()),
                                                                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),
                                                                                getContextManager()));}
      break;
    case ELSE:
      jj_consume_token(ELSE);
      expr = thenElseExpression();
      jj_consume_token(END);
                {if (true) return expr;}
      break;
    case WHEN:
      expr = whenThenExpression();
                {if (true) return expr;}
      break;
    default:
      jj_la1[251] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="whenThenExpression">whenThenExpression</A>
 */
  final public ValueNode whenThenExpression() throws ParseException, StandardException {
        ValueNode          expr;
        ValueNode          thenExpr;
        ValueNode          elseExpr;
    jj_consume_token(WHEN);
    expr = orExpression(null, false);
    label_39:
    while (true) {
      switch (jj_nt.kind) {
      case OR:
        ;
        break;
      default:
        jj_la1[252] = jj_gen;
        break label_39;
      }
      jj_consume_token(OR);
      expr = orExpression(expr, false);
    }
    jj_consume_token(THEN);
    thenExpr = thenElseExpression();
    elseExpr = caseExpression();
                ContextManager cm = getContextManager();
                ValueNodeList thenElseList = (ValueNodeList) nodeFactory.getNode(C_NodeTypes.VALUE_NODE_LIST, cm);
                thenElseList.addElement(thenExpr); // then
                thenElseList.addElement(elseExpr); // else

                {if (true) return((ValueNode) nodeFactory.getNode(C_NodeTypes.CONDITIONAL_NODE,
                                                                                                expr,
                                                                                                thenElseList,
                                                                                                cm));}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="thenElseExpression">thenElseExpression</A>
 */
  final public ValueNode thenElseExpression() throws ParseException, StandardException {
        ValueNode          expr;
    if (getToken(1).kind == NULL) {
      jj_consume_token(NULL);
                {if (true) return((ValueNode) nodeFactory.getNode(
                                                                                C_NodeTypes.CAST_NODE,
                                                                                (ValueNode) nodeFactory.getNode(C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                                                                                                getContextManager()),
                                                                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),
                                                                                getContextManager()));}
    } else if (jj_2_42(1)) {
      expr = additiveExpression(null, 0, false);
                {if (true) return expr;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TableElementNode tableConstraintDefinition() throws ParseException, StandardException {
        Properties properties = null;
        ConstraintDefinitionNode tcdn;
        TableName               constraintName = null;
        //initialize following two booleans before handling table level constraints
        explicitNotNull = false;
        explicitNull = false;
    switch (jj_nt.kind) {
    case CONSTRAINT:
      constraintName = constraintNameDefinition();
      break;
    default:
      jj_la1[253] = jj_gen;
      ;
    }
    tcdn = tableConstraint(constraintName);
    switch (jj_nt.kind) {
    case PROPERTIES:
      properties = propertyList();
      break;
    default:
      jj_la1[254] = jj_gen;
      ;
    }
                if (properties != null)
                {
                        tcdn.setProperties(properties);
                }
                {if (true) return tcdn;}
    throw new Error("Missing return statement in function");
  }

  final public ConstraintDefinitionNode tableConstraint(TableName constraintName) throws ParseException, StandardException {
        ConstraintDefinitionNode tcdn;
    switch (jj_nt.kind) {
    case PRIMARY:
    case UNIQUE:
      tcdn = uniqueConstraintDefinition(constraintName);
                {if (true) return tcdn;}
      break;
    case FOREIGN:
      tcdn = referentialConstraintDefinition(constraintName);
                {if (true) return tcdn;}
      break;
    case CHECK:
      tcdn = checkConstraintDefinition(constraintName, null);
                {if (true) return tcdn;}
      break;
    default:
      jj_la1[255] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ConstraintDefinitionNode uniqueConstraintDefinition(TableName constraintName) throws ParseException, StandardException {
        int constraintType;
        ResultColumnList uniqueColumnList;
    //for table level constraint, second parameter will be null
            constraintType = uniqueSpecification((DataTypeDescriptor) null, null);
    jj_consume_token(LEFT_PAREN);
    uniqueColumnList = uniqueColumnList();
    jj_consume_token(RIGHT_PAREN);
                //go through the unique columns list and if any of the columns in the
                //list is explicitly defined null, throw an exception for this. Columns
                //for which no nullability is defined are by default nullable. But in
                //case of create table, there nullability changes automatically to 
                //non-nullable if primary key is defined on it. But if user explicitly
                //defines the nullability, then defining a primary key on it in create
                //table will result in an exception.
                if (constraintType ==  DataDictionary.PRIMARYKEY_CONSTRAINT)
                {
                        for (int index = 0; index < uniqueColumnList.size(); index++)
                        {
                                String primaryKeyColumnName = ((ResultColumn) uniqueColumnList.elementAt(index)).getName();
                                if (explicitlyNullableColumnsList.contains(primaryKeyColumnName))
                                {
                                        String errorState = SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS;
                                        {if (true) throw StandardException.newException(errorState, primaryKeyColumnName);}
                                }
                        }
                }
                {if (true) return (ConstraintDefinitionNode) nodeFactory.getNode(
                                                C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                constraintName,
                                                ReuseFactory.getInteger(constraintType),
                                                uniqueColumnList,
                                                null,
                                                null,
                                                null,
                                                getContextManager()
                                                );}
    throw new Error("Missing return statement in function");
  }

//the second parameter to the following method will always be null for a table level
//constraint but not for a column level constraint
  final public int uniqueSpecification(DataTypeDescriptor dataTypeDescriptor,
String columnName) throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case UNIQUE:
      jj_consume_token(UNIQUE);
                {if (true) return DataDictionary.UNIQUE_CONSTRAINT;}
      break;
    case PRIMARY:
      jj_consume_token(PRIMARY);
      jj_consume_token(KEY);
                //explicitNull can be true only if it's column level constraint and
                //that column has null constraint defined on it. In that case, defining
                //a column-level constraint of primary key on it will result in an error.
                if (explicitNull)
                {
                        String errorState = SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS;
                        {if (true) throw StandardException.newException(errorState, columnName);}
                }
                {if (true) return DataDictionary.PRIMARYKEY_CONSTRAINT;}
      break;
    default:
      jj_la1[256] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ResultColumnList uniqueColumnList() throws ParseException, StandardException {
        ResultColumnList        resultColumns = (ResultColumnList) nodeFactory.getNode(
                                                                                        C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                        getContextManager());
    columnNameList(resultColumns);
                {if (true) return resultColumns;}
    throw new Error("Missing return statement in function");
  }

  final public ConstraintDefinitionNode referentialConstraintDefinition(TableName constraintName) throws ParseException, StandardException {
        ResultColumnList fkRcl = (ResultColumnList) nodeFactory.getNode(
                                                                                C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                getContextManager());
        ResultColumnList refRcl = (ResultColumnList) nodeFactory.getNode(
                                                                                C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                getContextManager());
        TableName referencedTable;
        int[] refActions = {StatementType.RA_NOACTION,
                            StatementType.RA_NOACTION};
    jj_consume_token(FOREIGN);
    jj_consume_token(KEY);
    jj_consume_token(LEFT_PAREN);
    columnNameList(fkRcl);
    jj_consume_token(RIGHT_PAREN);
    referencedTable = referencesSpecification(refRcl, refActions);
                {if (true) return (ConstraintDefinitionNode) nodeFactory.getNode(
                                                C_NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
                                                constraintName,
                                                referencedTable,
                                                fkRcl,
                                                refRcl,
                                                refActions,
                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public TableName referencesSpecification(ResultColumnList rcl, int[] refActions) throws ParseException, StandardException {
        TableName tableName = null;
    jj_consume_token(REFERENCES);
    tableName = referencedTableAndColumns(rcl);
    switch (jj_nt.kind) {
    case ON:
      jj_consume_token(ON);
      referentialTriggeredAction(refActions);
      break;
    default:
      jj_la1[257] = jj_gen;
      ;
    }
                {if (true) return tableName;}
    throw new Error("Missing return statement in function");
  }

  final public TableName referencedTableAndColumns(ResultColumnList rcl) throws ParseException, StandardException {
        TableName       tableName = null;
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    switch (jj_nt.kind) {
    case LEFT_PAREN:
      jj_consume_token(LEFT_PAREN);
      columnNameList(rcl);
      jj_consume_token(RIGHT_PAREN);
      break;
    default:
      jj_la1[258] = jj_gen;
      ;
    }
                {if (true) return tableName;}
    throw new Error("Missing return statement in function");
  }

  final public void referentialTriggeredAction(int [] refActions) throws ParseException, StandardException {
    switch (jj_nt.kind) {
    case UPDATE:
      refActions[1] = updateRule();
      switch (jj_nt.kind) {
      case ON:
        jj_consume_token(ON);
        refActions[0] = deleteRule();
        break;
      default:
        jj_la1[259] = jj_gen;
        ;
      }
      break;
    case DELETE:
      refActions[0] = deleteRule();
      switch (jj_nt.kind) {
      case ON:
        jj_consume_token(ON);
        refActions[1] = updateRule();
        break;
      default:
        jj_la1[260] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[261] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public int updateRule() throws ParseException {
        int action;
    jj_consume_token(UPDATE);
    action = updateReferentialAction();
                {if (true) return action;}
    throw new Error("Missing return statement in function");
  }

  final public int deleteRule() throws ParseException {
        int action;
    jj_consume_token(DELETE);
    action = deleteReferentialAction();
                {if (true) return action;}
    throw new Error("Missing return statement in function");
  }

  final public int updateReferentialAction() throws ParseException {
    switch (jj_nt.kind) {
    case RESTRICT:
      jj_consume_token(RESTRICT);
                      {if (true) return StatementType.RA_RESTRICT;}
      break;
    case NO:
      jj_consume_token(NO);
      jj_consume_token(ACTION);
                         {if (true) return StatementType.RA_NOACTION;}
      break;
    default:
      jj_la1[262] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int deleteReferentialAction() throws ParseException {
    switch (jj_nt.kind) {
    case CASCADE:
      jj_consume_token(CASCADE);
                   {if (true) return StatementType.RA_CASCADE;}
      break;
    case RESTRICT:
      jj_consume_token(RESTRICT);
                      {if (true) return StatementType.RA_RESTRICT;}
      break;
    case NO:
      jj_consume_token(NO);
      jj_consume_token(ACTION);
                         {if (true) return StatementType.RA_NOACTION;}
      break;
    case SET:
      jj_consume_token(SET);
      switch (jj_nt.kind) {
      case NULL:
        jj_consume_token(NULL);
                      {if (true) return StatementType.RA_SETNULL;}
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
                            {if (true) return StatementType.RA_SETDEFAULT;}
        break;
      default:
        jj_la1[263] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[264] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="columnConstraintDefinition">columnConstraintDefinition</A>
 */
  final public void columnConstraintDefinition(DataTypeDescriptor dataTypeDescriptor,
                                                   TableElementList tableElementList,
                                                   String columnName) throws ParseException, StandardException {
        int constraintType;
        TableElementNode tcdn;
        TableName constraintName = null;
    switch (jj_nt.kind) {
    case CONSTRAINT:
      constraintName = constraintNameDefinition();
      break;
    default:
      jj_la1[265] = jj_gen;
      ;
    }
    tcdn = columnConstraint(constraintName, dataTypeDescriptor, columnName);
                /* NOT NULL constraints are handled by marking the dataTypeDescriptor
		 * as being non-nullable.
		 */
                if (tcdn == null)
                {
                        {if (true) return;}
                }

                /* All other constraints, whether column or table will be added as
		 * table constraints.  We do this to facilitate the handling of
		 * multiple column constraints on the same column.
		 */
                tableElementList.addTableElement(tcdn);
  }

/*
 * <A NAME="columnConstraint">columnConstraint</A>
 */
  final public ConstraintDefinitionNode columnConstraint(TableName constraintName,
                                 DataTypeDescriptor dataTypeDescriptor,
                                 String columnName) throws ParseException, StandardException {
        int constraintType;
        Properties properties = null;
        ConstraintDefinitionNode tcdn;
        ResultColumnList refRcl = (ResultColumnList) nodeFactory.getNode(
                                                                                C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                getContextManager());
        TableName referencedTable;
        int[] refActions = {StatementType.RA_NOACTION,
                            StatementType.RA_NOACTION} ;
    switch (jj_nt.kind) {
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(NULL);
                //if column is explicitly defined not nullable, set following flag
                explicitNotNull = true;
                //if both null and not null constraints are defined for a column,
                //throw an exception
                if (explicitNull)
                   {if (true) throw StandardException.newException(SQLState.LANG_ADDING_COLUMN_WITH_NULL_AND_NOT_NULL_CONSTRAINT, columnName);}
                dataTypeDescriptor.setNullability(false);
                {if (true) return null;}
      break;
    case PRIMARY:
    case UNIQUE:
      //pass the columnname as the second parameter. It will be used to throw an
              //exception if null constraint is defined for this column-level primary 
              //key constraint
              constraintType = uniqueSpecification(dataTypeDescriptor,columnName);
      switch (jj_nt.kind) {
      case PROPERTIES:
        properties = propertyList();
        break;
      default:
        jj_la1[266] = jj_gen;
        ;
      }
                ResultColumnList uniqueColumnList =
                                                                                (ResultColumnList) nodeFactory.getNode(
                                                                                                C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                                getContextManager());
                uniqueColumnList.addElement(
                        (ResultColumn) nodeFactory.getNode(
                                                        C_NodeTypes.RESULT_COLUMN,
                                                        columnName,
                                                        null,
                                                        getContextManager()));

                {if (true) return (ConstraintDefinitionNode) nodeFactory.getNode(
                                                C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                constraintName,
                                                ReuseFactory.getInteger(constraintType),
                                                uniqueColumnList,
                                                properties,
                                                null,
                                                null,
                                                getContextManager()
                                                );}
      break;
    case REFERENCES:
      referencedTable = referencesSpecification(refRcl, refActions);
      switch (jj_nt.kind) {
      case PROPERTIES:
        properties = propertyList();
        break;
      default:
        jj_la1[267] = jj_gen;
        ;
      }
                ResultColumnList fkRcl = (ResultColumnList) nodeFactory.getNode(
                                                                                        C_NodeTypes.RESULT_COLUMN_LIST,
                                                                                        getContextManager());
                fkRcl.addElement(
                                        (ResultColumn) nodeFactory.getNode(
                                                                        C_NodeTypes.RESULT_COLUMN,
                                                                        columnName,
                                                                        null,
                                                                        getContextManager())
                                );
                tcdn = (ConstraintDefinitionNode) nodeFactory.getNode(
                                                C_NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
                                                constraintName,
                                                referencedTable,
                                                fkRcl,
                                                refRcl,
                                                refActions,
                                                getContextManager());
                if (properties != null)
                {
                        tcdn.setProperties(properties);
                }
                {if (true) return tcdn;}
      break;
    case CHECK:
      tcdn = checkConstraintDefinition(constraintName, columnName);
                {if (true) return tcdn;}
      break;
    default:
      jj_la1[268] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode dropSchemaStatement() throws ParseException, StandardException {
        String schemaName;
    jj_consume_token(SCHEMA);
    schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
    jj_consume_token(RESTRICT);
                QueryTreeNode stmt =  nodeFactory.getNode(
                                                        C_NodeTypes.DROP_SCHEMA_NODE,
                                                        schemaName,
                                                        new Integer(StatementType.DROP_RESTRICT),
                                                        getContextManager());

                {if (true) return stmt;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode alterTableStatement() throws ParseException, StandardException {
        QueryTreeNode           node;
        TableName                       tableName;
    jj_consume_token(TABLE);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
    node = alterTableBody(tableName);
                {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode alterTableBody(TableName tableName) throws ParseException, StandardException {
        QueryTreeNode qtn;
        char                            lockGranularity = '\0';
        String               newTableName;
        TableElementList        tableElementList =
                                                                        (TableElementList) nodeFactory.getNode(
                                                                                                C_NodeTypes.TABLE_ELEMENT_LIST,
                                                                                                getContextManager());
        Token                           tok = null;
        int[]                           changeType = new int[1];
        int[]                           behavior = new int[1];
        boolean[]                       sequential = new boolean[1];
    switch (jj_nt.kind) {
    case COMPRESS:
      jj_consume_token(COMPRESS);
      switch (jj_nt.kind) {
      case SEQUENTIAL:
        tok = jj_consume_token(SEQUENTIAL);
        break;
      default:
        jj_la1[269] = jj_gen;
        ;
      }
                checkInternalFeature("COMPRESS");
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                        C_NodeTypes.ALTER_TABLE_NODE,
                                                        tableName,
                                                        new Boolean(tok != null),
                                                        getContextManager());}
      break;
    default:
      jj_la1[270] = jj_gen;
      if (jj_2_43(1)) {
        lockGranularity = alterTableAction(tableElementList, changeType, behavior, sequential);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                        C_NodeTypes.ALTER_TABLE_NODE,
                                                        tableName,
                                                        tableElementList,
                                                        new Character(lockGranularity),
                                                        changeType,
                                                        behavior,
                                                        sequential,
                                                        getContextManager());}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="alterTableRenameTableStatement">alterTableRenameTableStatement</A>
 */
/*
QueryTreeNode
alterTableRenameTableStatement(TableName tableName) throws StandardException :
{
	String newTableName;
}
{
	<TO> newTableName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return (QueryTreeNode) nodeFactory.getNode(
							C_NodeTypes.RENAME_NODE,
							tableName,
							null,
							newTableName,
							Boolean.TRUE,
ReuseFactory.getInteger(StatementType.RENAME_TABLE),
							getContextManager());
	}
}
*/

/*
 * <A NAME="alterTableRenameColumnStatement">alterTableRenameColumnStatement</A>
 */
/*
QueryTreeNode
alterTableRenameColumnStatement(TableName tableName) throws StandardException :
{
	String oldColumnName;
	String newColumnName;
}
{
	oldColumnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) <TO> newColumnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return (QueryTreeNode) nodeFactory.getNode(
							C_NodeTypes.RENAME_NODE,
							tableName,
							oldColumnName,
							newColumnName,
							Boolean.TRUE,
ReuseFactory.getInteger(StatementType.RENAME_COLUMN),
							getContextManager());
	}
}
*/
  final public char alterTableAction(TableElementList tableElementList, int[] changeType, int[] behavior, boolean[] sequential) throws ParseException, StandardException {
        char                            lockGranularity = '\0';
        TableElementNode        tableElement;
        DataTypeDescriptor      typeDescriptor;
        Token                           tok = null;
        String                          columnName;
        long[]                          autoIncrementInfo = new long[3];
    switch (jj_nt.kind) {
    case ADD:
      jj_consume_token(ADD);
      switch (jj_nt.kind) {
      case BINARY:
      case COALESCE:
      case COLUMN:
      case D:
      case MODULE:
      case T:
      case TS:
      case VALUE:
      case VARBINARY:
      case ABS:
      case ABSVAL:
      case ACTION:
      case ALWAYS:
      case BLOB:
      case C:
      case CALLED:
      case CLOB:
      case COBOL:
      case COMMITTED:
      case CONCAT:
      case CONTAINS:
      case DATA:
      case DATE:
      case DAY:
      case DYNAMIC:
      case FORTRAN:
      case GENERATED:
      case IDENTITY_VAL_LOCAL:
      case INCREMENT:
      case INITIAL:
      case INTERVAL:
      case LANGUAGE:
      case LARGE:
      case LENGTH:
      case LEVEL:
      case LOCKS:
      case LOCKSIZE:
      case LOGGED:
      case MOD:
      case MODIFIES:
      case MODIFY:
      case MONTH:
      case _MORE:
      case MUMPS:
      case NAME:
      case NCLOB:
      case NULLABLE:
      case NUMBER:
      case OBJECT:
      case PASCAL:
      case PLI:
      case PRECISION:
      case RELEASE:
      case REPEATABLE:
      case RETURNS:
      case ROW:
      case SAVEPOINT:
      case SCALE:
      case SERIALIZABLE:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_HOUR:
      case SQL_TSI_DAY:
      case SQL_TSI_WEEK:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case START:
      case STATEMENT:
      case SYNONYM:
      case THEN:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TRUNCATE:
      case TYPE:
      case UNCOMMITTED:
      case USAGE:
      case WHEN:
      case CURDATE:
      case CURTIME:
      case DATABASE:
      case LONG:
      case AFTER:
      case BEFORE:
      case CLASS:
      case COMPRESS:
      case CONTENT:
      case CS:
      case DB2SQL:
      case DIRTY:
      case DOCUMENT:
      case EACH:
      case EXCLUSIVE:
      case FN:
      case INDEX:
      case JAVA:
      case LCASE:
      case LOCATE:
      case LOCK:
      case MESSAGE_LOCALE:
      case METHOD:
      case MODE:
      case NEW:
      case NEW_TABLE:
      case OJ:
      case OFF:
      case OLD:
      case OLD_TABLE:
      case PARAMETER:
      case PASSING:
      case PROPERTIES:
      case READS:
      case REF:
      case REFERENCING:
      case RENAME:
      case RESET:
      case RESULT:
      case RETAIN:
      case RR:
      case RS:
      case SEQUENTIAL:
      case SETS:
      case SHARE:
      case SQLID:
      case SPECIFIC:
      case SQRT:
      case STABILITY:
      case STRIP:
      case STYLE:
      case TRIGGER:
      case UCASE:
      case UR:
      case WHITESPACE:
      case IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        tableElement = addColumnDefinition(tableElementList);
        break;
      case CHECK:
      case CONSTRAINT:
      case FOREIGN:
      case PRIMARY:
      case UNIQUE:
        tableElement = tableConstraintDefinition();
        break;
      default:
        jj_la1[271] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                if (tableElement instanceof ColumnDefinitionNode)
                {
                        //bug 5724 - auto increment columns not allowed in ALTER TABLE statement
                        ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElement;
                        if ( cdn.isAutoincrementColumn())
                                {if (true) throw StandardException.newException(SQLState.LANG_ALTER_TABLE_AUTOINCREMENT_COLUMN_NOT_ALLOWED);}
                }
                changeType[0] = CreateStatementNode.ADD_TYPE;
                tableElementList.addTableElement(tableElement);
                {if (true) return lockGranularity;}
      break;
    case ALTER:
      jj_consume_token(ALTER);
      switch (jj_nt.kind) {
      case COLUMN:
        jj_consume_token(COLUMN);
        break;
      default:
        jj_la1[272] = jj_gen;
        ;
      }
      columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
      jj_consume_token(SET);
      typeDescriptor = DB2AlterColumn(autoIncrementInfo);
                changeType[0] = CreateStatementNode.MODIFY_TYPE;
                /* typeDescriptor is not null for MODIFY_COLUMN_TYPE_NODE */
                if (typeDescriptor != null)
                        tableElementList.addTableElement((TableElementNode) nodeFactory.getNode(
                                                C_NodeTypes.MODIFY_COLUMN_TYPE_NODE,
                                                columnName, null,
                                                typeDescriptor, null,
                                                getContextManager()));
                else
                        tableElementList.addTableElement((TableElementNode) nodeFactory.getNode(
                                                C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
                                                columnName,
                                                null, null, autoIncrementInfo,
                                                getContextManager()));
                {if (true) return lockGranularity;}
      break;
    default:
      jj_la1[273] = jj_gen;
      if (getToken(1).kind == DROP
                      && (getToken(2).kind == CONSTRAINT
                              || getToken(2).kind == PRIMARY
                              || getToken(2).kind == FOREIGN
                              || getToken(2).kind == UNIQUE
                              || getToken(2).kind == CHECK)) {
        tableElement = dropTableConstraintDefinition();
                changeType[0] = CreateStatementNode.DROP_TYPE;
                tableElementList.addTableElement(tableElement);
                {if (true) return lockGranularity;}
      } else {
        switch (jj_nt.kind) {
        case LOCKSIZE:
          lockGranularity = DB2lockGranularityClause();
                changeType[0] = CreateStatementNode.LOCKING_TYPE;
                {if (true) return lockGranularity;}
          break;
        default:
          jj_la1[274] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public TableElementNode addColumnDefinition(TableElementList tableElementList) throws ParseException, StandardException {
        TableElementNode        tableElement;
    switch (jj_nt.kind) {
    case COLUMN:
      jj_consume_token(COLUMN);
      break;
    default:
      jj_la1[275] = jj_gen;
      ;
    }
    tableElement = columnDefinition(tableElementList);
                {if (true) return tableElement;}
    throw new Error("Missing return statement in function");
  }

  final public TableElementNode columnAlter() throws ParseException, StandardException {
        String columnName;
        TableElementNode tn;
    columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
    tn = columnAlterClause(columnName);
                {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public TableElementNode columnAlterClause(String columnName) throws ParseException, StandardException {
        ValueNode       defaultNode;
        DataTypeDescriptor typeDescriptor;
        long[]                          autoIncrementInfo = new long[3];
    if (getToken(1).kind == WITH || getToken(1).kind == _DEFAULT) {
      defaultNode = defaultClause(autoIncrementInfo, columnName);
                if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX]
                                 == 0)
                {
                        autoIncrementInfo = null;
                }

                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                                C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
                                                                columnName,
                                                                defaultNode, null, autoIncrementInfo,
                                                                getContextManager());}
    } else if (getToken(1).kind == NULL) {
      jj_consume_token(NULL);
                // for a MODIFY column NULL clause form a modify_column node
                // with all null values. In a column definition a [NOT] NULL
                // column constraint is specified by setting the right value
                // in the nullability field of the data type but we don't have
                // a datatype here.
                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                                C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE,
                                                                columnName, null, null, null,
                                                                getContextManager());}
    } else if (getToken(1).kind == NOT) {
      jj_consume_token(NOT);
      jj_consume_token(NULL);
                // for a MODIFY column NOT NULL clause form a modify_column node
                // with all null values. In a column definition a [NOT] NULL
                // column constraint is specified by setting the right value
                // in the nullability field of the data type but we don't have
                // a datatype here.
                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                                C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NOT_NULL_NODE,
                                                                columnName, null, null, null,
                                                                getContextManager());}
    } else if (jj_2_44(1)) {
      // MODIFY column_name varchar(64)
              typeDescriptor = dataTypeDDL();
                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                                C_NodeTypes.MODIFY_COLUMN_TYPE_NODE,
                                                                columnName,
                                                                null, typeDescriptor, null,
                                                                getContextManager());}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * DB2 syntax for ALTER COLUMN
 */
  final public DataTypeDescriptor DB2AlterColumn(long[] autoIncrementInfo) throws ParseException, StandardException {
        long                            autoIncrementIncrement = 1;
        DataTypeDescriptor      typeDescriptor = null;
    switch (jj_nt.kind) {
    case DATA:
      jj_consume_token(DATA);
      jj_consume_token(TYPE);
      typeDescriptor = dataTypeDDL();
                {if (true) return typeDescriptor;}
      break;
    case INCREMENT:
      jj_consume_token(INCREMENT);
      jj_consume_token(BY);
      autoIncrementIncrement = exactNumber();
                autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
                {if (true) return typeDescriptor;}
      break;
    default:
      jj_la1[276] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TableElementNode dropTableConstraintDefinition() throws ParseException, StandardException {
        TableName                constraintName;
    if (getToken(2).kind == CONSTRAINT) {
      jj_consume_token(DROP);
      jj_consume_token(CONSTRAINT);
      constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                constraintName,
                                                ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
                                                null,
                                                null,
                                                null,
                                                null,
                                                ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
                                                getContextManager()
                                                );}
    } else if (getToken(2).kind == PRIMARY) {
      jj_consume_token(DROP);
      jj_consume_token(PRIMARY);
      jj_consume_token(KEY);
                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                null,
                                                ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
                                                null,
                                                null,
                                                null,
                                                null,
                                                ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
                                                getContextManager()
                                                );}
    } else if (getToken(2).kind == FOREIGN) {
      jj_consume_token(DROP);
      jj_consume_token(FOREIGN);
      jj_consume_token(KEY);
      constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                constraintName,
                                                ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
                                                null,
                                                null,
                                                null,
                                                null,
                                                ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
                                                ReuseFactory.getInteger(DataDictionary.FOREIGNKEY_CONSTRAINT),
                                                getContextManager()
                                                );}
    } else if (getToken(2).kind == UNIQUE) {
      jj_consume_token(DROP);
      jj_consume_token(UNIQUE);
      constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                constraintName,
                                                ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
                                                null,
                                                null,
                                                null,
                                                null,
                                                ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
                                                ReuseFactory.getInteger(DataDictionary.UNIQUE_CONSTRAINT),
                                                getContextManager()
                                                );}
    } else {
      switch (jj_nt.kind) {
      case DROP:
        jj_consume_token(DROP);
        jj_consume_token(CHECK);
        constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (TableElementNode) nodeFactory.getNode(
                                                C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                constraintName,
                                                ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
                                                null,
                                                null,
                                                null,
                                                null,
                                                ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
                                                ReuseFactory.getInteger(DataDictionary.CHECK_CONSTRAINT),
                                                getContextManager()
                                                );}
        break;
      default:
        jj_la1[277] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dropTableStatement">dropTableStatement</A>
 */
  final public QueryTreeNode dropTableStatement() throws ParseException, StandardException {
        TableName tableName;
    jj_consume_token(TABLE);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                // DB2 does not support a drop behaviour
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                                        C_NodeTypes.DROP_TABLE_NODE,
                                                                                        tableName,
                                                                                        new Integer(StatementType.DROP_DEFAULT),
                                                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dropIndexStatement">dropIndexStatement</A>
 */
  final public QueryTreeNode dropIndexStatement() throws ParseException, StandardException {
        TableName indexName;
    jj_consume_token(INDEX);
    indexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.DROP_INDEX_NODE,
                                                                indexName,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="dropAliasStatement">dropAliasStatement</A>
 */
  final public QueryTreeNode dropAliasStatement() throws ParseException, StandardException {
        Object aliasName;
    switch (jj_nt.kind) {
    case PROCEDURE:
      jj_consume_token(PROCEDURE);
      aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR);}
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
      aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR);}
      break;
    case SYNONYM:
      jj_consume_token(SYNONYM);
      aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "DROP SYNONYM");

                {if (true) return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR);}
      break;
    default:
      jj_la1[278] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode dropViewStatement() throws ParseException, StandardException {
        TableName viewName;
    jj_consume_token(VIEW);
    viewName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.DROP_VIEW_NODE,
                                                                viewName,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode dropTriggerStatement() throws ParseException, StandardException {
        TableName triggerName;
    jj_consume_token(TRIGGER);
    triggerName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                                C_NodeTypes.DROP_TRIGGER_NODE,
                                                                triggerName,
                                                                getContextManager());}
    throw new Error("Missing return statement in function");
  }

  final public QueryTreeNode truncateTableStatement() throws ParseException, StandardException {
        TableName tableName;
    jj_consume_token(TRUNCATE);
    jj_consume_token(TABLE);
    tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
                {if (true) return (QueryTreeNode) nodeFactory.getNode(
                                                        C_NodeTypes.ALTER_TABLE_NODE,
                                                        tableName,
                                                        getContextManager());}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="identifier">identifier</A>
 */
  final public String internalIdentifier(int id_length_limit, boolean useANSICasing, boolean checkLength) throws ParseException, StandardException {
        String  str;
        Token   tok;
    switch (jj_nt.kind) {
    case IDENTIFIER:
      tok = jj_consume_token(IDENTIFIER);
        if( useANSICasing)
            str = StringUtil.SQLToUpperCase(tok.image);
        else
            str = getLanguageConnectionContext().convertIdentifierCase( tok.image);
                if (checkLength) {//if checkLength false, then calling method would do the length limit checks
                        //limit the identifier to the id length limit passed to this method
                        checkIdentifierLengthLimit(str, id_length_limit);
                }
                // Remember whether last token was a delimited identifier
                nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
                lastTokenDelimitedIdentifier = Boolean.FALSE;
                nextToLastIdentifierToken = lastIdentifierToken;
                lastIdentifierToken = tok;
                {if (true) return str;}
      break;
    case DELIMITED_IDENTIFIER:
      str = delimitedIdentifier();
                if (checkLength) {//if checkLength false, then calling method would do the length limit checks
                        //limit the identifier to the id length limit passed to this method
                        checkIdentifierLengthLimit(str, id_length_limit);
                }
                {if (true) return str;}
      break;
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
      str = nonReservedKeyword();
                {if (true) return getLanguageConnectionContext().convertIdentifierCase( str);}
      break;
    default:
      jj_la1[279] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String identifier(int id_length_limit, boolean checkLength) throws ParseException, StandardException {
        String  id;
    id = internalIdentifier(id_length_limit, false, checkLength);
        {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="delimitedIdentifier">delimitedIdentifier</A>
 */
  final public String delimitedIdentifier() throws ParseException {
        String  str;
        Token   tok;
    tok = jj_consume_token(DELIMITED_IDENTIFIER);
                str = tok.image.substring(1, tok.image.length() -1);
                str = normalizeDelimitedID( str );
                // Remember whether last token was a delimited identifier
                nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
                lastTokenDelimitedIdentifier = Boolean.TRUE;
                nextToLastIdentifierToken = lastIdentifierToken;
                lastIdentifierToken = tok;

                {if (true) return str;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="reservedKeyword">reservedKeyword</A>
 */
  final public String reservedKeyword() throws ParseException {
        Token   tok;
    switch (jj_nt.kind) {
    case ADD:
      /* SQL92 reserved Keywords */
              tok = jj_consume_token(ADD);
      break;
    case ALL:
      tok = jj_consume_token(ALL);
      break;
    case ALLOCATE:
      tok = jj_consume_token(ALLOCATE);
      break;
    case ALTER:
      tok = jj_consume_token(ALTER);
      break;
    case AND:
      tok = jj_consume_token(AND);
      break;
    case ANY:
      tok = jj_consume_token(ANY);
      break;
    case ARE:
      tok = jj_consume_token(ARE);
      break;
    case AS:
      tok = jj_consume_token(AS);
      break;
    case ASC:
      tok = jj_consume_token(ASC);
      break;
    case ASSERTION:
      tok = jj_consume_token(ASSERTION);
      break;
    case AT:
      tok = jj_consume_token(AT);
      break;
    case AUTHORIZATION:
      tok = jj_consume_token(AUTHORIZATION);
      break;
    case AVG:
      tok = jj_consume_token(AVG);
      break;
    case BEGIN:
      tok = jj_consume_token(BEGIN);
      break;
    case BETWEEN:
      tok = jj_consume_token(BETWEEN);
      break;
    case BIT:
      tok = jj_consume_token(BIT);
      break;
    case BOTH:
      tok = jj_consume_token(BOTH);
      break;
    case BY:
      tok = jj_consume_token(BY);
      break;
    case CASCADE:
      tok = jj_consume_token(CASCADE);
      break;
    case CASCADED:
      tok = jj_consume_token(CASCADED);
      break;
    case CASE:
      tok = jj_consume_token(CASE);
      break;
    case CAST:
      tok = jj_consume_token(CAST);
      break;
    case CHAR:
      tok = jj_consume_token(CHAR);
      break;
    case CHARACTER:
      tok = jj_consume_token(CHARACTER);
      break;
    case CHECK:
      tok = jj_consume_token(CHECK);
      break;
    case CLOSE:
      tok = jj_consume_token(CLOSE);
      break;
    case COLLATE:
      tok = jj_consume_token(COLLATE);
      break;
    case COLLATION:
      tok = jj_consume_token(COLLATION);
      break;
    case COLUMN:
      tok = jj_consume_token(COLUMN);
      break;
    case COMMIT:
      tok = jj_consume_token(COMMIT);
      break;
    case CONNECT:
      tok = jj_consume_token(CONNECT);
      break;
    case CONNECTION:
      tok = jj_consume_token(CONNECTION);
      break;
    case CONSTRAINT:
      tok = jj_consume_token(CONSTRAINT);
      break;
    case CONSTRAINTS:
      tok = jj_consume_token(CONSTRAINTS);
      break;
    case CONTINUE:
      tok = jj_consume_token(CONTINUE);
      break;
    case CONVERT:
      tok = jj_consume_token(CONVERT);
      break;
    case CORRESPONDING:
      tok = jj_consume_token(CORRESPONDING);
      break;
    case COUNT:
      tok = jj_consume_token(COUNT);
      break;
    case CREATE:
      tok = jj_consume_token(CREATE);
      break;
    case CURRENT:
      tok = jj_consume_token(CURRENT);
      break;
    case CURRENT_DATE:
      tok = jj_consume_token(CURRENT_DATE);
      break;
    case CURRENT_TIME:
      tok = jj_consume_token(CURRENT_TIME);
      break;
    case CURRENT_TIMESTAMP:
      tok = jj_consume_token(CURRENT_TIMESTAMP);
      break;
    case CURRENT_USER:
      tok = jj_consume_token(CURRENT_USER);
      break;
    case CURSOR:
      tok = jj_consume_token(CURSOR);
      break;
    case DEALLOCATE:
      tok = jj_consume_token(DEALLOCATE);
      break;
    case DEC:
      tok = jj_consume_token(DEC);
      break;
    case DECIMAL:
      tok = jj_consume_token(DECIMAL);
      break;
    case DECLARE:
      tok = jj_consume_token(DECLARE);
      break;
    case _DEFAULT:
      tok = jj_consume_token(_DEFAULT);
      break;
    case DEFERRABLE:
      tok = jj_consume_token(DEFERRABLE);
      break;
    case DEFERRED:
      tok = jj_consume_token(DEFERRED);
      break;
    case DELETE:
      tok = jj_consume_token(DELETE);
      break;
    case DESC:
      tok = jj_consume_token(DESC);
      break;
    case DESCRIBE:
      tok = jj_consume_token(DESCRIBE);
      break;
    case DIAGNOSTICS:
      tok = jj_consume_token(DIAGNOSTICS);
      break;
    case DISCONNECT:
      tok = jj_consume_token(DISCONNECT);
      break;
    case DISTINCT:
      tok = jj_consume_token(DISTINCT);
      break;
    case DOUBLE:
      tok = jj_consume_token(DOUBLE);
      break;
    case DROP:
      tok = jj_consume_token(DROP);
      break;
    case ELSE:
      tok = jj_consume_token(ELSE);
      break;
    case END:
      tok = jj_consume_token(END);
      break;
    case ENDEXEC:
      tok = jj_consume_token(ENDEXEC);
      break;
    case ESCAPE:
      tok = jj_consume_token(ESCAPE);
      break;
    case EXCEPT:
      tok = jj_consume_token(EXCEPT);
      break;
    case EXCEPTION:
      tok = jj_consume_token(EXCEPTION);
      break;
    case EXEC:
      tok = jj_consume_token(EXEC);
      break;
    case EXECUTE:
      tok = jj_consume_token(EXECUTE);
      break;
    case EXISTS:
      tok = jj_consume_token(EXISTS);
      break;
    case EXTERNAL:
      tok = jj_consume_token(EXTERNAL);
      break;
    case FALSE:
      tok = jj_consume_token(FALSE);
      break;
    case FETCH:
      tok = jj_consume_token(FETCH);
      break;
    case FIRST:
      tok = jj_consume_token(FIRST);
      break;
    case FLOAT:
      tok = jj_consume_token(FLOAT);
      break;
    case FOR:
      tok = jj_consume_token(FOR);
      break;
    case FOREIGN:
      tok = jj_consume_token(FOREIGN);
      break;
    case FOUND:
      tok = jj_consume_token(FOUND);
      break;
    case FROM:
      tok = jj_consume_token(FROM);
      break;
    case FULL:
      tok = jj_consume_token(FULL);
      break;
    case FUNCTION:
      tok = jj_consume_token(FUNCTION);
      break;
    case GET:
      tok = jj_consume_token(GET);
      break;
    case GET_CURRENT_CONNECTION:
      tok = jj_consume_token(GET_CURRENT_CONNECTION);
      break;
    case GLOBAL:
      tok = jj_consume_token(GLOBAL);
      break;
    case GO:
      tok = jj_consume_token(GO);
      break;
    case GOTO:
      tok = jj_consume_token(GOTO);
      break;
    case GRANT:
      tok = jj_consume_token(GRANT);
      break;
    case GROUP:
      tok = jj_consume_token(GROUP);
      break;
    case HAVING:
      tok = jj_consume_token(HAVING);
      break;
    case HOUR:
      tok = jj_consume_token(HOUR);
      break;
    case IDENTITY:
      tok = jj_consume_token(IDENTITY);
      break;
    case IMMEDIATE:
      tok = jj_consume_token(IMMEDIATE);
      break;
    case IN:
      tok = jj_consume_token(IN);
      break;
    case INDICATOR:
      tok = jj_consume_token(INDICATOR);
      break;
    case INITIALLY:
      tok = jj_consume_token(INITIALLY);
      break;
    case INNER:
      tok = jj_consume_token(INNER);
      break;
    case INOUT:
      tok = jj_consume_token(INOUT);
      break;
    case INPUT:
      tok = jj_consume_token(INPUT);
      break;
    case INSENSITIVE:
      tok = jj_consume_token(INSENSITIVE);
      break;
    case INSERT:
      tok = jj_consume_token(INSERT);
      break;
    case INT:
      tok = jj_consume_token(INT);
      break;
    case INTEGER:
      tok = jj_consume_token(INTEGER);
      break;
    case INTERSECT:
      tok = jj_consume_token(INTERSECT);
      break;
    case INTO:
      tok = jj_consume_token(INTO);
      break;
    case IS:
      tok = jj_consume_token(IS);
      break;
    case ISOLATION:
      tok = jj_consume_token(ISOLATION);
      break;
    case JOIN:
      tok = jj_consume_token(JOIN);
      break;
    case KEY:
      tok = jj_consume_token(KEY);
      break;
    case LAST:
      tok = jj_consume_token(LAST);
      break;
    case LEFT:
      tok = jj_consume_token(LEFT);
      break;
    case LIKE:
      tok = jj_consume_token(LIKE);
      break;
    case LOWER:
      tok = jj_consume_token(LOWER);
      break;
    case MATCH:
      tok = jj_consume_token(MATCH);
      break;
    case MAX:
      tok = jj_consume_token(MAX);
      break;
    case MIN:
      tok = jj_consume_token(MIN);
      break;
    case MINUTE:
      tok = jj_consume_token(MINUTE);
      break;
    case NATIONAL:
      tok = jj_consume_token(NATIONAL);
      break;
    case NATURAL:
      tok = jj_consume_token(NATURAL);
      break;
    case NCHAR:
      tok = jj_consume_token(NCHAR);
      break;
    case NVARCHAR:
      tok = jj_consume_token(NVARCHAR);
      break;
    case NEXT:
      tok = jj_consume_token(NEXT);
      break;
    case NO:
      tok = jj_consume_token(NO);
      break;
    case NOT:
      tok = jj_consume_token(NOT);
      break;
    case NULL:
      tok = jj_consume_token(NULL);
      break;
    case NULLIF:
      tok = jj_consume_token(NULLIF);
      break;
    case NUMERIC:
      tok = jj_consume_token(NUMERIC);
      break;
    case OF:
      tok = jj_consume_token(OF);
      break;
    case ON:
      tok = jj_consume_token(ON);
      break;
    case ONLY:
      tok = jj_consume_token(ONLY);
      break;
    case OPEN:
      tok = jj_consume_token(OPEN);
      break;
    case OPTION:
      tok = jj_consume_token(OPTION);
      break;
    case OR:
      tok = jj_consume_token(OR);
      break;
    case ORDER:
      tok = jj_consume_token(ORDER);
      break;
    case OUT:
      tok = jj_consume_token(OUT);
      break;
    case OUTER:
      tok = jj_consume_token(OUTER);
      break;
    case OUTPUT:
      tok = jj_consume_token(OUTPUT);
      break;
    case OVERLAPS:
      tok = jj_consume_token(OVERLAPS);
      break;
    case PAD:
      tok = jj_consume_token(PAD);
      break;
    case PARTIAL:
      tok = jj_consume_token(PARTIAL);
      break;
    case PREPARE:
      tok = jj_consume_token(PREPARE);
      break;
    case PRESERVE:
      tok = jj_consume_token(PRESERVE);
      break;
    case PRIMARY:
      tok = jj_consume_token(PRIMARY);
      break;
    case PRIOR:
      tok = jj_consume_token(PRIOR);
      break;
    case PRIVILEGES:
      tok = jj_consume_token(PRIVILEGES);
      break;
    case PROCEDURE:
      tok = jj_consume_token(PROCEDURE);
      break;
    case PUBLIC:
      tok = jj_consume_token(PUBLIC);
      break;
    case READ:
      tok = jj_consume_token(READ);
      break;
    case REAL:
      tok = jj_consume_token(REAL);
      break;
    case REFERENCES:
      tok = jj_consume_token(REFERENCES);
      break;
    case RELATIVE:
      tok = jj_consume_token(RELATIVE);
      break;
    case RESTRICT:
      tok = jj_consume_token(RESTRICT);
      break;
    case REVOKE:
      tok = jj_consume_token(REVOKE);
      break;
    case RIGHT:
      tok = jj_consume_token(RIGHT);
      break;
    case ROLLBACK:
      tok = jj_consume_token(ROLLBACK);
      break;
    case ROWS:
      tok = jj_consume_token(ROWS);
      break;
    case SCHEMA:
      tok = jj_consume_token(SCHEMA);
      break;
    case SCROLL:
      tok = jj_consume_token(SCROLL);
      break;
    case SECOND:
      tok = jj_consume_token(SECOND);
      break;
    case SELECT:
      tok = jj_consume_token(SELECT);
      break;
    case SESSION_USER:
      tok = jj_consume_token(SESSION_USER);
      break;
    case SET:
      tok = jj_consume_token(SET);
      break;
    case SMALLINT:
      tok = jj_consume_token(SMALLINT);
      break;
    case SOME:
      tok = jj_consume_token(SOME);
      break;
    case SPACE:
      tok = jj_consume_token(SPACE);
      break;
    case SQL:
      tok = jj_consume_token(SQL);
      break;
    case SQLCODE:
      tok = jj_consume_token(SQLCODE);
      break;
    case SQLERROR:
      tok = jj_consume_token(SQLERROR);
      break;
    case SQLSTATE:
      tok = jj_consume_token(SQLSTATE);
      break;
    case SUBSTRING:
      tok = jj_consume_token(SUBSTRING);
      break;
    case SUM:
      tok = jj_consume_token(SUM);
      break;
    case SYSTEM_USER:
      tok = jj_consume_token(SYSTEM_USER);
      break;
    case TABLE:
      tok = jj_consume_token(TABLE);
      break;
    case TEMPORARY:
      tok = jj_consume_token(TEMPORARY);
      break;
    case TIMEZONE_HOUR:
      tok = jj_consume_token(TIMEZONE_HOUR);
      break;
    case TIMEZONE_MINUTE:
      tok = jj_consume_token(TIMEZONE_MINUTE);
      break;
    case TO:
      tok = jj_consume_token(TO);
      break;
    case TRANSACTION:
      tok = jj_consume_token(TRANSACTION);
      break;
    case TRANSLATE:
      tok = jj_consume_token(TRANSLATE);
      break;
    case TRANSLATION:
      tok = jj_consume_token(TRANSLATION);
      break;
    case TRUE:
      tok = jj_consume_token(TRUE);
      break;
    case UNION:
      tok = jj_consume_token(UNION);
      break;
    case UNIQUE:
      tok = jj_consume_token(UNIQUE);
      break;
    case UNKNOWN:
      tok = jj_consume_token(UNKNOWN);
      break;
    case UPDATE:
      tok = jj_consume_token(UPDATE);
      break;
    case UPPER:
      tok = jj_consume_token(UPPER);
      break;
    case USER:
      tok = jj_consume_token(USER);
      break;
    case USING:
      tok = jj_consume_token(USING);
      break;
    case VALUES:
      tok = jj_consume_token(VALUES);
      break;
    case VARCHAR:
      tok = jj_consume_token(VARCHAR);
      break;
    case VARYING:
      tok = jj_consume_token(VARYING);
      break;
    case VIEW:
      tok = jj_consume_token(VIEW);
      break;
    case WHENEVER:
      tok = jj_consume_token(WHENEVER);
      break;
    case WHERE:
      tok = jj_consume_token(WHERE);
      break;
    case WITH:
      tok = jj_consume_token(WITH);
      break;
    case WORK:
      tok = jj_consume_token(WORK);
      break;
    case WRITE:
      tok = jj_consume_token(WRITE);
      break;
    case YEAR:
      tok = jj_consume_token(YEAR);
      break;
    case BOOLEAN:
      tok = jj_consume_token(BOOLEAN);
      break;
    case CALL:
      tok = jj_consume_token(CALL);
      break;
    case EXPLAIN:
      tok = jj_consume_token(EXPLAIN);
      break;
    case LONGINT:
      tok = jj_consume_token(LONGINT);
      break;
    case LTRIM:
      tok = jj_consume_token(LTRIM);
      break;
    case RTRIM:
      tok = jj_consume_token(RTRIM);
      break;
    case SUBSTR:
      tok = jj_consume_token(SUBSTR);
      break;
    case XML:
      tok = jj_consume_token(XML);
      break;
    case XMLPARSE:
      tok = jj_consume_token(XMLPARSE);
      break;
    case XMLSERIALIZE:
      tok = jj_consume_token(XMLSERIALIZE);
      break;
    case XMLEXISTS:
      tok = jj_consume_token(XMLEXISTS);
      break;
    default:
      jj_la1[280] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                // Remember whether last token was a delimited identifier
                nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
                lastTokenDelimitedIdentifier = Boolean.FALSE;
                {if (true) return tok.image;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="nonReservedKeyword">nonReservedKeyword</A>
 */
  final public String nonReservedKeyword() throws ParseException {
        Token   tok;
    switch (jj_nt.kind) {
    case ABS:
      tok = jj_consume_token(ABS);
      break;
    case ABSVAL:
      tok = jj_consume_token(ABSVAL);
      break;
    case ACTION:
      tok = jj_consume_token(ACTION);
      break;
    case AFTER:
      tok = jj_consume_token(AFTER);
      break;
    case ALWAYS:
      tok = jj_consume_token(ALWAYS);
      break;
    case BEFORE:
      tok = jj_consume_token(BEFORE);
      break;
    case BINARY:
      tok = jj_consume_token(BINARY);
      break;
    case BLOB:
      tok = jj_consume_token(BLOB);
      break;
    case C:
      tok = jj_consume_token(C);
      break;
    case CALLED:
      tok = jj_consume_token(CALLED);
      break;
    case CLASS:
      tok = jj_consume_token(CLASS);
      break;
    case CLOB:
      tok = jj_consume_token(CLOB);
      break;
    case COALESCE:
      tok = jj_consume_token(COALESCE);
      break;
    case COBOL:
      tok = jj_consume_token(COBOL);
      break;
    case COMMITTED:
      tok = jj_consume_token(COMMITTED);
      break;
    case COMPRESS:
      tok = jj_consume_token(COMPRESS);
      break;
    case CONCAT:
      tok = jj_consume_token(CONCAT);
      break;
    case CONTAINS:
      tok = jj_consume_token(CONTAINS);
      break;
    case CONTENT:
      tok = jj_consume_token(CONTENT);
      break;
    case CS:
      tok = jj_consume_token(CS);
      break;
    case CURDATE:
      tok = jj_consume_token(CURDATE);
      break;
    case CURTIME:
      tok = jj_consume_token(CURTIME);
      break;
    case D:
      tok = jj_consume_token(D);
      break;
    case DATA:
      tok = jj_consume_token(DATA);
      break;
    case DATE:
      tok = jj_consume_token(DATE);
      break;
    case DAY:
      tok = jj_consume_token(DAY);
      break;
    case DIRTY:
      tok = jj_consume_token(DIRTY);
      break;
    case DYNAMIC:
      tok = jj_consume_token(DYNAMIC);
      break;
    case DATABASE:
      tok = jj_consume_token(DATABASE);
      break;
    case DB2SQL:
      tok = jj_consume_token(DB2SQL);
      break;
    case DOCUMENT:
      tok = jj_consume_token(DOCUMENT);
      break;
    case EACH:
      tok = jj_consume_token(EACH);
      break;
    case EXCLUSIVE:
      tok = jj_consume_token(EXCLUSIVE);
      break;
    case FN:
      tok = jj_consume_token(FN);
      break;
    case FORTRAN:
      tok = jj_consume_token(FORTRAN);
      break;
    case GENERATED:
      tok = jj_consume_token(GENERATED);
      break;
    case IDENTITY_VAL_LOCAL:
      tok = jj_consume_token(IDENTITY_VAL_LOCAL);
      break;
    case INCREMENT:
      tok = jj_consume_token(INCREMENT);
      break;
    case INDEX:
      tok = jj_consume_token(INDEX);
      break;
    case INITIAL:
      tok = jj_consume_token(INITIAL);
      break;
    case INTERVAL:
      tok = jj_consume_token(INTERVAL);
      break;
    case JAVA:
      tok = jj_consume_token(JAVA);
      break;
    case LANGUAGE:
      tok = jj_consume_token(LANGUAGE);
      break;
    case LARGE:
      tok = jj_consume_token(LARGE);
      break;
    case LCASE:
      tok = jj_consume_token(LCASE);
      break;
    case LENGTH:
      tok = jj_consume_token(LENGTH);
      break;
    case LEVEL:
      tok = jj_consume_token(LEVEL);
      break;
    case LOCATE:
      tok = jj_consume_token(LOCATE);
      break;
    case LOCK:
      tok = jj_consume_token(LOCK);
      break;
    case LOCKS:
      tok = jj_consume_token(LOCKS);
      break;
    case LOCKSIZE:
      tok = jj_consume_token(LOCKSIZE);
      break;
    case LOGGED:
      tok = jj_consume_token(LOGGED);
      break;
    case LONG:
      tok = jj_consume_token(LONG);
      break;
    case MESSAGE_LOCALE:
      tok = jj_consume_token(MESSAGE_LOCALE);
      break;
    case METHOD:
      tok = jj_consume_token(METHOD);
      break;
    case MOD:
      tok = jj_consume_token(MOD);
      break;
    case MODE:
      tok = jj_consume_token(MODE);
      break;
    case MODIFIES:
      tok = jj_consume_token(MODIFIES);
      break;
    case MODIFY:
      tok = jj_consume_token(MODIFY);
      break;
    case MODULE:
      tok = jj_consume_token(MODULE);
      break;
    case MONTH:
      tok = jj_consume_token(MONTH);
      break;
    case _MORE:
      tok = jj_consume_token(_MORE);
      break;
    case MUMPS:
      tok = jj_consume_token(MUMPS);
      break;
    case NAME:
      tok = jj_consume_token(NAME);
      break;
    case NCLOB:
      tok = jj_consume_token(NCLOB);
      break;
    case NEW:
      tok = jj_consume_token(NEW);
      break;
    case NEW_TABLE:
      tok = jj_consume_token(NEW_TABLE);
      break;
    case NULLABLE:
      tok = jj_consume_token(NULLABLE);
      break;
    case NUMBER:
      tok = jj_consume_token(NUMBER);
      break;
    case OBJECT:
      tok = jj_consume_token(OBJECT);
      break;
    case OFF:
      tok = jj_consume_token(OFF);
      break;
    case OLD:
      tok = jj_consume_token(OLD);
      break;
    case OLD_TABLE:
      tok = jj_consume_token(OLD_TABLE);
      break;
    case OJ:
      tok = jj_consume_token(OJ);
      break;
    case PASCAL:
      tok = jj_consume_token(PASCAL);
      break;
    case PASSING:
      tok = jj_consume_token(PASSING);
      break;
    case PLI:
      tok = jj_consume_token(PLI);
      break;
    case PRECISION:
      tok = jj_consume_token(PRECISION);
      break;
    case PROPERTIES:
      tok = jj_consume_token(PROPERTIES);
      break;
    case READS:
      tok = jj_consume_token(READS);
      break;
    case REF:
      tok = jj_consume_token(REF);
      break;
    case RELEASE:
      tok = jj_consume_token(RELEASE);
      break;
    case RENAME:
      tok = jj_consume_token(RENAME);
      break;
    case REPEATABLE:
      tok = jj_consume_token(REPEATABLE);
      break;
    case REFERENCING:
      tok = jj_consume_token(REFERENCING);
      break;
    case RESET:
      tok = jj_consume_token(RESET);
      break;
    case RESULT:
      tok = jj_consume_token(RESULT);
      break;
    case RETAIN:
      tok = jj_consume_token(RETAIN);
      break;
    case RETURNS:
      tok = jj_consume_token(RETURNS);
      break;
    case ROW:
      tok = jj_consume_token(ROW);
      break;
    case RR:
      tok = jj_consume_token(RR);
      break;
    case RS:
      tok = jj_consume_token(RS);
      break;
    case SCALE:
      tok = jj_consume_token(SCALE);
      break;
    case SAVEPOINT:
      tok = jj_consume_token(SAVEPOINT);
      break;
    case SEQUENTIAL:
      tok = jj_consume_token(SEQUENTIAL);
      break;
    case SERIALIZABLE:
      tok = jj_consume_token(SERIALIZABLE);
      break;
    case SETS:
      tok = jj_consume_token(SETS);
      break;
    case SHARE:
      tok = jj_consume_token(SHARE);
      break;
    case SPECIFIC:
      tok = jj_consume_token(SPECIFIC);
      break;
    case SQLID:
      tok = jj_consume_token(SQLID);
      break;
    case SQL_TSI_FRAC_SECOND:
      tok = jj_consume_token(SQL_TSI_FRAC_SECOND);
      break;
    case SQL_TSI_SECOND:
      tok = jj_consume_token(SQL_TSI_SECOND);
      break;
    case SQL_TSI_MINUTE:
      tok = jj_consume_token(SQL_TSI_MINUTE);
      break;
    case SQL_TSI_HOUR:
      tok = jj_consume_token(SQL_TSI_HOUR);
      break;
    case SQL_TSI_DAY:
      tok = jj_consume_token(SQL_TSI_DAY);
      break;
    case SQL_TSI_WEEK:
      tok = jj_consume_token(SQL_TSI_WEEK);
      break;
    case SQL_TSI_MONTH:
      tok = jj_consume_token(SQL_TSI_MONTH);
      break;
    case SQL_TSI_QUARTER:
      tok = jj_consume_token(SQL_TSI_QUARTER);
      break;
    case SQL_TSI_YEAR:
      tok = jj_consume_token(SQL_TSI_YEAR);
      break;
    case SQRT:
      tok = jj_consume_token(SQRT);
      break;
    case STABILITY:
      tok = jj_consume_token(STABILITY);
      break;
    case START:
      tok = jj_consume_token(START);
      break;
    case STATEMENT:
      tok = jj_consume_token(STATEMENT);
      break;
    case STRIP:
      tok = jj_consume_token(STRIP);
      break;
    case SYNONYM:
      tok = jj_consume_token(SYNONYM);
      break;
    case STYLE:
      tok = jj_consume_token(STYLE);
      break;
    case T:
      tok = jj_consume_token(T);
      break;
    case THEN:
      tok = jj_consume_token(THEN);
      break;
    case TIME:
      tok = jj_consume_token(TIME);
      break;
    case TIMESTAMP:
      tok = jj_consume_token(TIMESTAMP);
      break;
    case TIMESTAMPADD:
      tok = jj_consume_token(TIMESTAMPADD);
      break;
    case TIMESTAMPDIFF:
      tok = jj_consume_token(TIMESTAMPDIFF);
      break;
    case TRIGGER:
      tok = jj_consume_token(TRIGGER);
      break;
    case TRUNCATE:
      tok = jj_consume_token(TRUNCATE);
      break;
    case TS:
      tok = jj_consume_token(TS);
      break;
    case TYPE:
      tok = jj_consume_token(TYPE);
      break;
    case UCASE:
      tok = jj_consume_token(UCASE);
      break;
    case UNCOMMITTED:
      tok = jj_consume_token(UNCOMMITTED);
      break;
    case UR:
      tok = jj_consume_token(UR);
      break;
    case USAGE:
      tok = jj_consume_token(USAGE);
      break;
    case VALUE:
      tok = jj_consume_token(VALUE);
      break;
    case VARBINARY:
      tok = jj_consume_token(VARBINARY);
      break;
    case PARAMETER:
      tok = jj_consume_token(PARAMETER);
      break;
    case WHEN:
      tok = jj_consume_token(WHEN);
      break;
    case WHITESPACE:
      tok = jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[281] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                // Remember whether last token was a delimited identifier
                nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
                lastTokenDelimitedIdentifier = Boolean.FALSE;
                nextToLastIdentifierToken = lastIdentifierToken;
                lastIdentifierToken = tok;
                {if (true) return tok.image;}
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="caseSensitiveIdentifierPlusReservedWords">caseSensitiveIdentifierPlusReservedWords</A>
 */
  final public String caseSensitiveIdentifierPlusReservedWords() throws ParseException {
        String str;
    switch (jj_nt.kind) {
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      str = caseSensitiveIdentifier();
                {if (true) return str;}
      break;
    case ADD:
    case ALL:
    case ALLOCATE:
    case ALTER:
    case AND:
    case ANY:
    case ARE:
    case AS:
    case ASC:
    case ASSERTION:
    case AT:
    case AUTHORIZATION:
    case AVG:
    case BEGIN:
    case BETWEEN:
    case BIT:
    case BOTH:
    case BY:
    case CASCADE:
    case CASCADED:
    case CASE:
    case CAST:
    case CHAR:
    case CHARACTER:
    case CHECK:
    case CLOSE:
    case COLLATE:
    case COLLATION:
    case COLUMN:
    case COMMIT:
    case CONNECT:
    case CONNECTION:
    case CONSTRAINT:
    case CONSTRAINTS:
    case CONTINUE:
    case CONVERT:
    case CORRESPONDING:
    case COUNT:
    case CREATE:
    case CURRENT:
    case CURRENT_DATE:
    case CURRENT_TIME:
    case CURRENT_TIMESTAMP:
    case CURRENT_USER:
    case CURSOR:
    case DEALLOCATE:
    case DEC:
    case DECIMAL:
    case DECLARE:
    case _DEFAULT:
    case DEFERRABLE:
    case DEFERRED:
    case DELETE:
    case DESC:
    case DESCRIBE:
    case DIAGNOSTICS:
    case DISCONNECT:
    case DISTINCT:
    case DOUBLE:
    case DROP:
    case ELSE:
    case END:
    case ENDEXEC:
    case ESCAPE:
    case EXCEPT:
    case EXCEPTION:
    case EXEC:
    case EXECUTE:
    case EXISTS:
    case EXTERNAL:
    case FALSE:
    case FETCH:
    case FIRST:
    case FLOAT:
    case FOR:
    case FOREIGN:
    case FOUND:
    case FROM:
    case FULL:
    case FUNCTION:
    case GET:
    case GLOBAL:
    case GO:
    case GOTO:
    case GRANT:
    case GROUP:
    case HAVING:
    case HOUR:
    case IDENTITY:
    case IMMEDIATE:
    case IN:
    case INDICATOR:
    case INITIALLY:
    case INNER:
    case INPUT:
    case INSENSITIVE:
    case INSERT:
    case INT:
    case INTEGER:
    case INTERSECT:
    case INTO:
    case IS:
    case ISOLATION:
    case JOIN:
    case KEY:
    case LAST:
    case LEFT:
    case LIKE:
    case LOWER:
    case MATCH:
    case MAX:
    case MIN:
    case MINUTE:
    case NATIONAL:
    case NATURAL:
    case NCHAR:
    case NEXT:
    case NO:
    case NOT:
    case NULL:
    case NULLIF:
    case NUMERIC:
    case OF:
    case ON:
    case ONLY:
    case OPEN:
    case OPTION:
    case OR:
    case ORDER:
    case OUTER:
    case OUTPUT:
    case OVERLAPS:
    case PAD:
    case PARTIAL:
    case PREPARE:
    case PRESERVE:
    case PRIMARY:
    case PRIOR:
    case PRIVILEGES:
    case PROCEDURE:
    case PUBLIC:
    case READ:
    case REAL:
    case REFERENCES:
    case RELATIVE:
    case RESTRICT:
    case REVOKE:
    case RIGHT:
    case ROLLBACK:
    case ROWS:
    case SCHEMA:
    case SCROLL:
    case SECOND:
    case SELECT:
    case SESSION_USER:
    case SET:
    case SMALLINT:
    case SOME:
    case SPACE:
    case SQL:
    case SQLCODE:
    case SQLERROR:
    case SQLSTATE:
    case SUBSTRING:
    case SUM:
    case SYSTEM_USER:
    case TABLE:
    case TEMPORARY:
    case TIMEZONE_HOUR:
    case TIMEZONE_MINUTE:
    case TO:
    case TRANSACTION:
    case TRANSLATE:
    case TRANSLATION:
    case TRUE:
    case UNION:
    case UNIQUE:
    case UNKNOWN:
    case UPDATE:
    case UPPER:
    case USER:
    case USING:
    case VALUES:
    case VARCHAR:
    case VARYING:
    case VIEW:
    case WHENEVER:
    case WHERE:
    case WITH:
    case WORK:
    case WRITE:
    case YEAR:
    case INOUT:
    case BOOLEAN:
    case CALL:
    case GET_CURRENT_CONNECTION:
    case EXPLAIN:
    case LONGINT:
    case LTRIM:
    case RTRIM:
    case SUBSTR:
    case XML:
    case XMLPARSE:
    case XMLSERIALIZE:
    case XMLEXISTS:
    case NVARCHAR:
    case OUT:
      str = reservedKeyword();
                {if (true) return str;}
      break;
    default:
      jj_la1[282] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="caseInsensitiveIdentifierPlusReservedWords">caseInsensitiveIdentifierPlusReservedWords</A>
 */
  final public String caseInsensitiveIdentifierPlusReservedWords() throws ParseException, StandardException {
        String str;
    switch (jj_nt.kind) {
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
    case IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      str = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
                {if (true) return str;}
      break;
    case ADD:
    case ALL:
    case ALLOCATE:
    case ALTER:
    case AND:
    case ANY:
    case ARE:
    case AS:
    case ASC:
    case ASSERTION:
    case AT:
    case AUTHORIZATION:
    case AVG:
    case BEGIN:
    case BETWEEN:
    case BIT:
    case BOTH:
    case BY:
    case CASCADE:
    case CASCADED:
    case CASE:
    case CAST:
    case CHAR:
    case CHARACTER:
    case CHECK:
    case CLOSE:
    case COLLATE:
    case COLLATION:
    case COLUMN:
    case COMMIT:
    case CONNECT:
    case CONNECTION:
    case CONSTRAINT:
    case CONSTRAINTS:
    case CONTINUE:
    case CONVERT:
    case CORRESPONDING:
    case COUNT:
    case CREATE:
    case CURRENT:
    case CURRENT_DATE:
    case CURRENT_TIME:
    case CURRENT_TIMESTAMP:
    case CURRENT_USER:
    case CURSOR:
    case DEALLOCATE:
    case DEC:
    case DECIMAL:
    case DECLARE:
    case _DEFAULT:
    case DEFERRABLE:
    case DEFERRED:
    case DELETE:
    case DESC:
    case DESCRIBE:
    case DIAGNOSTICS:
    case DISCONNECT:
    case DISTINCT:
    case DOUBLE:
    case DROP:
    case ELSE:
    case END:
    case ENDEXEC:
    case ESCAPE:
    case EXCEPT:
    case EXCEPTION:
    case EXEC:
    case EXECUTE:
    case EXISTS:
    case EXTERNAL:
    case FALSE:
    case FETCH:
    case FIRST:
    case FLOAT:
    case FOR:
    case FOREIGN:
    case FOUND:
    case FROM:
    case FULL:
    case FUNCTION:
    case GET:
    case GLOBAL:
    case GO:
    case GOTO:
    case GRANT:
    case GROUP:
    case HAVING:
    case HOUR:
    case IDENTITY:
    case IMMEDIATE:
    case IN:
    case INDICATOR:
    case INITIALLY:
    case INNER:
    case INPUT:
    case INSENSITIVE:
    case INSERT:
    case INT:
    case INTEGER:
    case INTERSECT:
    case INTO:
    case IS:
    case ISOLATION:
    case JOIN:
    case KEY:
    case LAST:
    case LEFT:
    case LIKE:
    case LOWER:
    case MATCH:
    case MAX:
    case MIN:
    case MINUTE:
    case NATIONAL:
    case NATURAL:
    case NCHAR:
    case NEXT:
    case NO:
    case NOT:
    case NULL:
    case NULLIF:
    case NUMERIC:
    case OF:
    case ON:
    case ONLY:
    case OPEN:
    case OPTION:
    case OR:
    case ORDER:
    case OUTER:
    case OUTPUT:
    case OVERLAPS:
    case PAD:
    case PARTIAL:
    case PREPARE:
    case PRESERVE:
    case PRIMARY:
    case PRIOR:
    case PRIVILEGES:
    case PROCEDURE:
    case PUBLIC:
    case READ:
    case REAL:
    case REFERENCES:
    case RELATIVE:
    case RESTRICT:
    case REVOKE:
    case RIGHT:
    case ROLLBACK:
    case ROWS:
    case SCHEMA:
    case SCROLL:
    case SECOND:
    case SELECT:
    case SESSION_USER:
    case SET:
    case SMALLINT:
    case SOME:
    case SPACE:
    case SQL:
    case SQLCODE:
    case SQLERROR:
    case SQLSTATE:
    case SUBSTRING:
    case SUM:
    case SYSTEM_USER:
    case TABLE:
    case TEMPORARY:
    case TIMEZONE_HOUR:
    case TIMEZONE_MINUTE:
    case TO:
    case TRANSACTION:
    case TRANSLATE:
    case TRANSLATION:
    case TRUE:
    case UNION:
    case UNIQUE:
    case UNKNOWN:
    case UPDATE:
    case UPPER:
    case USER:
    case USING:
    case VALUES:
    case VARCHAR:
    case VARYING:
    case VIEW:
    case WHENEVER:
    case WHERE:
    case WITH:
    case WORK:
    case WRITE:
    case YEAR:
    case INOUT:
    case BOOLEAN:
    case CALL:
    case GET_CURRENT_CONNECTION:
    case EXPLAIN:
    case LONGINT:
    case LTRIM:
    case RTRIM:
    case SUBSTR:
    case XML:
    case XMLPARSE:
    case XMLSERIALIZE:
    case XMLEXISTS:
    case NVARCHAR:
    case OUT:
      str = reservedKeyword();
                {if (true) return getLanguageConnectionContext().convertIdentifierCase( str);}
      break;
    default:
      jj_la1[283] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * <A NAME="caseSensitiveIdentifier">caseSensitiveIdentifier</A>
 */
  final public String caseSensitiveIdentifier() throws ParseException {
        String  str;
        Token   tok;
    switch (jj_nt.kind) {
    case IDENTIFIER:
      tok = jj_consume_token(IDENTIFIER);
                // Remember whether last token was a delimited identifier
                nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
                lastTokenDelimitedIdentifier = Boolean.FALSE;
                {if (true) return tok.image;}
      break;
    case DELIMITED_IDENTIFIER:
      str = delimitedIdentifier();
                {if (true) return str;}
      break;
    case BINARY:
    case COALESCE:
    case D:
    case MODULE:
    case T:
    case TS:
    case VALUE:
    case VARBINARY:
    case ABS:
    case ABSVAL:
    case ACTION:
    case ALWAYS:
    case BLOB:
    case C:
    case CALLED:
    case CLOB:
    case COBOL:
    case COMMITTED:
    case CONCAT:
    case CONTAINS:
    case DATA:
    case DATE:
    case DAY:
    case DYNAMIC:
    case FORTRAN:
    case GENERATED:
    case IDENTITY_VAL_LOCAL:
    case INCREMENT:
    case INITIAL:
    case INTERVAL:
    case LANGUAGE:
    case LARGE:
    case LENGTH:
    case LEVEL:
    case LOCKS:
    case LOCKSIZE:
    case LOGGED:
    case MOD:
    case MODIFIES:
    case MODIFY:
    case MONTH:
    case _MORE:
    case MUMPS:
    case NAME:
    case NCLOB:
    case NULLABLE:
    case NUMBER:
    case OBJECT:
    case PASCAL:
    case PLI:
    case PRECISION:
    case RELEASE:
    case REPEATABLE:
    case RETURNS:
    case ROW:
    case SAVEPOINT:
    case SCALE:
    case SERIALIZABLE:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_HOUR:
    case SQL_TSI_DAY:
    case SQL_TSI_WEEK:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case START:
    case STATEMENT:
    case SYNONYM:
    case THEN:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TRUNCATE:
    case TYPE:
    case UNCOMMITTED:
    case USAGE:
    case WHEN:
    case CURDATE:
    case CURTIME:
    case DATABASE:
    case LONG:
    case AFTER:
    case BEFORE:
    case CLASS:
    case COMPRESS:
    case CONTENT:
    case CS:
    case DB2SQL:
    case DIRTY:
    case DOCUMENT:
    case EACH:
    case EXCLUSIVE:
    case FN:
    case INDEX:
    case JAVA:
    case LCASE:
    case LOCATE:
    case LOCK:
    case MESSAGE_LOCALE:
    case METHOD:
    case MODE:
    case NEW:
    case NEW_TABLE:
    case OJ:
    case OFF:
    case OLD:
    case OLD_TABLE:
    case PARAMETER:
    case PASSING:
    case PROPERTIES:
    case READS:
    case REF:
    case REFERENCING:
    case RENAME:
    case RESET:
    case RESULT:
    case RETAIN:
    case RR:
    case RS:
    case SEQUENTIAL:
    case SETS:
    case SHARE:
    case SQLID:
    case SPECIFIC:
    case SQRT:
    case STABILITY:
    case STRIP:
    case STYLE:
    case TRIGGER:
    case UCASE:
    case UR:
    case WHITESPACE:
      str = nonReservedKeyword();
                {if (true) return str;}
      break;
    default:
      jj_la1[284] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_8();
    jj_save(7, xla);
    return retval;
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_9();
    jj_save(8, xla);
    return retval;
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_10();
    jj_save(9, xla);
    return retval;
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_11();
    jj_save(10, xla);
    return retval;
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_12();
    jj_save(11, xla);
    return retval;
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_13();
    jj_save(12, xla);
    return retval;
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_14();
    jj_save(13, xla);
    return retval;
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_15();
    jj_save(14, xla);
    return retval;
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_16();
    jj_save(15, xla);
    return retval;
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_17();
    jj_save(16, xla);
    return retval;
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_18();
    jj_save(17, xla);
    return retval;
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_19();
    jj_save(18, xla);
    return retval;
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_20();
    jj_save(19, xla);
    return retval;
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_21();
    jj_save(20, xla);
    return retval;
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_22();
    jj_save(21, xla);
    return retval;
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_23();
    jj_save(22, xla);
    return retval;
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_24();
    jj_save(23, xla);
    return retval;
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_25();
    jj_save(24, xla);
    return retval;
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_26();
    jj_save(25, xla);
    return retval;
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_27();
    jj_save(26, xla);
    return retval;
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_28();
    jj_save(27, xla);
    return retval;
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_29();
    jj_save(28, xla);
    return retval;
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_30();
    jj_save(29, xla);
    return retval;
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_31();
    jj_save(30, xla);
    return retval;
  }

  final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_32();
    jj_save(31, xla);
    return retval;
  }

  final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_33();
    jj_save(32, xla);
    return retval;
  }

  final private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_34();
    jj_save(33, xla);
    return retval;
  }

  final private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_35();
    jj_save(34, xla);
    return retval;
  }

  final private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_36();
    jj_save(35, xla);
    return retval;
  }

  final private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_37();
    jj_save(36, xla);
    return retval;
  }

  final private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_38();
    jj_save(37, xla);
    return retval;
  }

  final private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_39();
    jj_save(38, xla);
    return retval;
  }

  final private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_40();
    jj_save(39, xla);
    return retval;
  }

  final private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_41();
    jj_save(40, xla);
    return retval;
  }

  final private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_42();
    jj_save(41, xla);
    return retval;
  }

  final private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_43();
    jj_save(42, xla);
    return retval;
  }

  final private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_44();
    jj_save(43, xla);
    return retval;
  }

  final private boolean jj_3R_210() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) {
    jj_scanpos = xsp;
    if (jj_3R_276()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_3R_184()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(GET_CURRENT_CONNECTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_489() {
    if (jj_scan_token(EXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_51()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_282() {
    if (jj_3R_285()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_217() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == PERIOD &&
                getToken(4).kind == LEFT_PAREN;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3_9()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_3R_62()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_227() {
    if (jj_3R_285()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_3R_68()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_3R_192()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_107() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == PERIOD &&
                        (
                                getToken(3).kind == ASTERISK ||
                                (getToken(4).kind == PERIOD && getToken(5).kind == ASTERISK)
                        );
    lookingAhead = false;
    if (!jj_semLA || jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3_18()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_107()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_61()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_333() {
    if (jj_3R_335()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_226() {
    if (jj_3R_66()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_181() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = ( (getToken(1).kind == GET_CURRENT_CONNECTION ||
                getToken(1).kind == ABS ||
                getToken(1).kind == ABSVAL ||
                getToken(1).kind == SQRT ||
                getToken(1).kind == MOD ||
                getToken(1).kind == COALESCE ||
                getToken(1).kind == VALUE ||
                getToken(1).kind == IDENTITY_VAL_LOCAL ||
                getToken(1).kind == SUBSTRING ||
                getToken(1).kind == SUBSTR ||
                getToken(1).kind == UPPER ||
                getToken(1).kind == LOWER ||
                getToken(1).kind == UCASE ||
                getToken(1).kind == LCASE ||
                getToken(1).kind == LTRIM ||
                getToken(1).kind == RTRIM ||
                getToken(1).kind == DATE ||
                getToken(1).kind == TIME ||
                getToken(1).kind == TIMESTAMP ||
                getToken(1).kind == DOUBLE ||
                getToken(1).kind == CHAR ||
                getToken(1).kind == VARCHAR ||
                getToken(1).kind == INTEGER ||
                getToken(1).kind == SMALLINT ||
                getToken(1).kind == LONGINT ||
                getToken(1).kind == YEAR ||
                getToken(1).kind == MONTH ||
                getToken(1).kind == DAY ||
                getToken(1).kind == HOUR ||
                getToken(1).kind == MINUTE ||
                getToken(1).kind == SECOND ||
                getToken(1).kind == LENGTH ||
                getToken(1).kind == LOCATE ||
                getToken(1).kind == XMLPARSE ||
                getToken(1).kind == XMLSERIALIZE ||
                getToken(1).kind == XMLEXISTS ) &&
              getToken(2).kind == LEFT_PAREN
              );
    lookingAhead = false;
    if (!jj_semLA || jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_312() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_332()) {
    jj_scanpos = xsp;
    if (jj_3R_333()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_332() {
    if (jj_scan_token(CALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_3R_67()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_3R_183()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_273() {
    if (jj_scan_token(LEFT_BRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_272() {
    if (jj_3R_312()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(ALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_209() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_272()) {
    jj_scanpos = xsp;
    if (jj_3R_273()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == DISTINCT &&
                        !(
                                getToken(2).kind == PERIOD ||
                                getToken(2).kind == DOUBLE_COLON
                        );
    lookingAhead = false;
    if (!jj_semLA || jj_3R_105()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == ALL &&
                        !(
                                getToken(2).kind == PERIOD ||
                                getToken(2).kind == DOUBLE_COLON
                        );
    lookingAhead = false;
    if (!jj_semLA || jj_3R_106()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_scan_token(DISTINCT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_3R_182()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_138()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_3R_181()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_502() {
    if (jj_scan_token(SELECT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_33() {
    if (jj_3R_72()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_3R_180()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_3R_179()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_42() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_499() {
    if (jj_3R_503()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_3R_178()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_495() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_498()) {
    jj_scanpos = xsp;
    if (jj_3R_499()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_498() {
    if (jj_3R_502()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_345() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = escapedValueFunctionFollows();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_110()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == SCHEMA || getToken(2).kind == SQLID;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_111()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == ISOLATION;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = newInvocationFollows(1);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_114()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = aggregateFollows();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_115()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = miscBuiltinFollows();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_scan_token(LEFT_BRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_331() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_344()) {
    jj_scanpos = xsp;
    if (jj_3R_345()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_344() {
    if (jj_3R_495()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_341() {
    if (jj_scan_token(LTRIM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_323() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_340()) {
    jj_scanpos = xsp;
    if (jj_3R_341()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_340() {
    if (jj_scan_token(RTRIM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_scan_token(UPDATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_291() {
    if (jj_3R_323()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_223() {
    if (jj_scan_token(CASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_290() {
    if (jj_scan_token(LCASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_288() {
    if (jj_scan_token(LOWER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_238() {
    if (jj_scan_token(LOCATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_32() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_222() {
    if (jj_scan_token(NULLIF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_506() {
    if (jj_3R_339()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_237() {
    if (jj_3R_291()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_221() {
    if (jj_3R_283()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_505() {
    if (jj_3R_338()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_3R_194()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_178() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_289() {
    if (jj_scan_token(UCASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_scan_token(INSERT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_236() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_289()) {
    jj_scanpos = xsp;
    if (jj_3R_290()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_500() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_504()) {
    jj_scanpos = xsp;
    if (jj_3R_505()) {
    jj_scanpos = xsp;
    if (jj_3R_506()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_504() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_287() {
    if (jj_scan_token(UPPER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_235() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_311() {
    if (jj_3R_331()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_234() {
    if (jj_scan_token(SUBSTR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_185() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) {
    jj_scanpos = xsp;
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_scan_token(LOCKSIZE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_326() {
    if (jj_scan_token(SECOND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_497() {
    if (jj_3R_501()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_293() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_325()) {
    jj_scanpos = xsp;
    if (jj_3R_326()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_325() {
    if (jj_3R_343()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_346() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_496()) {
    jj_scanpos = xsp;
    if (jj_3R_497()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_496() {
    if (jj_3R_500()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_3R_271()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_488() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_487() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_486() {
    if (jj_scan_token(PARAMETER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_485() {
    if (jj_scan_token(VARBINARY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_484() {
    if (jj_scan_token(VALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_483() {
    if (jj_scan_token(USAGE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_271() {
    if (jj_3R_311()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_481() {
    if (jj_scan_token(UNCOMMITTED)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_479() {
    if (jj_scan_token(TYPE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_478() {
    if (jj_scan_token(TS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_482() {
    if (jj_scan_token(UR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_477() {
    if (jj_scan_token(TRUNCATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_475() {
    if (jj_scan_token(TIMESTAMPDIFF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_474() {
    if (jj_scan_token(TIMESTAMPADD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_473() {
    if (jj_scan_token(TIMESTAMP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_472() {
    if (jj_scan_token(TIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_480() {
    if (jj_scan_token(UCASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_471() {
    if (jj_scan_token(THEN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_470() {
    if (jj_scan_token(T)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_469() {
    if (jj_scan_token(STYLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_468() {
    if (jj_scan_token(SYNONYM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_476() {
    if (jj_scan_token(TRIGGER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_467() {
    if (jj_scan_token(STRIP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_466() {
    if (jj_scan_token(STATEMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_465() {
    if (jj_scan_token(START)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_scan_token(SCHEMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_90() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == CURRENT && ( getToken(2).kind == SCHEMA ||  getToken(2).kind == SQLID );
    lookingAhead = false;
    if (!jj_semLA || jj_3R_170()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_462() {
    if (jj_scan_token(SQL_TSI_YEAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_461() {
    if (jj_scan_token(SQL_TSI_QUARTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_460() {
    if (jj_scan_token(SQL_TSI_MONTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_464() {
    if (jj_scan_token(STABILITY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_459() {
    if (jj_scan_token(SQL_TSI_WEEK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_458() {
    if (jj_scan_token(SQL_TSI_DAY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_457() {
    if (jj_scan_token(SQL_TSI_HOUR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_456() {
    if (jj_scan_token(SQL_TSI_MINUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_455() {
    if (jj_scan_token(SQL_TSI_SECOND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_463() {
    if (jj_scan_token(SQRT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_454() {
    if (jj_scan_token(SQL_TSI_FRAC_SECOND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_453() {
    if (jj_scan_token(SQLID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_451() {
    if (jj_scan_token(SHARE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_450() {
    if (jj_scan_token(SETS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_449() {
    if (jj_scan_token(SERIALIZABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_448() {
    if (jj_scan_token(SEQUENTIAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_452() {
    if (jj_scan_token(SPECIFIC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_3R_90()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_447() {
    if (jj_scan_token(SAVEPOINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_446() {
    if (jj_scan_token(SCALE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_443() {
    if (jj_scan_token(ROW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_442() {
    if (jj_scan_token(RETURNS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_445() {
    if (jj_scan_token(RS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_441() {
    if (jj_scan_token(RETAIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_444() {
    if (jj_scan_token(RR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_440() {
    if (jj_scan_token(RESULT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_439() {
    if (jj_scan_token(RESET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_438() {
    if (jj_scan_token(REFERENCING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_437() {
    if (jj_scan_token(REPEATABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_436() {
    if (jj_scan_token(RENAME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_435() {
    if (jj_scan_token(RELEASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_434() {
    if (jj_scan_token(REF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_433() {
    if (jj_scan_token(READS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_432() {
    if (jj_scan_token(PROPERTIES)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_431() {
    if (jj_scan_token(PRECISION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_430() {
    if (jj_scan_token(PLI)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_429() {
    if (jj_scan_token(PASSING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_428() {
    if (jj_scan_token(PASCAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_427() {
    if (jj_scan_token(OJ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_426() {
    if (jj_scan_token(OLD_TABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_192() {
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_425() {
    if (jj_scan_token(OLD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_424() {
    if (jj_scan_token(OFF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_423() {
    if (jj_scan_token(OBJECT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_422() {
    if (jj_scan_token(NUMBER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_421() {
    if (jj_scan_token(NULLABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_419() {
    if (jj_scan_token(NEW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_418() {
    if (jj_scan_token(NCLOB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_417() {
    if (jj_scan_token(NAME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_416() {
    if (jj_scan_token(MUMPS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_420() {
    if (jj_scan_token(NEW_TABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_415() {
    if (jj_scan_token(_MORE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_233() {
    if (jj_scan_token(IDENTITY_VAL_LOCAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_414() {
    if (jj_scan_token(MONTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_413() {
    if (jj_scan_token(MODULE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_412() {
    if (jj_scan_token(MODIFY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_411() {
    if (jj_scan_token(MODIFIES)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_232() {
    if (jj_scan_token(MOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_410() {
    if (jj_scan_token(MODE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_409() {
    if (jj_scan_token(MOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_408() {
    if (jj_scan_token(METHOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_407() {
    if (jj_scan_token(MESSAGE_LOCALE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_406() {
    if (jj_scan_token(LONG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_405() {
    if (jj_scan_token(LOGGED)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_404() {
    if (jj_scan_token(LOCKSIZE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_403() {
    if (jj_scan_token(LOCKS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_402() {
    if (jj_scan_token(LOCK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_400() {
    if (jj_scan_token(LEVEL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_399() {
    if (jj_scan_token(LENGTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_397() {
    if (jj_scan_token(LARGE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_231() {
    if (jj_scan_token(SQRT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_396() {
    if (jj_scan_token(LANGUAGE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_394() {
    if (jj_scan_token(INTERVAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_401() {
    if (jj_scan_token(LOCATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_393() {
    if (jj_scan_token(INITIAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_230() {
    if (jj_scan_token(ABSVAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_392() {
    if (jj_scan_token(INDEX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_395() {
    if (jj_scan_token(JAVA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_391() {
    if (jj_scan_token(INCREMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_398() {
    if (jj_scan_token(LCASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_390() {
    if (jj_scan_token(IDENTITY_VAL_LOCAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_389() {
    if (jj_scan_token(GENERATED)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_388() {
    if (jj_scan_token(FORTRAN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_229() {
    if (jj_scan_token(ABS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_184() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_387() {
    if (jj_scan_token(FN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_386() {
    if (jj_scan_token(EXCLUSIVE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_385() {
    if (jj_scan_token(EACH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_384() {
    if (jj_scan_token(DOCUMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_304() {
    if (jj_scan_token(TIMESTAMP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_261() {
    if (jj_scan_token(UR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_383() {
    if (jj_scan_token(DB2SQL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_381() {
    if (jj_scan_token(DYNAMIC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_260() {
    if (jj_scan_token(CS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_380() {
    if (jj_scan_token(DIRTY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_379() {
    if (jj_scan_token(DAY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_259() {
    if (jj_scan_token(RS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_378() {
    if (jj_scan_token(DATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_scan_token(SERIALIZABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_377() {
    if (jj_scan_token(DATA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_376() {
    if (jj_scan_token(D)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_375() {
    if (jj_scan_token(CURTIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_374() {
    if (jj_scan_token(CURDATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_382() {
    if (jj_scan_token(DATABASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_258() {
    if (jj_scan_token(RR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_scan_token(DELETE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_372() {
    if (jj_scan_token(CONTENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_371() {
    if (jj_scan_token(CONTAINS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_370() {
    if (jj_scan_token(CONCAT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_scan_token(READ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_369() {
    if (jj_scan_token(COMPRESS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_373() {
    if (jj_scan_token(CS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_368() {
    if (jj_scan_token(COMMITTED)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_367() {
    if (jj_scan_token(COBOL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_365() {
    if (jj_scan_token(CLOB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_303() {
    if (jj_scan_token(TIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_195() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_258()) {
    jj_scanpos = xsp;
    if (jj_3R_259()) {
    jj_scanpos = xsp;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_scan_token(READ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_364() {
    if (jj_scan_token(CLASS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_363() {
    if (jj_scan_token(CALLED)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_362() {
    if (jj_scan_token(C)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_scan_token(NULL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_361() {
    if (jj_scan_token(BLOB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_360() {
    if (jj_scan_token(BINARY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_267() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_302()) {
    jj_scanpos = xsp;
    if (jj_3R_303()) {
    jj_scanpos = xsp;
    if (jj_3R_304()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_302() {
    if (jj_scan_token(DATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_359() {
    if (jj_scan_token(BEFORE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_358() {
    if (jj_scan_token(ALWAYS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_366() {
    if (jj_scan_token(COALESCE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_357() {
    if (jj_scan_token(AFTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_356() {
    if (jj_scan_token(ACTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_3R_210()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_355() {
    if (jj_scan_token(ABSVAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_scan_token(DIRTY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_196() {
    if (jj_scan_token(REPEATABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_scan_token(CURSOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_3R_209()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_150() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_3R_195()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_354() {
    if (jj_scan_token(ABS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_3R_208()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_3R_67()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_339() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_354()) {
    jj_scanpos = xsp;
    if (jj_3R_355()) {
    jj_scanpos = xsp;
    if (jj_3R_356()) {
    jj_scanpos = xsp;
    if (jj_3R_357()) {
    jj_scanpos = xsp;
    if (jj_3R_358()) {
    jj_scanpos = xsp;
    if (jj_3R_359()) {
    jj_scanpos = xsp;
    if (jj_3R_360()) {
    jj_scanpos = xsp;
    if (jj_3R_361()) {
    jj_scanpos = xsp;
    if (jj_3R_362()) {
    jj_scanpos = xsp;
    if (jj_3R_363()) {
    jj_scanpos = xsp;
    if (jj_3R_364()) {
    jj_scanpos = xsp;
    if (jj_3R_365()) {
    jj_scanpos = xsp;
    if (jj_3R_366()) {
    jj_scanpos = xsp;
    if (jj_3R_367()) {
    jj_scanpos = xsp;
    if (jj_3R_368()) {
    jj_scanpos = xsp;
    if (jj_3R_369()) {
    jj_scanpos = xsp;
    if (jj_3R_370()) {
    jj_scanpos = xsp;
    if (jj_3R_371()) {
    jj_scanpos = xsp;
    if (jj_3R_372()) {
    jj_scanpos = xsp;
    if (jj_3R_373()) {
    jj_scanpos = xsp;
    if (jj_3R_374()) {
    jj_scanpos = xsp;
    if (jj_3R_375()) {
    jj_scanpos = xsp;
    if (jj_3R_376()) {
    jj_scanpos = xsp;
    if (jj_3R_377()) {
    jj_scanpos = xsp;
    if (jj_3R_378()) {
    jj_scanpos = xsp;
    if (jj_3R_379()) {
    jj_scanpos = xsp;
    if (jj_3R_380()) {
    jj_scanpos = xsp;
    if (jj_3R_381()) {
    jj_scanpos = xsp;
    if (jj_3R_382()) {
    jj_scanpos = xsp;
    if (jj_3R_383()) {
    jj_scanpos = xsp;
    if (jj_3R_384()) {
    jj_scanpos = xsp;
    if (jj_3R_385()) {
    jj_scanpos = xsp;
    if (jj_3R_386()) {
    jj_scanpos = xsp;
    if (jj_3R_387()) {
    jj_scanpos = xsp;
    if (jj_3R_388()) {
    jj_scanpos = xsp;
    if (jj_3R_389()) {
    jj_scanpos = xsp;
    if (jj_3R_390()) {
    jj_scanpos = xsp;
    if (jj_3R_391()) {
    jj_scanpos = xsp;
    if (jj_3R_392()) {
    jj_scanpos = xsp;
    if (jj_3R_393()) {
    jj_scanpos = xsp;
    if (jj_3R_394()) {
    jj_scanpos = xsp;
    if (jj_3R_395()) {
    jj_scanpos = xsp;
    if (jj_3R_396()) {
    jj_scanpos = xsp;
    if (jj_3R_397()) {
    jj_scanpos = xsp;
    if (jj_3R_398()) {
    jj_scanpos = xsp;
    if (jj_3R_399()) {
    jj_scanpos = xsp;
    if (jj_3R_400()) {
    jj_scanpos = xsp;
    if (jj_3R_401()) {
    jj_scanpos = xsp;
    if (jj_3R_402()) {
    jj_scanpos = xsp;
    if (jj_3R_403()) {
    jj_scanpos = xsp;
    if (jj_3R_404()) {
    jj_scanpos = xsp;
    if (jj_3R_405()) {
    jj_scanpos = xsp;
    if (jj_3R_406()) {
    jj_scanpos = xsp;
    if (jj_3R_407()) {
    jj_scanpos = xsp;
    if (jj_3R_408()) {
    jj_scanpos = xsp;
    if (jj_3R_409()) {
    jj_scanpos = xsp;
    if (jj_3R_410()) {
    jj_scanpos = xsp;
    if (jj_3R_411()) {
    jj_scanpos = xsp;
    if (jj_3R_412()) {
    jj_scanpos = xsp;
    if (jj_3R_413()) {
    jj_scanpos = xsp;
    if (jj_3R_414()) {
    jj_scanpos = xsp;
    if (jj_3R_415()) {
    jj_scanpos = xsp;
    if (jj_3R_416()) {
    jj_scanpos = xsp;
    if (jj_3R_417()) {
    jj_scanpos = xsp;
    if (jj_3R_418()) {
    jj_scanpos = xsp;
    if (jj_3R_419()) {
    jj_scanpos = xsp;
    if (jj_3R_420()) {
    jj_scanpos = xsp;
    if (jj_3R_421()) {
    jj_scanpos = xsp;
    if (jj_3R_422()) {
    jj_scanpos = xsp;
    if (jj_3R_423()) {
    jj_scanpos = xsp;
    if (jj_3R_424()) {
    jj_scanpos = xsp;
    if (jj_3R_425()) {
    jj_scanpos = xsp;
    if (jj_3R_426()) {
    jj_scanpos = xsp;
    if (jj_3R_427()) {
    jj_scanpos = xsp;
    if (jj_3R_428()) {
    jj_scanpos = xsp;
    if (jj_3R_429()) {
    jj_scanpos = xsp;
    if (jj_3R_430()) {
    jj_scanpos = xsp;
    if (jj_3R_431()) {
    jj_scanpos = xsp;
    if (jj_3R_432()) {
    jj_scanpos = xsp;
    if (jj_3R_433()) {
    jj_scanpos = xsp;
    if (jj_3R_434()) {
    jj_scanpos = xsp;
    if (jj_3R_435()) {
    jj_scanpos = xsp;
    if (jj_3R_436()) {
    jj_scanpos = xsp;
    if (jj_3R_437()) {
    jj_scanpos = xsp;
    if (jj_3R_438()) {
    jj_scanpos = xsp;
    if (jj_3R_439()) {
    jj_scanpos = xsp;
    if (jj_3R_440()) {
    jj_scanpos = xsp;
    if (jj_3R_441()) {
    jj_scanpos = xsp;
    if (jj_3R_442()) {
    jj_scanpos = xsp;
    if (jj_3R_443()) {
    jj_scanpos = xsp;
    if (jj_3R_444()) {
    jj_scanpos = xsp;
    if (jj_3R_445()) {
    jj_scanpos = xsp;
    if (jj_3R_446()) {
    jj_scanpos = xsp;
    if (jj_3R_447()) {
    jj_scanpos = xsp;
    if (jj_3R_448()) {
    jj_scanpos = xsp;
    if (jj_3R_449()) {
    jj_scanpos = xsp;
    if (jj_3R_450()) {
    jj_scanpos = xsp;
    if (jj_3R_451()) {
    jj_scanpos = xsp;
    if (jj_3R_452()) {
    jj_scanpos = xsp;
    if (jj_3R_453()) {
    jj_scanpos = xsp;
    if (jj_3R_454()) {
    jj_scanpos = xsp;
    if (jj_3R_455()) {
    jj_scanpos = xsp;
    if (jj_3R_456()) {
    jj_scanpos = xsp;
    if (jj_3R_457()) {
    jj_scanpos = xsp;
    if (jj_3R_458()) {
    jj_scanpos = xsp;
    if (jj_3R_459()) {
    jj_scanpos = xsp;
    if (jj_3R_460()) {
    jj_scanpos = xsp;
    if (jj_3R_461()) {
    jj_scanpos = xsp;
    if (jj_3R_462()) {
    jj_scanpos = xsp;
    if (jj_3R_463()) {
    jj_scanpos = xsp;
    if (jj_3R_464()) {
    jj_scanpos = xsp;
    if (jj_3R_465()) {
    jj_scanpos = xsp;
    if (jj_3R_466()) {
    jj_scanpos = xsp;
    if (jj_3R_467()) {
    jj_scanpos = xsp;
    if (jj_3R_468()) {
    jj_scanpos = xsp;
    if (jj_3R_469()) {
    jj_scanpos = xsp;
    if (jj_3R_470()) {
    jj_scanpos = xsp;
    if (jj_3R_471()) {
    jj_scanpos = xsp;
    if (jj_3R_472()) {
    jj_scanpos = xsp;
    if (jj_3R_473()) {
    jj_scanpos = xsp;
    if (jj_3R_474()) {
    jj_scanpos = xsp;
    if (jj_3R_475()) {
    jj_scanpos = xsp;
    if (jj_3R_476()) {
    jj_scanpos = xsp;
    if (jj_3R_477()) {
    jj_scanpos = xsp;
    if (jj_3R_478()) {
    jj_scanpos = xsp;
    if (jj_3R_479()) {
    jj_scanpos = xsp;
    if (jj_3R_480()) {
    jj_scanpos = xsp;
    if (jj_3R_481()) {
    jj_scanpos = xsp;
    if (jj_3R_482()) {
    jj_scanpos = xsp;
    if (jj_3R_483()) {
    jj_scanpos = xsp;
    if (jj_3R_484()) {
    jj_scanpos = xsp;
    if (jj_3R_485()) {
    jj_scanpos = xsp;
    if (jj_3R_486()) {
    jj_scanpos = xsp;
    if (jj_3R_487()) {
    jj_scanpos = xsp;
    if (jj_3R_488()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_3R_207()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_41() {
    if (jj_3R_77()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_77() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == READ && getToken(2).kind == COMMITTED;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_153()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == READ && getToken(2).kind == UNCOMMITTED;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_154()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_3R_206()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_31() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_3R_205()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_335() {
    if (jj_scan_token(QUESTION_MARK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_713() {
    if (jj_scan_token(XMLEXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_712() {
    if (jj_scan_token(XMLSERIALIZE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_711() {
    if (jj_scan_token(XMLPARSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_710() {
    if (jj_scan_token(XML)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_709() {
    if (jj_scan_token(SUBSTR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_708() {
    if (jj_scan_token(RTRIM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_707() {
    if (jj_scan_token(LTRIM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_706() {
    if (jj_scan_token(LONGINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_48()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_705() {
    if (jj_scan_token(EXPLAIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_704() {
    if (jj_scan_token(CALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_703() {
    if (jj_scan_token(BOOLEAN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_702() {
    if (jj_scan_token(YEAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_38() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_701() {
    if (jj_scan_token(WRITE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_700() {
    if (jj_scan_token(WORK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_699() {
    if (jj_scan_token(WITH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_698() {
    if (jj_scan_token(WHERE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_697() {
    if (jj_scan_token(WHENEVER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_696() {
    if (jj_scan_token(VIEW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_695() {
    if (jj_scan_token(VARYING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_48()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(SET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_694() {
    if (jj_scan_token(VARCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_693() {
    if (jj_scan_token(VALUES)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_692() {
    if (jj_scan_token(USING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(ISOLATION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_89() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == CURRENT && getToken(2).kind == ISOLATION;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_168()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_691() {
    if (jj_scan_token(USER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_690() {
    if (jj_scan_token(UPPER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_249() {
    if (jj_scan_token(VARCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_689() {
    if (jj_scan_token(UPDATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_688() {
    if (jj_scan_token(UNKNOWN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_687() {
    if (jj_scan_token(UNIQUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_686() {
    if (jj_scan_token(UNION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_685() {
    if (jj_scan_token(TRUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_248() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_189() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_684() {
    if (jj_scan_token(TRANSLATION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == SET && getToken(2).kind != CURRENT;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_80()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == SET && getToken(2).kind == CURRENT;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_81()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_scan_token(SET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_683() {
    if (jj_scan_token(TRANSLATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_682() {
    if (jj_scan_token(TRANSACTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_3R_89()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_681() {
    if (jj_scan_token(TO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_680() {
    if (jj_scan_token(TIMEZONE_MINUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_679() {
    if (jj_scan_token(TIMEZONE_HOUR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_678() {
    if (jj_scan_token(TEMPORARY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_677() {
    if (jj_scan_token(TABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_676() {
    if (jj_scan_token(SYSTEM_USER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_675() {
    if (jj_scan_token(SUM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_674() {
    if (jj_scan_token(SUBSTRING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_673() {
    if (jj_scan_token(SQLSTATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_672() {
    if (jj_scan_token(SQLERROR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_671() {
    if (jj_scan_token(SQLCODE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_670() {
    if (jj_scan_token(SQL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_669() {
    if (jj_scan_token(SPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_668() {
    if (jj_scan_token(SOME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_667() {
    if (jj_scan_token(SMALLINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(EXECUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_666() {
    if (jj_scan_token(SET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(ALTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_665() {
    if (jj_scan_token(SESSION_USER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_664() {
    if (jj_scan_token(SELECT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_663() {
    if (jj_scan_token(SECOND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_662() {
    if (jj_scan_token(SCROLL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_661() {
    if (jj_scan_token(SCHEMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_660() {
    if (jj_scan_token(ROWS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_659() {
    if (jj_scan_token(ROLLBACK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_658() {
    if (jj_scan_token(RIGHT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_657() {
    if (jj_scan_token(REVOKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_656() {
    if (jj_scan_token(RESTRICT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_655() {
    if (jj_scan_token(RELATIVE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_654() {
    if (jj_scan_token(REFERENCES)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_653() {
    if (jj_scan_token(REAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_652() {
    if (jj_scan_token(READ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_651() {
    if (jj_scan_token(PUBLIC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_650() {
    if (jj_scan_token(PROCEDURE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_scan_token(CAST)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_649() {
    if (jj_scan_token(PRIVILEGES)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_648() {
    if (jj_scan_token(PRIOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_647() {
    if (jj_scan_token(PRIMARY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_646() {
    if (jj_scan_token(PRESERVE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_645() {
    if (jj_scan_token(PREPARE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_644() {
    if (jj_scan_token(PARTIAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_643() {
    if (jj_scan_token(PAD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_scan_token(DROP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_642() {
    if (jj_scan_token(OVERLAPS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_641() {
    if (jj_scan_token(OUTPUT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_353() {
    if (jj_scan_token(SUM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_640() {
    if (jj_scan_token(OUTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_352() {
    if (jj_scan_token(MIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_351() {
    if (jj_scan_token(AVG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_638() {
    if (jj_scan_token(ORDER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_350() {
    if (jj_scan_token(MAX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_637() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_636() {
    if (jj_scan_token(OPTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_639() {
    if (jj_scan_token(OUT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_635() {
    if (jj_scan_token(OPEN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_634() {
    if (jj_scan_token(ONLY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_633() {
    if (jj_scan_token(ON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_632() {
    if (jj_scan_token(OF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_631() {
    if (jj_scan_token(NUMERIC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_630() {
    if (jj_scan_token(NULLIF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_629() {
    if (jj_scan_token(NULL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_337() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_350()) {
    jj_scanpos = xsp;
    if (jj_3R_351()) {
    jj_scanpos = xsp;
    if (jj_3R_352()) {
    jj_scanpos = xsp;
    if (jj_3R_353()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_628() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_627() {
    if (jj_scan_token(NO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_626() {
    if (jj_scan_token(NEXT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_625() {
    if (jj_scan_token(NVARCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_624() {
    if (jj_scan_token(NCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_623() {
    if (jj_scan_token(NATURAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_622() {
    if (jj_scan_token(NATIONAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_621() {
    if (jj_scan_token(MINUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_3R_66()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_620() {
    if (jj_scan_token(MIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_619() {
    if (jj_scan_token(MAX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_618() {
    if (jj_scan_token(MATCH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_617() {
    if (jj_scan_token(LOWER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_616() {
    if (jj_scan_token(LIKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_615() {
    if (jj_scan_token(LEFT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_614() {
    if (jj_scan_token(LAST)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_613() {
    if (jj_scan_token(KEY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_612() {
    if (jj_scan_token(JOIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_611() {
    if (jj_scan_token(ISOLATION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_610() {
    if (jj_scan_token(IS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(CREATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_609() {
    if (jj_scan_token(INTO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_608() {
    if (jj_scan_token(INTERSECT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_607() {
    if (jj_scan_token(INTEGER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_606() {
    if (jj_scan_token(INT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_605() {
    if (jj_scan_token(INSERT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_494() {
    if (jj_scan_token(MINUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_604() {
    if (jj_scan_token(INSENSITIVE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_603() {
    if (jj_scan_token(INPUT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_319() {
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_601() {
    if (jj_scan_token(INNER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_600() {
    if (jj_scan_token(INITIALLY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_493() {
    if (jj_scan_token(HOUR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_599() {
    if (jj_scan_token(INDICATOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_602() {
    if (jj_scan_token(INOUT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_598() {
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_597() {
    if (jj_scan_token(IMMEDIATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_596() {
    if (jj_scan_token(IDENTITY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_595() {
    if (jj_scan_token(HOUR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_492() {
    if (jj_scan_token(DAY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_594() {
    if (jj_scan_token(HAVING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_593() {
    if (jj_scan_token(GROUP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_592() {
    if (jj_scan_token(GRANT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_88()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_591() {
    if (jj_scan_token(GOTO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_3R_87()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_590() {
    if (jj_scan_token(GO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_40()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_491() {
    if (jj_scan_token(MONTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_284() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_318()) {
    jj_scanpos = xsp;
    if (jj_3R_319()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_318() {
    if (jj_3R_337()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_589() {
    if (jj_scan_token(GLOBAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_3R_86()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_588() {
    if (jj_scan_token(GET_CURRENT_CONNECTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_3R_85()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_587() {
    if (jj_scan_token(GET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_3R_84()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_586() {
    if (jj_scan_token(FUNCTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_585() {
    if (jj_scan_token(FULL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_343() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_490()) {
    jj_scanpos = xsp;
    if (jj_3R_491()) {
    jj_scanpos = xsp;
    if (jj_3R_492()) {
    jj_scanpos = xsp;
    if (jj_3R_493()) {
    jj_scanpos = xsp;
    if (jj_3R_494()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_490() {
    if (jj_scan_token(YEAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_584() {
    if (jj_scan_token(FROM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_583() {
    if (jj_scan_token(FOUND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_582() {
    if (jj_scan_token(FOREIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_581() {
    if (jj_scan_token(FOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_580() {
    if (jj_scan_token(FLOAT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3_1()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_579() {
    if (jj_scan_token(FIRST)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_578() {
    if (jj_scan_token(FETCH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_577() {
    if (jj_scan_token(FALSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_576() {
    if (jj_scan_token(EXTERNAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_575() {
    if (jj_scan_token(EXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_574() {
    if (jj_scan_token(EXECUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_573() {
    if (jj_scan_token(EXEC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_572() {
    if (jj_scan_token(EXCEPTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_571() {
    if (jj_scan_token(EXCEPT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_37() {
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_570() {
    if (jj_scan_token(ESCAPE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_75() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_37()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_569() {
    if (jj_scan_token(ENDEXEC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_568() {
    if (jj_scan_token(END)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_567() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_566() {
    if (jj_scan_token(DROP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_565() {
    if (jj_scan_token(DOUBLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_564() {
    if (jj_scan_token(DISTINCT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_563() {
    if (jj_scan_token(DISCONNECT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_562() {
    if (jj_scan_token(DIAGNOSTICS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_561() {
    if (jj_scan_token(DESCRIBE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_560() {
    if (jj_scan_token(DESC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_559() {
    if (jj_scan_token(DELETE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_558() {
    if (jj_scan_token(DEFERRED)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_557() {
    if (jj_scan_token(DEFERRABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_556() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_36() {
    if (jj_3R_75()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_555() {
    if (jj_scan_token(DECLARE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_225() {
    if (jj_3R_284()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_554() {
    if (jj_scan_token(DECIMAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_553() {
    if (jj_scan_token(DEC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_552() {
    if (jj_scan_token(DEALLOCATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_551() {
    if (jj_scan_token(CURSOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_550() {
    if (jj_scan_token(CURRENT_USER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_313() {
    if (jj_3R_334()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_549() {
    if (jj_scan_token(CURRENT_TIMESTAMP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_548() {
    if (jj_scan_token(CURRENT_TIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_547() {
    if (jj_scan_token(CURRENT_DATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_546() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_545() {
    if (jj_scan_token(CREATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_544() {
    if (jj_scan_token(COUNT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_543() {
    if (jj_scan_token(CORRESPONDING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_542() {
    if (jj_scan_token(CONVERT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_541() {
    if (jj_scan_token(CONTINUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_540() {
    if (jj_scan_token(CONSTRAINTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_539() {
    if (jj_scan_token(CONSTRAINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_538() {
    if (jj_scan_token(CONNECTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_537() {
    if (jj_scan_token(CONNECT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_536() {
    if (jj_scan_token(COMMIT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_224() {
    if (jj_scan_token(COUNT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_180() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_535() {
    if (jj_scan_token(COLUMN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_534() {
    if (jj_scan_token(COLLATION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_533() {
    if (jj_scan_token(COLLATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_334() {
    if (jj_3R_346()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_532() {
    if (jj_scan_token(CLOSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_531() {
    if (jj_scan_token(CHECK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_530() {
    if (jj_scan_token(CHARACTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_529() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_528() {
    if (jj_scan_token(CAST)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_3R_277()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_527() {
    if (jj_scan_token(CASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_526() {
    if (jj_scan_token(CASCADED)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_525() {
    if (jj_scan_token(CASCADE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_524() {
    if (jj_scan_token(BY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_523() {
    if (jj_scan_token(BOTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_522() {
    if (jj_scan_token(BIT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_521() {
    if (jj_scan_token(BETWEEN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_520() {
    if (jj_scan_token(BEGIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_519() {
    if (jj_scan_token(AVG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_518() {
    if (jj_scan_token(AUTHORIZATION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_517() {
    if (jj_scan_token(AT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_scan_token(CURRENT_TIMESTAMP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_516() {
    if (jj_scan_token(ASSERTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_515() {
    if (jj_scan_token(ASC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_514() {
    if (jj_scan_token(AS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_513() {
    if (jj_scan_token(ARE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_512() {
    if (jj_scan_token(ANY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_511() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_510() {
    if (jj_scan_token(ALTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_509() {
    if (jj_scan_token(ALLOCATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_508() {
    if (jj_scan_token(ALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_507() {
    if (jj_scan_token(ADD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_3R_211()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_91() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = javaClassFollows();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3_23()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_501() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_507()) {
    jj_scanpos = xsp;
    if (jj_3R_508()) {
    jj_scanpos = xsp;
    if (jj_3R_509()) {
    jj_scanpos = xsp;
    if (jj_3R_510()) {
    jj_scanpos = xsp;
    if (jj_3R_511()) {
    jj_scanpos = xsp;
    if (jj_3R_512()) {
    jj_scanpos = xsp;
    if (jj_3R_513()) {
    jj_scanpos = xsp;
    if (jj_3R_514()) {
    jj_scanpos = xsp;
    if (jj_3R_515()) {
    jj_scanpos = xsp;
    if (jj_3R_516()) {
    jj_scanpos = xsp;
    if (jj_3R_517()) {
    jj_scanpos = xsp;
    if (jj_3R_518()) {
    jj_scanpos = xsp;
    if (jj_3R_519()) {
    jj_scanpos = xsp;
    if (jj_3R_520()) {
    jj_scanpos = xsp;
    if (jj_3R_521()) {
    jj_scanpos = xsp;
    if (jj_3R_522()) {
    jj_scanpos = xsp;
    if (jj_3R_523()) {
    jj_scanpos = xsp;
    if (jj_3R_524()) {
    jj_scanpos = xsp;
    if (jj_3R_525()) {
    jj_scanpos = xsp;
    if (jj_3R_526()) {
    jj_scanpos = xsp;
    if (jj_3R_527()) {
    jj_scanpos = xsp;
    if (jj_3R_528()) {
    jj_scanpos = xsp;
    if (jj_3R_529()) {
    jj_scanpos = xsp;
    if (jj_3R_530()) {
    jj_scanpos = xsp;
    if (jj_3R_531()) {
    jj_scanpos = xsp;
    if (jj_3R_532()) {
    jj_scanpos = xsp;
    if (jj_3R_533()) {
    jj_scanpos = xsp;
    if (jj_3R_534()) {
    jj_scanpos = xsp;
    if (jj_3R_535()) {
    jj_scanpos = xsp;
    if (jj_3R_536()) {
    jj_scanpos = xsp;
    if (jj_3R_537()) {
    jj_scanpos = xsp;
    if (jj_3R_538()) {
    jj_scanpos = xsp;
    if (jj_3R_539()) {
    jj_scanpos = xsp;
    if (jj_3R_540()) {
    jj_scanpos = xsp;
    if (jj_3R_541()) {
    jj_scanpos = xsp;
    if (jj_3R_542()) {
    jj_scanpos = xsp;
    if (jj_3R_543()) {
    jj_scanpos = xsp;
    if (jj_3R_544()) {
    jj_scanpos = xsp;
    if (jj_3R_545()) {
    jj_scanpos = xsp;
    if (jj_3R_546()) {
    jj_scanpos = xsp;
    if (jj_3R_547()) {
    jj_scanpos = xsp;
    if (jj_3R_548()) {
    jj_scanpos = xsp;
    if (jj_3R_549()) {
    jj_scanpos = xsp;
    if (jj_3R_550()) {
    jj_scanpos = xsp;
    if (jj_3R_551()) {
    jj_scanpos = xsp;
    if (jj_3R_552()) {
    jj_scanpos = xsp;
    if (jj_3R_553()) {
    jj_scanpos = xsp;
    if (jj_3R_554()) {
    jj_scanpos = xsp;
    if (jj_3R_555()) {
    jj_scanpos = xsp;
    if (jj_3R_556()) {
    jj_scanpos = xsp;
    if (jj_3R_557()) {
    jj_scanpos = xsp;
    if (jj_3R_558()) {
    jj_scanpos = xsp;
    if (jj_3R_559()) {
    jj_scanpos = xsp;
    if (jj_3R_560()) {
    jj_scanpos = xsp;
    if (jj_3R_561()) {
    jj_scanpos = xsp;
    if (jj_3R_562()) {
    jj_scanpos = xsp;
    if (jj_3R_563()) {
    jj_scanpos = xsp;
    if (jj_3R_564()) {
    jj_scanpos = xsp;
    if (jj_3R_565()) {
    jj_scanpos = xsp;
    if (jj_3R_566()) {
    jj_scanpos = xsp;
    if (jj_3R_567()) {
    jj_scanpos = xsp;
    if (jj_3R_568()) {
    jj_scanpos = xsp;
    if (jj_3R_569()) {
    jj_scanpos = xsp;
    if (jj_3R_570()) {
    jj_scanpos = xsp;
    if (jj_3R_571()) {
    jj_scanpos = xsp;
    if (jj_3R_572()) {
    jj_scanpos = xsp;
    if (jj_3R_573()) {
    jj_scanpos = xsp;
    if (jj_3R_574()) {
    jj_scanpos = xsp;
    if (jj_3R_575()) {
    jj_scanpos = xsp;
    if (jj_3R_576()) {
    jj_scanpos = xsp;
    if (jj_3R_577()) {
    jj_scanpos = xsp;
    if (jj_3R_578()) {
    jj_scanpos = xsp;
    if (jj_3R_579()) {
    jj_scanpos = xsp;
    if (jj_3R_580()) {
    jj_scanpos = xsp;
    if (jj_3R_581()) {
    jj_scanpos = xsp;
    if (jj_3R_582()) {
    jj_scanpos = xsp;
    if (jj_3R_583()) {
    jj_scanpos = xsp;
    if (jj_3R_584()) {
    jj_scanpos = xsp;
    if (jj_3R_585()) {
    jj_scanpos = xsp;
    if (jj_3R_586()) {
    jj_scanpos = xsp;
    if (jj_3R_587()) {
    jj_scanpos = xsp;
    if (jj_3R_588()) {
    jj_scanpos = xsp;
    if (jj_3R_589()) {
    jj_scanpos = xsp;
    if (jj_3R_590()) {
    jj_scanpos = xsp;
    if (jj_3R_591()) {
    jj_scanpos = xsp;
    if (jj_3R_592()) {
    jj_scanpos = xsp;
    if (jj_3R_593()) {
    jj_scanpos = xsp;
    if (jj_3R_594()) {
    jj_scanpos = xsp;
    if (jj_3R_595()) {
    jj_scanpos = xsp;
    if (jj_3R_596()) {
    jj_scanpos = xsp;
    if (jj_3R_597()) {
    jj_scanpos = xsp;
    if (jj_3R_598()) {
    jj_scanpos = xsp;
    if (jj_3R_599()) {
    jj_scanpos = xsp;
    if (jj_3R_600()) {
    jj_scanpos = xsp;
    if (jj_3R_601()) {
    jj_scanpos = xsp;
    if (jj_3R_602()) {
    jj_scanpos = xsp;
    if (jj_3R_603()) {
    jj_scanpos = xsp;
    if (jj_3R_604()) {
    jj_scanpos = xsp;
    if (jj_3R_605()) {
    jj_scanpos = xsp;
    if (jj_3R_606()) {
    jj_scanpos = xsp;
    if (jj_3R_607()) {
    jj_scanpos = xsp;
    if (jj_3R_608()) {
    jj_scanpos = xsp;
    if (jj_3R_609()) {
    jj_scanpos = xsp;
    if (jj_3R_610()) {
    jj_scanpos = xsp;
    if (jj_3R_611()) {
    jj_scanpos = xsp;
    if (jj_3R_612()) {
    jj_scanpos = xsp;
    if (jj_3R_613()) {
    jj_scanpos = xsp;
    if (jj_3R_614()) {
    jj_scanpos = xsp;
    if (jj_3R_615()) {
    jj_scanpos = xsp;
    if (jj_3R_616()) {
    jj_scanpos = xsp;
    if (jj_3R_617()) {
    jj_scanpos = xsp;
    if (jj_3R_618()) {
    jj_scanpos = xsp;
    if (jj_3R_619()) {
    jj_scanpos = xsp;
    if (jj_3R_620()) {
    jj_scanpos = xsp;
    if (jj_3R_621()) {
    jj_scanpos = xsp;
    if (jj_3R_622()) {
    jj_scanpos = xsp;
    if (jj_3R_623()) {
    jj_scanpos = xsp;
    if (jj_3R_624()) {
    jj_scanpos = xsp;
    if (jj_3R_625()) {
    jj_scanpos = xsp;
    if (jj_3R_626()) {
    jj_scanpos = xsp;
    if (jj_3R_627()) {
    jj_scanpos = xsp;
    if (jj_3R_628()) {
    jj_scanpos = xsp;
    if (jj_3R_629()) {
    jj_scanpos = xsp;
    if (jj_3R_630()) {
    jj_scanpos = xsp;
    if (jj_3R_631()) {
    jj_scanpos = xsp;
    if (jj_3R_632()) {
    jj_scanpos = xsp;
    if (jj_3R_633()) {
    jj_scanpos = xsp;
    if (jj_3R_634()) {
    jj_scanpos = xsp;
    if (jj_3R_635()) {
    jj_scanpos = xsp;
    if (jj_3R_636()) {
    jj_scanpos = xsp;
    if (jj_3R_637()) {
    jj_scanpos = xsp;
    if (jj_3R_638()) {
    jj_scanpos = xsp;
    if (jj_3R_639()) {
    jj_scanpos = xsp;
    if (jj_3R_640()) {
    jj_scanpos = xsp;
    if (jj_3R_641()) {
    jj_scanpos = xsp;
    if (jj_3R_642()) {
    jj_scanpos = xsp;
    if (jj_3R_643()) {
    jj_scanpos = xsp;
    if (jj_3R_644()) {
    jj_scanpos = xsp;
    if (jj_3R_645()) {
    jj_scanpos = xsp;
    if (jj_3R_646()) {
    jj_scanpos = xsp;
    if (jj_3R_647()) {
    jj_scanpos = xsp;
    if (jj_3R_648()) {
    jj_scanpos = xsp;
    if (jj_3R_649()) {
    jj_scanpos = xsp;
    if (jj_3R_650()) {
    jj_scanpos = xsp;
    if (jj_3R_651()) {
    jj_scanpos = xsp;
    if (jj_3R_652()) {
    jj_scanpos = xsp;
    if (jj_3R_653()) {
    jj_scanpos = xsp;
    if (jj_3R_654()) {
    jj_scanpos = xsp;
    if (jj_3R_655()) {
    jj_scanpos = xsp;
    if (jj_3R_656()) {
    jj_scanpos = xsp;
    if (jj_3R_657()) {
    jj_scanpos = xsp;
    if (jj_3R_658()) {
    jj_scanpos = xsp;
    if (jj_3R_659()) {
    jj_scanpos = xsp;
    if (jj_3R_660()) {
    jj_scanpos = xsp;
    if (jj_3R_661()) {
    jj_scanpos = xsp;
    if (jj_3R_662()) {
    jj_scanpos = xsp;
    if (jj_3R_663()) {
    jj_scanpos = xsp;
    if (jj_3R_664()) {
    jj_scanpos = xsp;
    if (jj_3R_665()) {
    jj_scanpos = xsp;
    if (jj_3R_666()) {
    jj_scanpos = xsp;
    if (jj_3R_667()) {
    jj_scanpos = xsp;
    if (jj_3R_668()) {
    jj_scanpos = xsp;
    if (jj_3R_669()) {
    jj_scanpos = xsp;
    if (jj_3R_670()) {
    jj_scanpos = xsp;
    if (jj_3R_671()) {
    jj_scanpos = xsp;
    if (jj_3R_672()) {
    jj_scanpos = xsp;
    if (jj_3R_673()) {
    jj_scanpos = xsp;
    if (jj_3R_674()) {
    jj_scanpos = xsp;
    if (jj_3R_675()) {
    jj_scanpos = xsp;
    if (jj_3R_676()) {
    jj_scanpos = xsp;
    if (jj_3R_677()) {
    jj_scanpos = xsp;
    if (jj_3R_678()) {
    jj_scanpos = xsp;
    if (jj_3R_679()) {
    jj_scanpos = xsp;
    if (jj_3R_680()) {
    jj_scanpos = xsp;
    if (jj_3R_681()) {
    jj_scanpos = xsp;
    if (jj_3R_682()) {
    jj_scanpos = xsp;
    if (jj_3R_683()) {
    jj_scanpos = xsp;
    if (jj_3R_684()) {
    jj_scanpos = xsp;
    if (jj_3R_685()) {
    jj_scanpos = xsp;
    if (jj_3R_686()) {
    jj_scanpos = xsp;
    if (jj_3R_687()) {
    jj_scanpos = xsp;
    if (jj_3R_688()) {
    jj_scanpos = xsp;
    if (jj_3R_689()) {
    jj_scanpos = xsp;
    if (jj_3R_690()) {
    jj_scanpos = xsp;
    if (jj_3R_691()) {
    jj_scanpos = xsp;
    if (jj_3R_692()) {
    jj_scanpos = xsp;
    if (jj_3R_693()) {
    jj_scanpos = xsp;
    if (jj_3R_694()) {
    jj_scanpos = xsp;
    if (jj_3R_695()) {
    jj_scanpos = xsp;
    if (jj_3R_696()) {
    jj_scanpos = xsp;
    if (jj_3R_697()) {
    jj_scanpos = xsp;
    if (jj_3R_698()) {
    jj_scanpos = xsp;
    if (jj_3R_699()) {
    jj_scanpos = xsp;
    if (jj_3R_700()) {
    jj_scanpos = xsp;
    if (jj_3R_701()) {
    jj_scanpos = xsp;
    if (jj_3R_702()) {
    jj_scanpos = xsp;
    if (jj_3R_703()) {
    jj_scanpos = xsp;
    if (jj_3R_704()) {
    jj_scanpos = xsp;
    if (jj_3R_705()) {
    jj_scanpos = xsp;
    if (jj_3R_706()) {
    jj_scanpos = xsp;
    if (jj_3R_707()) {
    jj_scanpos = xsp;
    if (jj_3R_708()) {
    jj_scanpos = xsp;
    if (jj_3R_709()) {
    jj_scanpos = xsp;
    if (jj_3R_710()) {
    jj_scanpos = xsp;
    if (jj_3R_711()) {
    jj_scanpos = xsp;
    if (jj_3R_712()) {
    jj_scanpos = xsp;
    if (jj_3R_713()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_scan_token(CURRENT_TIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_3R_191()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(DOUBLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_scan_token(CURRENT_DATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_71() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_299() {
    if (jj_scan_token(HEX_STRING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_68() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = (getToken(1).kind == CURRENT && getToken(2).kind == DATE);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = (getToken(1).kind == CURRENT && getToken(2).kind == TIME);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = (getToken(1).kind == CURRENT && getToken(2).kind == TIMESTAMP);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_338() {
    if (jj_scan_token(DELIMITED_IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_270() {
    if (jj_scan_token(XML)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_298() {
    if (jj_scan_token(STRING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_228() {
    if (jj_3R_286()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_322() {
    if (jj_3R_339()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_321() {
    if (jj_3R_338()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_503() {
    if (jj_scan_token(VALUES)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_268() {
    if (jj_scan_token(LONG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(DOUBLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_286() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) {
    jj_scanpos = xsp;
    if (jj_3R_322()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_320() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == PRECISION;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(TRUNCATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(REAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_scan_token(PERIOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_scan_token(PERIOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_218() {
    if (jj_scan_token(FIELD_REFERENCE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3_15()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_scan_token(FLOAT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_176() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(3).kind == LEFT_PAREN;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_295() {
    if (jj_scan_token(INT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_252() {
    if (jj_scan_token(LONGINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_300() {
    if (jj_scan_token(LEFT_BRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_3R_109()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_251() {
    if (jj_scan_token(SMALLINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_294() {
    if (jj_scan_token(INTEGER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_250() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_294()) {
    jj_scanpos = xsp;
    if (jj_3R_295()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_190() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_3R_64()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_3R_91()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_215() {
    if (jj_3R_190()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_277() {
    if (jj_3R_313()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_315() {
    if (jj_scan_token(MINUS_SIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_281() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_314()) {
    jj_scanpos = xsp;
    if (jj_3R_315()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_314() {
    if (jj_scan_token(PLUS_SIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_280() {
    if (jj_scan_token(DEC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_279() {
    if (jj_scan_token(DECIMAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_285() {
    if (jj_3R_192()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_278() {
    if (jj_scan_token(NUMERIC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_266() {
    if (jj_scan_token(DROP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_214() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_278()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) {
    jj_scanpos = xsp;
    if (jj_3R_280()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_173() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_30() {
    if (jj_3R_71()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_328() {
    if (jj_scan_token(APPROXIMATE_NUMERIC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_265() {
    if (jj_scan_token(DROP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_3R_281()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_58()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_3R_173()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_297() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_327()) {
    jj_scanpos = xsp;
    if (jj_3R_328()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_327() {
    if (jj_scan_token(EXACT_NUMERIC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_217()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_193() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_264() {
    if (jj_scan_token(DROP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_310() {
    if (jj_scan_token(NATIONAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_309() {
    if (jj_3R_172()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_263() {
    if (jj_scan_token(DROP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_308() {
    if (jj_scan_token(BINARY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_307() {
    if (jj_scan_token(NCLOB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_257() {
    if (jj_3R_301()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_306() {
    if (jj_scan_token(CLOB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_256() {
    if (jj_3R_300()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_262() {
    if (jj_scan_token(DROP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_198() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == CONSTRAINT;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_262()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == PRIMARY;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_263()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == FOREIGN;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_264()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == UNIQUE;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_305() {
    if (jj_scan_token(BLOB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_255() {
    if (jj_3R_299()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(NEW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_254() {
    if (jj_3R_298()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_296() {
    if (jj_3R_281()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_269() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) {
    jj_scanpos = xsp;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_253() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_296()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_297()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_194() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_349() {
    if (jj_scan_token(SESSION_USER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_3R_194()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_348() {
    if (jj_scan_token(CURRENT_USER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(NVARCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_175()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_40() {
    if (jj_3R_68()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_44() {
    if (jj_3R_79()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_336() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_347()) {
    jj_scanpos = xsp;
    if (jj_3R_348()) {
    jj_scanpos = xsp;
    if (jj_3R_349()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_347() {
    if (jj_scan_token(USER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_scan_token(NCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_317() {
    if (jj_3R_336()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_3R_181()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_283() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_316()) {
    jj_scanpos = xsp;
    if (jj_3R_317()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_316() {
    if (jj_3R_335()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(NATIONAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_3R_181()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_330() {
    if (jj_scan_token(FALSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(USER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_301() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_329() {
    if (jj_scan_token(TRUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == SCHEMA || getToken(2).kind == SQLID;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == DATE ||
                getToken(1).kind == TIME ||
                getToken(1).kind == TIMESTAMP;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_146()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == LEFT_PAREN ||
                                getToken(4).kind == LEFT_PAREN;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3_40()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_213() {
    if (jj_scan_token(CHARACTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_39() {
    if (jj_3R_76()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_172() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_3R_108()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_247() {
    if (jj_3R_293()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_3R_199()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_246() {
    if (jj_scan_token(TIMESTAMP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_3R_193()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_245() {
    if (jj_scan_token(DATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_3R_198()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_3R_172()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_244() {
    if (jj_scan_token(TIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_188() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) {
    jj_scanpos = xsp;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) {
    jj_scanpos = xsp;
    if (jj_3R_247()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(VARCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_scan_token(ALTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_3R_190()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_3R_270()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_3R_269()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_29() {
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_70() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_202() {
    if (jj_3R_268()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_55() {
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_3R_192()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_53() {
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_scan_token(ADD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_78() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == DROP
                && (getToken(2).kind == CONSTRAINT
                        || getToken(2).kind == PRIMARY
                        || getToken(2).kind == FOREIGN
                        || getToken(2).kind == UNIQUE
                        || getToken(2).kind == CHECK);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_3R_267()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_3R_57()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_201() {
    if (jj_scan_token(BOOLEAN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_12() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(3).kind != LARGE;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(2).kind != LARGE;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_53()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_160() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_3R_179()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_74() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = newInvocationFollows(1);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == LEFT_PAREN &&
                                (
                                        getToken(2).kind == SELECT ||
                                        getToken(2).kind == VALUES
                                );
    lookingAhead = false;
    if (!jj_semLA || jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_159() {
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_79() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = commonDatatypeName(false);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_159()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_160()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_43() {
    if (jj_3R_78()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_scan_token(LEFT_BRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_35() {
    if (jj_3R_74()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_34() {
    if (jj_3R_73()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_342() {
    if (jj_3R_489()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_324() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3R_342()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_292() {
    if (jj_3R_324()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_scan_token(ON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_scan_token(ON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_243() {
    if (jj_3R_292()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_241() {
    if (jj_scan_token(XMLEXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_240() {
    if (jj_scan_token(XMLSERIALIZE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == ON && getToken(2).kind == COMMIT;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_93()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == ON && getToken(2).kind == ROLLBACK;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_94()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_239() {
    if (jj_scan_token(XMLPARSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_186() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_52()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(DECLARE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_242() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_187() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_242()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_243()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_3R_189()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_28() {
    if (jj_3R_70()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_69() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_134() {
    if (jj_3R_188()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_3R_187()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_3R_186()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_3R_127()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_scan_token(LENGTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(VALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_276() {
    if (jj_scan_token(RELEASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_scan_token(COALESCE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_275() {
    if (jj_scan_token(ROLLBACK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_3R_69()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_3R_185()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_274() {
    if (jj_scan_token(SAVEPOINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public SQLParserTokenManager token_source;
  public Token token, jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[285];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static private int[] jj_la1_8;
  static private int[] jj_la1_9;
  static private int[] jj_la1_10;
  static private int[] jj_la1_11;
  static private int[] jj_la1_12;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
      jj_la1_5();
      jj_la1_6();
      jj_la1_7();
      jj_la1_8();
      jj_la1_9();
      jj_la1_10();
      jj_la1_11();
      jj_la1_12();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x60200000,0x0,0x0,0x60000000,0x0,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x80,0x80,0x0,0x0,0x80,0x80,0x0,0x0,0x0,0x0,0x202000,0x2000,0x0,0x400,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffffc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x10200000,0x200000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x880,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x202000,0x2000,0x0,0x0,0x2000,0x0,0x0,0x200000,0x0,0x0,0x0,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x240000,0x240000,0x40000,0x20000000,0x0,0x0,0x0,0x7fffffc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x240,0x0,0x0,0x0,0x0,0x0,0x200000,0x7fdfffc0,0x200000,0x7fffffc0,0x7fffffc0,0x200000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x40000000,0x0,0x44008000,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400004,0x0,0x0,0x0,0x10000,0x0,0x400004,0x0,0x0,0x0,0x0,0x400004,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x400205,0x8000201,0x201,0x201,0x8000000,0x201,0x8000201,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000000,0x3000000,0x0,0x0,0x3000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x400004,0x400004,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x100000,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400004,0x0,0x0,0x0,0x0,0x0,0x0,0x400004,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x20000,0x40000,0x80000,0x0,0x404004,0x400004,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400004,0x0,0x0,0x0,0x0,0x400004,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x400004,0x100000,0x0,0x0,0x200,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x8000000,0x0,0x200,0x0,0x0,0x1,0x0,0x0,0x400225,0x20,0x0,0x0,0x20,0x0,0x0,0x0,0x400004,0xffbffffb,0x400004,0xffffffff,0xffffffff,0x400004,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x20,0x2000,0x0,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x10,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x8,0x8,0x8,0x8,0x400,0x0,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x8000,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0xc0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x20,0x2000000,0x0,0xffffffff,0x0,0xffffffff,0xffffffff,0x0,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x400,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x50000000,0x0,0x0,0x0,0x0,0x10000000,0x1800,0x0,0x0,0x0,0x1800,0x1800,0x1800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x200010,0x0,0x0,0x200010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x4000002,0x0,0x0,0x0,0x0,0x0,0x0,0x4000002,0x0,0x400000,0x0,0x0,0x400000,0x0,0x0,0x0,0x8000000,0x8000000,0x400000,0x0,0x0,0x4000002,0x0,0x0,0x0,0x0,0x0,0x1800,0x4000002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x100080,0x0,0x100080,0x100000,0x0,0x0,0x0,0x0,0x0,0xb000000,0xb000000,0x3000000,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000010,0x10,0x10,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0xf7ffffff,0x8000000,0xffffffff,0xffffffff,0x8000000,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x80000000,0x0,0x0,0x0,0x400000,0x400000,0x0,0x80000000,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x80000000,0x40,0x0,0x2,0x40000,0x0,0x80000,0x4080002,0x4080002,0x4080002,0x0,0x4080002,0x4080002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x10,0x0,0x0,0x10,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x2,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x1000000,0x0,0x0,0x4,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x1000,0x40000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x400,0x0,0x0,0x80000,0x80000,0x40,0x0,0x40,0x40,0x0,0x10000001,0x4,0x10000001,0x0,0x0,0x0,0x4080002,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0xffffffff,0x0,0xffffffff,0xffffffff,0x0,};
   }
   private static void jj_la1_5() {
      jj_la1_5 = new int[] {0x80000010,0x0,0x80000010,0x0,0x0,0x2,0x20040002,0x40002,0x0,0x80000010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8020000,0x40000,0x0,0x0,0x0,0x0,0x8020000,0x0,0x0,0x20000000,0x0,0x8020000,0x400000,0x0,0x20000000,0x0,0x0,0x0,0x0,0x28020000,0x20000000,0x20000000,0x20000000,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x10,0x10,0x0,0x0,0x8020000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x4020,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4000020,0x8020000,0x8020000,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x80,0x8,0x0,0x4000000,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x8020000,0x0,0x0,0x0,0x0,0x0,0x0,0x8020000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8028000,0x8028000,0x8000,0x0,0x0,0x0,0x0,0xffffffff,0x40000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x8020000,0x0,0x0,0x0,0x0,0x8020000,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x4000000,0x0,0x4000000,0x0,0x8020000,0x40000,0x0,0x400000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x8020000,0x4000020,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x40,0x0,0x0,0x0,0x20000000,0x0,0x0,0x28020000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8020000,0xf7fdffff,0x8020000,0xffffffff,0xffffffff,0x8020000,};
   }
   private static void jj_la1_6() {
      jj_la1_6 = new int[] {0x10,0x0,0x10,0x0,0x0,0x100,0x100,0x100,0x0,0x10,0x400,0x0,0x400,0x0,0x0,0x0,0x800,0xffff8028,0x0,0x400,0x0,0x0,0x400,0xffff8028,0x0,0x0,0x0,0x1000,0xffff8028,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff8028,0x800,0x0,0x0,0x800,0x0,0x800,0x10480000,0x0,0x80,0x40,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x480000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x10,0x0,0x0,0xffff8028,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x20004000,0x0,0x2000002,0x0,0x0,0x18000,0x0,0x20004000,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x2,0xffff8028,0xffff8028,0x18001,0x8,0x0,0x30004000,0x40,0x0,0x0,0x0,0x0,0x0,0x30004000,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff8028,0x0,0x0,0x0,0x0,0x0,0x0,0xffff8028,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff8028,0xffff8028,0x0,0x40,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x44200000,0x40000000,0x44200000,0x200000,0x0,0xffff8028,0x0,0x0,0x44200000,0x0,0xffff8028,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x40000,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0xffff802a,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff8028,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0xffff8028,0x7fd7,0xffff8028,0xffffffff,0xffffffff,0xffff8028,};
   }
   private static void jj_la1_7() {
      jj_la1_7 = new int[] {0x0,0x0,0x88000000,0x0,0x0,0x0,0x0,0x0,0x0,0x88000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffef,0x0,0x0,0x0,0x0,0x0,0xffffffef,0x0,0x0,0x0,0x0,0xffffffef,0x0,0x88000000,0x0,0x400,0x0,0x0,0x0,0xffffffef,0x1,0x0,0x0,0x1,0x0,0x1,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x10000,0x0,0x0,0x0,0x0,0x2002,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffef,0xffffffef,0x2002,0x100,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffef,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffef,0xffffffef,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x40000000,0x0,0x0,0x20004040,0x0,0x20004040,0x20000000,0x0,0xffffffff,0x10,0x10,0x20004040,0x0,0xffffffef,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x10000000,0x0,0x0,0x0,0x0,0xffffffef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffef,0x0,0x0,0x800,0x0,0x4,0x0,0x0,0xffffffef,0x10,0xffffffef,0xffffffff,0xffffffff,0xffffffef,};
   }
   private static void jj_la1_8() {
      jj_la1_8 = new int[] {0x0,0x0,0x2000000,0x80000,0x0,0x2000,0x2000,0x2000,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x2000000,0x2000000,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x1018000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x80000000,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0xc060000,0x60000,0x7fc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x1cffffff,0x20000000,0x0,0x0,0x18000,0x0,0x0,0x0,0x0,0x0,0x80000000,0x18000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x2,0x200000,0x0,0x0,0x0,0x1cffffff,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1cffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x1cffffff,0xe3000000,0x1cffffff,0xffffffff,0xffffffff,0x1cffffff,};
   }
   private static void jj_la1_9() {
      jj_la1_9 = new int[] {0x0,0x2000000,0x0,0x0,0x2000000,0x0,0x200000,0x200000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbf01,0x200000,0x0,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x0,0x0,0x0,0x0,0x11,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffbfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x180000e,0x6,0x0,0x0,0x7fffbf01,0x7fffbf01,0x180000e,0xe0,0x0,0x0,0x0,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbf01,0x7fffbf01,0x0,0x0,0x0,0x0,0x0,0xffffbfff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x100,0x0,0x0,0x0,0x60000000,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x80000,0x0,0x0,0x0,0x0,0x0,0x12000,0x2000,0x0,0x0,0x0,0x0,0x0,0x7fffbf01,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x7fffbf01,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbf01,0x800000fe,0x7fffbf01,0xffffbfff,0xffffbfff,0x7fffbf01,};
   }
   private static void jj_la1_10() {
      jj_la1_10 = new int[] {0x0,0x800,0x0,0x0,0x800,0x4000000,0x4000000,0x4000000,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x3fffffef,0x0,0x0,0x80,0x0,0x0,0x3fffffef,0x0,0x0,0x0,0x0,0x3fffffef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fffffef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fffffef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fffffff,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x100000,0x0,0x3fffffef,0x3fffffef,0x8400000,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x3fffffef,0x0,0x0,0x80,0x0,0x0,0x80,0x3fffffef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fffffef,0x3fffffef,0x0,0x0,0x0,0x0,0x80,0x3fffffff,0x0,0x0,0x80,0x202120,0x0,0x202120,0x0,0x0,0x3fffffff,0x10,0x10,0x202120,0x0,0x3fffffef,0x0,0x400,0x0,0x0,0x0,0x0,0xc,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x1000,0x0,0x10018000,0x10018000,0x0,0x0,0x0,0x100000,0x0,0x3fffffef,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x0,0x20000,0x0,0x3fffffef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fffffef,0x10,0x3fffffef,0x3fffffff,0x3fffffff,0x3fffffef,};
   }
   private static void jj_la1_11() {
      jj_la1_11 = new int[] {0x10,0x0,0x400014,0x0,0x0,0x0,0x0,0x0,0x0,0x400014,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x20000000,0x400004,0x400000,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x10,0x0,0x10,0x0,0x0,0x10,0x10,0x10,0x10,0x0,0x0,0x0,0x100,0x10,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x400,0x20000000,0x0,0x280,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x40,0x100,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f8000,0x4,0x4,0x0,0x3f8000,0x280,0x280,0x8000840,0x8000840,0x280,0x10000400,0x400,0x0,0x20000000,0x0,0x100,0x0,0x0,0x0,0x0,0x100,0x0,0x100,0x0,0x0,0x100,0x0,0x0,0x0,0x400284,0x20000010,0x20000000,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x120,0x0,0x400000,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x0,0x100,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x4,0x0,0x10,0x0,0x20000000,0x0,0x10,0x0,0x0,0x10,0x0,0x20000000,0x10,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x40,0x20000000,0x20000000,0x0,0x0,0x0,0x100,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x20000000,0x0,0x0,0x0,0x100,0x20000000,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x100,0x0,0x0,0x0,0x284,0x280,0x284,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x20400000,0x400284,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x20000000,0x20000000,0x20000000,};
   }
   private static void jj_la1_12() {
      jj_la1_12 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x50,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x390,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x98,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x390,0x0,0x390,0x210,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x88,0x390,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x8,0x8,0x8,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[44];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public SQLParser(CharStream stream) {
    token_source = new SQLParserTokenManager(stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 285; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 285; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public SQLParser(SQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 285; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(SQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 285; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {
        int[] oldentry = (int[])(enum.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[406];
    for (int i = 0; i < 406; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 285; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
          if ((jj_la1_8[i] & (1<<j)) != 0) {
            la1tokens[256+j] = true;
          }
          if ((jj_la1_9[i] & (1<<j)) != 0) {
            la1tokens[288+j] = true;
          }
          if ((jj_la1_10[i] & (1<<j)) != 0) {
            la1tokens[320+j] = true;
          }
          if ((jj_la1_11[i] & (1<<j)) != 0) {
            la1tokens[352+j] = true;
          }
          if ((jj_la1_12[i] & (1<<j)) != 0) {
            la1tokens[384+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 406; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 44; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
